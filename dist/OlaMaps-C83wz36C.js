import { g as Pg, m as V, O as Er } from "./maplibre-gl-BIFSxk4Y.js";
import { default3dTIleset as Og, getOlaMapIcon as xg, defaultStyleJson as Ng } from "./index.js";
function Fg(t, e) {
  for (var s = 0; s < e.length; s++) {
    const n = e[s];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const r in n)
        if (r !== "default" && !(r in t)) {
          const i = Object.getOwnPropertyDescriptor(n, r);
          i && Object.defineProperty(t, r, i.get ? i : {
            enumerable: !0,
            get: () => n[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
async function sr(t, e, s, n) {
  return n._parse(t, e, s, n);
}
function se(t, e) {
  if (!t)
    throw new Error(e || "loader assertion failed.");
}
const Ri = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), wl = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
wl && parseFloat(wl[1]);
const Il = globalThis, vl = globalThis.process || {}, Dg = globalThis.navigator || {};
function Vf(t) {
  if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron)
    return !0;
  const s = typeof navigator < "u" && navigator.userAgent;
  return !!(s && s.indexOf("Electron") >= 0);
}
function Zt() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !process?.browser) || Vf();
}
function Ug(t) {
  return Zt() ? Vf() ? "Electron" : (Dg.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const Hf = "4.0.7";
function Lg(t) {
  try {
    const e = window[t], s = "__storage_test__";
    return e.setItem(s, s), e.removeItem(s), e;
  } catch {
    return null;
  }
}
class kg {
  constructor(e, s, n = "sessionStorage") {
    this.storage = Lg(n), this.id = e, this.config = s, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const s = JSON.stringify(this.config);
      this.storage.setItem(this.id, s);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const s = this.storage.getItem(this.id);
      e = s ? JSON.parse(s) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function Vg(t) {
  let e;
  return t < 10 ? e = `${t.toFixed(2)}ms` : t < 100 ? e = `${t.toFixed(1)}ms` : t < 1e3 ? e = `${t.toFixed(0)}ms` : e = `${(t / 1e3).toFixed(2)}s`, e;
}
function Hg(t, e = 8) {
  const s = Math.max(e - t.length, 0);
  return `${" ".repeat(s)}${t}`;
}
var oi;
(function(t) {
  t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(oi || (oi = {}));
const zg = 10;
function Bl(t) {
  return typeof t != "string" ? t : (t = t.toUpperCase(), oi[t] || oi.WHITE);
}
function jg(t, e, s) {
  return !Zt && typeof t == "string" && (e && (t = `\x1B[${Bl(e)}m${t}\x1B[39m`), s && (t = `\x1B[${Bl(s) + zg}m${t}\x1B[49m`)), t;
}
function Wg(t, e = ["constructor"]) {
  const s = Object.getPrototypeOf(t), n = Object.getOwnPropertyNames(s), r = t;
  for (const i of n) {
    const o = r[i];
    typeof o == "function" && (e.find((a) => i === a) || (r[i] = o.bind(t)));
  }
}
function Za(t, e) {
  if (!t)
    throw new Error("Assertion failed");
}
function ws() {
  let t;
  if (Zt() && Il.performance)
    t = Il?.performance?.now?.();
  else if ("hrtime" in vl) {
    const e = vl?.hrtime?.();
    t = e[0] * 1e3 + e[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
const Is = {
  debug: Zt() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, Xg = {
  enabled: !0,
  level: 0
};
function vs() {
}
const Ml = {}, Pl = { once: !0 };
class ln {
  constructor({ id: e } = { id: "" }) {
    this.VERSION = Hf, this._startTs = ws(), this._deltaTs = ws(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new kg(`__probe-${this.id}__`, Xg), this.timeStamp(`${this.id} started`), Wg(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((ws() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((ws() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(e = !0) {
    return this._storage.setConfiguration({ enabled: e }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({ level: e }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, s) {
    this._storage.setConfiguration({ [e]: s });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, s) {
    if (!e)
      throw new Error(s || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, Is.warn, arguments, Pl);
  }
  error(e) {
    return this._getLogFunction(0, e, Is.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, s) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${s}\` instead`);
  }
  /** Print a removal warning */
  removed(e, s) {
    return this.error(`\`${e}\` has been removed. Use \`${s}\` instead`);
  }
  probe(e, s) {
    return this._getLogFunction(e, s, Is.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, s) {
    return this._getLogFunction(e, s, Is.debug, arguments);
  }
  info(e, s) {
    return this._getLogFunction(e, s, console.info, arguments);
  }
  once(e, s) {
    return this._getLogFunction(e, s, Is.debug || Is.info, arguments, Pl);
  }
  /** Logs an object as a table */
  table(e, s, n) {
    return s ? this._getLogFunction(e, s, console.table || vs, n && [n], {
      tag: $g(s)
    }) : vs;
  }
  time(e, s) {
    return this._getLogFunction(e, s, console.time ? console.time : console.info);
  }
  timeEnd(e, s) {
    return this._getLogFunction(e, s, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, s) {
    return this._getLogFunction(e, s, console.timeStamp || vs);
  }
  group(e, s, n = { collapsed: !1 }) {
    const r = Ol({ logLevel: e, message: s, opts: n }), { collapsed: i } = n;
    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);
  }
  groupCollapsed(e, s, n = {}) {
    return this.group(e, s, Object.assign({}, n, { collapsed: !0 }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || vs);
  }
  // EXPERIMENTAL
  withGroup(e, s, n) {
    this.group(e, s)();
    try {
      n();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= zf(e);
  }
  _getLogFunction(e, s, n, r, i) {
    if (this._shouldLog(e)) {
      i = Ol({ logLevel: e, message: s, args: r, opts: i }), n = n || i.method, Za(n), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = ws();
      const o = i.tag || i.message;
      if (i.once && o)
        if (!Ml[o])
          Ml[o] = ws();
        else
          return vs;
      return s = Gg(this.id, i.message, i), n.bind(console, s, ...i.args);
    }
    return vs;
  }
}
ln.VERSION = Hf;
function zf(t) {
  if (!t)
    return 0;
  let e;
  switch (typeof t) {
    case "number":
      e = t;
      break;
    case "object":
      e = t.logLevel || t.priority || 0;
      break;
    default:
      return 0;
  }
  return Za(Number.isFinite(e) && e >= 0), e;
}
function Ol(t) {
  const { logLevel: e, message: s } = t;
  t.logLevel = zf(e);
  const n = t.args ? Array.from(t.args) : [];
  for (; n.length && n.shift() !== s; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      s !== void 0 && n.unshift(s), t.message = e;
      break;
    case "object":
      Object.assign(t, e);
      break;
  }
  typeof t.message == "function" && (t.message = t.message());
  const r = typeof t.message;
  return Za(r === "string" || r === "object"), Object.assign(t, { args: n }, t.opts);
}
function Gg(t, e, s) {
  if (typeof e == "string") {
    const n = s.time ? Hg(Vg(s.total)) : "";
    e = s.time ? `${t}: ${n}  ${e}` : `${t}: ${e}`, e = jg(e, s.color, s.background);
  }
  return e;
}
function $g(t) {
  for (const e in t)
    for (const s in t[e])
      return s || "untitled";
  return "empty";
}
globalThis.probe = {};
const jf = new ln({ id: "@probe.gl/log" }), no = "4.3.1", Kg = no[0] >= "0" && no[0] <= "9" ? `v${no}` : "";
function Yg() {
  const t = new ln({ id: "loaders.gl" });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = t, globalThis.loaders.version = Kg, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = t, t;
}
const Jg = Yg();
function qg(t, e) {
  return Wf(t || {}, e);
}
function Wf(t, e, s = 0) {
  if (s > 3)
    return e;
  const n = { ...t };
  for (const [r, i] of Object.entries(e))
    i && typeof i == "object" && !Array.isArray(i) ? n[r] = Wf(n[r] || {}, e[r], s + 1) : n[r] = e[r];
  return n;
}
function Zg(t) {
  globalThis.loaders ||= {}, globalThis.loaders.modules ||= {}, Object.assign(globalThis.loaders.modules, t);
}
function Qg(t) {
  return globalThis.loaders?.modules?.[t] || null;
}
const em = "latest";
function tm() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.1"), globalThis._loadersgl_.version;
}
const Xf = tm();
function Bt(t, e) {
  if (!t)
    throw new Error(e || "loaders.gl assertion failed.");
}
const ze = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), Qa = typeof importScripts == "function", sm = typeof window < "u" && typeof window.orientation < "u", xl = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
xl && parseFloat(xl[1]);
class nm {
  name;
  workerThread;
  isRunning = !0;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(e, s) {
    this.name = e, this.workerThread = s, this.result = new Promise((n, r) => {
      this._resolve = n, this._reject = r;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, s) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: s
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    Bt(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    Bt(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class ro {
  terminate() {
  }
}
const io = /* @__PURE__ */ new Map();
function rm(t) {
  Bt(t.source && !t.url || !t.source && t.url);
  let e = io.get(t.source || t.url);
  return e || (t.url && (e = im(t.url), io.set(t.url, e)), t.source && (e = Gf(t.source), io.set(t.source, e))), Bt(e), e;
}
function im(t) {
  if (!t.startsWith("http"))
    return t;
  const e = om(t);
  return Gf(e);
}
function Gf(t) {
  const e = new Blob([t], { type: "application/javascript" });
  return URL.createObjectURL(e);
}
function om(t) {
  return `try {
  importScripts('${t}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function $f(t, e = !0, s) {
  const n = s || /* @__PURE__ */ new Set();
  if (t) {
    if (Nl(t))
      n.add(t);
    else if (Nl(t.buffer))
      n.add(t.buffer);
    else if (!ArrayBuffer.isView(t)) {
      if (e && typeof t == "object")
        for (const r in t)
          $f(t[r], e, n);
    }
  }
  return s === void 0 ? Array.from(n) : [];
}
function Nl(t) {
  return t ? t instanceof ArrayBuffer || typeof MessagePort < "u" && t instanceof MessagePort || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas : !1;
}
const oo = () => {
};
class ca {
  name;
  source;
  url;
  terminated = !1;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && ze || typeof ro < "u" && !ze;
  }
  constructor(e) {
    const { name: s, source: n, url: r } = e;
    Bt(n || r), this.name = s, this.source = n, this.url = r, this.onMessage = oo, this.onError = (i) => console.log(i), this.worker = ze ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = oo, this.onError = oo, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, s) {
    s = s || $f(e), this.worker.postMessage(e, s);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let s = "Failed to load ";
    return s += `worker ${this.name} from ${this.url}. `, e.message && (s += `${e.message} in `), e.lineno && (s += `:${e.lineno}:${e.colno}`), new Error(s);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = rm({ source: this.source, url: this.url });
    const e = new Worker(this._loadableURL, { name: this.name });
    return e.onmessage = (s) => {
      s.data ? this.onMessage(s.data) : this.onError(new Error("No data received"));
    }, e.onerror = (s) => {
      this.onError(this._getErrorFromErrorEvent(s)), this.terminated = !0;
    }, e.onmessageerror = (s) => console.error(s), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const n = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new ro(n, { eval: !1 });
    } else if (this.source)
      e = new ro(this.source, { eval: !0 });
    else
      throw new Error("no worker");
    return e.on("message", (s) => {
      this.onMessage(s);
    }), e.on("error", (s) => {
      this.onError(s);
    }), e.on("exit", (s) => {
    }), e;
  }
}
class am {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = !0;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = !1;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return ca.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = { ...this.props, ...e }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e, s = (r, i, o) => r.done(o), n = (r, i) => r.error(i)) {
    const r = new Promise((i) => (this.jobQueue.push({ name: e, onMessage: s, onError: n, onStart: i }), this));
    return this._startQueuedJob(), await r;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const s = this.jobQueue.shift();
    if (s) {
      this.onDebug({
        message: "Starting job",
        name: s.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const n = new nm(s.name, e);
      e.onMessage = (r) => s.onMessage(n, r.type, r.payload), e.onError = (r) => s.onError(n, r), s.onStart(n);
      try {
        await n.result;
      } catch (r) {
        console.error(`Worker exception: ${r}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !ze || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new ca({ name: e, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return sm ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const cm = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Ht {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return ca.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(e = {}) {
    return Ht._workerFarm = Ht._workerFarm || new Ht({}), Ht._workerFarm.setProps(e), Ht._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    this.props = { ...cm }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = { ...this.props, ...e };
    for (const s of this.workerPools.values())
      s.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const { name: s, source: n, url: r } = e;
    let i = this.workerPools.get(s);
    return i || (i = new am({
      name: s,
      source: n,
      url: r
    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(s, i)), i;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function lm(t, e = {}) {
  const s = e[t.id] || {}, n = ze ? `${t.id}-worker.js` : `${t.id}-worker-node.js`;
  let r = s.workerUrl;
  if (!r && t.id === "compression" && (r = e.workerUrl), e._workerType === "test" && (ze ? r = `modules/${t.module}/dist/${n}` : r = `modules/${t.module}/src/workers/${t.id}-worker-node.ts`), !r) {
    let i = t.version;
    i === "latest" && (i = em);
    const o = i ? `@${i}` : "";
    r = `https://unpkg.com/@loaders.gl/${t.module}${o}/dist/${n}`;
  }
  return Bt(r), r;
}
function hm(t, e = Xf) {
  Bt(t, "no worker provided");
  const s = t.version;
  return !(!e || !s);
}
const ao = {};
async function ps(t, e = null, s = {}, n = null) {
  return e && (t = um(t, e, s, n)), ao[t] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  ao[t] || fm(t), await ao[t];
}
function um(t, e, s = {}, n = null) {
  if (!s.useLocalLibraries && t.startsWith("http"))
    return t;
  n = n || t;
  const r = s.modules || {};
  return r[n] ? r[n] : ze ? s.CDN ? (Bt(s.CDN.startsWith("http")), `${s.CDN}/${e}@${Xf}/dist/libs/${n}`) : Qa ? `../src/libs/${n}` : `modules/${e}/src/libs/${n}` : `modules/${e}/dist/libs/${n}`;
}
async function fm(t) {
  if (t.endsWith("wasm"))
    return await pm(t);
  if (!ze)
    try {
      const { requireFromFile: s } = globalThis.loaders || {};
      return await s?.(t);
    } catch (s) {
      return console.error(s), null;
    }
  if (Qa)
    return importScripts(t);
  const e = await _m(t);
  return dm(e, t);
}
function dm(t, e) {
  if (!ze) {
    const { requireFromString: n } = globalThis.loaders || {};
    return n?.(t, e);
  }
  if (Qa)
    return eval.call(globalThis, t), null;
  const s = document.createElement("script");
  s.id = e;
  try {
    s.appendChild(document.createTextNode(t));
  } catch {
    s.text = t;
  }
  return document.body.appendChild(s), null;
}
async function pm(t) {
  const { readFileAsArrayBuffer: e } = globalThis.loaders || {};
  return ze || !e || t.startsWith("http") ? await (await fetch(t)).arrayBuffer() : await e(t);
}
async function _m(t) {
  const { readFileAsText: e } = globalThis.loaders || {};
  return ze || !e || t.startsWith("http") ? await (await fetch(t)).text() : await e(t);
}
function gm(t, e) {
  return !Ht.isSupported() || !ze && !e?._nodeWorkers ? !1 : t.worker && e?.worker;
}
async function mm(t, e, s, n, r) {
  const i = t.id, o = lm(t, s), c = Ht.getWorkerFarm(s).getWorkerPool({ name: i, url: o });
  s = JSON.parse(JSON.stringify(s)), n = JSON.parse(JSON.stringify(n || {}));
  const l = await c.startJob(
    "process-on-worker",
    // @ts-expect-error
    Am.bind(null, r)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return l.postMessage("process", {
    // @ts-ignore
    input: e,
    options: s,
    context: n
  }), await (await l.result).result;
}
async function Am(t, e, s, n) {
  switch (s) {
    case "done":
      e.done(n);
      break;
    case "error":
      e.error(new Error(n.error));
      break;
    case "process":
      const { id: r, input: i, options: o } = n;
      try {
        const a = await t(i, o);
        e.postMessage("done", { id: r, result: a });
      } catch (a) {
        const c = a instanceof Error ? a.message : "unknown error";
        e.postMessage("error", { id: r, error: c });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${s}`);
  }
}
function Tm(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? Fl(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? Fl(t, 0, e) : "";
}
function Fl(t, e, s) {
  if (t.byteLength <= e + s)
    return "";
  const n = new DataView(t);
  let r = "";
  for (let i = 0; i < s; i++)
    r += String.fromCharCode(n.getUint8(e + i));
  return r;
}
function ym(t) {
  try {
    return JSON.parse(t);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${Tm(t)}"`);
  }
}
function bm(t, e, s) {
  if (s = s || t.byteLength, t.byteLength < s || e.byteLength < s)
    return !1;
  const n = new Uint8Array(t), r = new Uint8Array(e);
  for (let i = 0; i < n.length; ++i)
    if (n[i] !== r[i])
      return !1;
  return !0;
}
function Em(...t) {
  return Cm(t);
}
function Cm(t) {
  const e = t.map((i) => i instanceof ArrayBuffer ? new Uint8Array(i) : i), s = e.reduce((i, o) => i + o.byteLength, 0), n = new Uint8Array(s);
  let r = 0;
  for (const i of e)
    n.set(i, r), r += i.byteLength;
  return n.buffer;
}
function ec(t, e, s) {
  const n = s !== void 0 ? new Uint8Array(t).subarray(e, e + s) : new Uint8Array(t).subarray(e);
  return new Uint8Array(n).buffer;
}
function nr(t, e) {
  return se(t >= 0), se(e > 0), t + (e - 1) & -4;
}
function Sm(t, e, s) {
  let n;
  if (t instanceof ArrayBuffer)
    n = new Uint8Array(t);
  else {
    const r = t.byteOffset, i = t.byteLength;
    n = new Uint8Array(t.buffer || t.arrayBuffer, r, i);
  }
  return e.set(n, s), s + nr(n.byteLength, 4);
}
async function Rm(t) {
  const e = [];
  for await (const s of t)
    e.push(s);
  return Em(...e);
}
function Dl() {
  let t;
  if (typeof window < "u" && window.performance)
    t = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    t = e[0] * 1e3 + e[1] / 1e6;
  } else
    t = Date.now();
  return t;
}
class Ul {
  constructor(e, s) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = s, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = Dl(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(Dl() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class hn {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e, s = "count") {
    return this._getOrCreate({ name: e, type: s });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const s of Object.values(this.stats))
      e(s);
  }
  getTable() {
    const e = {};
    return this.forEach((s) => {
      e[s.name] = {
        time: s.time || 0,
        count: s.count || 0,
        average: s.getAverageTime() || 0,
        hz: s.getHz() || 0
      };
    }), e;
  }
  _initializeStats(e = []) {
    e.forEach((s) => this._getOrCreate(s));
  }
  _getOrCreate(e) {
    const { name: s, type: n } = e;
    let r = this.stats[s];
    return r || (e instanceof Ul ? r = e : r = new Ul(s, n), this.stats[s] = r), r;
  }
}
const wm = "Queued Requests", Im = "Active Requests", vm = "Cancelled Requests", Bm = "Queued Requests Ever", Mm = "Active Requests Ever", Pm = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class Om {
  props;
  stats;
  activeRequestCount = 0;
  /** Tracks the number of active requests and prioritizes/cancels queued requests. */
  requestQueue = [];
  requestMap = /* @__PURE__ */ new Map();
  updateTimer = null;
  constructor(e = {}) {
    this.props = { ...Pm, ...e }, this.stats = new hn({ id: this.props.id }), this.stats.get(wm), this.stats.get(Im), this.stats.get(vm), this.stats.get(Bm), this.stats.get(Mm);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e, s = () => 0) {
    if (!this.props.throttleRequests)
      return Promise.resolve({ done: () => {
      } });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const n = { handle: e, priority: 0, getPriority: s }, r = new Promise((i) => (n.resolve = i, n));
    return this.requestQueue.push(n), this.requestMap.set(e, r), this._issueNewRequests(), r;
  }
  // PRIVATE
  _issueRequest(e) {
    const { handle: s, resolve: n } = e;
    let r = !1;
    const i = () => {
      r || (r = !0, this.requestMap.delete(s), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, n ? n({ done: i }) : Promise.resolve({ done: i });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let s = 0; s < e; ++s) {
        const n = this.requestQueue.shift();
        n && this._issueRequest(n);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let s = 0; s < e.length; ++s) {
      const n = e[s];
      this._updateRequest(n) || (e.splice(s, 1), this.requestMap.delete(n.handle), s--);
    }
    e.sort((s, n) => s.priority - n.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let xm = "";
const Ll = {};
function Nm(t) {
  for (const e in Ll)
    if (t.startsWith(e)) {
      const s = Ll[e];
      t = t.replace(e, s);
    }
  return !t.startsWith("http://") && !t.startsWith("https://") && (t = `${xm}${t}`), t;
}
function Fm(t) {
  return t && typeof t == "object" && t.isBuffer;
}
function Kf(t) {
  if (Fm(t))
    return t;
  if (t instanceof ArrayBuffer)
    return t;
  if (ArrayBuffer.isView(t))
    return t.byteOffset === 0 && t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
  if (typeof t == "string") {
    const e = t;
    return new TextEncoder().encode(e).buffer;
  }
  if (t && typeof t == "object" && t._toArrayBuffer)
    return t._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function Dm() {
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const t = window.location?.pathname;
  return t?.slice(0, t.lastIndexOf("/") + 1) || "";
}
function Yf(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(e + 1) : "";
}
function tc(t) {
  const e = t ? t.lastIndexOf("/") : -1;
  return e >= 0 ? t.substr(0, e) : "";
}
function Um(...t) {
  const e = [];
  for (let i = 0; i < t.length; i++)
    e[i] = t[i];
  let s = "", n = !1, r;
  for (let i = e.length - 1; i >= -1 && !n; i--) {
    let o;
    i >= 0 ? o = e[i] : (r === void 0 && (r = Dm()), o = r), o.length !== 0 && (s = `${o}/${s}`, n = o.charCodeAt(0) === On);
  }
  return s = Lm(s, !n), n ? `/${s}` : s.length > 0 ? s : ".";
}
const On = 47, co = 46;
function Lm(t, e) {
  let s = "", n = -1, r = 0, i, o = !1;
  for (let a = 0; a <= t.length; ++a) {
    if (a < t.length)
      i = t.charCodeAt(a);
    else {
      if (i === On)
        break;
      i = On;
    }
    if (i === On) {
      if (!(n === a - 1 || r === 1)) if (n !== a - 1 && r === 2) {
        if (s.length < 2 || !o || s.charCodeAt(s.length - 1) !== co || s.charCodeAt(s.length - 2) !== co) {
          if (s.length > 2) {
            const c = s.length - 1;
            let l = c;
            for (; l >= 0 && s.charCodeAt(l) !== On; --l)
              ;
            if (l !== c) {
              s = l === -1 ? "" : s.slice(0, l), n = a, r = 0, o = !1;
              continue;
            }
          } else if (s.length === 2 || s.length === 1) {
            s = "", n = a, r = 0, o = !1;
            continue;
          }
        }
        e && (s.length > 0 ? s += "/.." : s = "..", o = !0);
      } else {
        const c = t.slice(n + 1, a);
        s.length > 0 ? s += `/${c}` : s = c, o = !1;
      }
      n = a, r = 0;
    } else i === co && r !== -1 ? ++r : r = -1;
  }
  return s;
}
const km = (t) => typeof t == "boolean", Ln = (t) => typeof t == "function", rr = (t) => t !== null && typeof t == "object", kl = (t) => rr(t) && t.constructor === {}.constructor, Vm = (t) => !!t && typeof t[Symbol.iterator] == "function", Hm = (t) => t && typeof t[Symbol.asyncIterator] == "function", ys = (t) => typeof Response < "u" && t instanceof Response || t && t.arrayBuffer && t.text && t.json, bs = (t) => typeof Blob < "u" && t instanceof Blob, zm = (t) => t && typeof t == "object" && t.isBuffer, jm = (t) => typeof ReadableStream < "u" && t instanceof ReadableStream || rr(t) && Ln(t.tee) && Ln(t.cancel) && Ln(t.getReader), Wm = (t) => rr(t) && Ln(t.read) && Ln(t.pipe) && km(t.readable), Jf = (t) => jm(t) || Wm(t);
class Xm extends Error {
  constructor(e, s) {
    super(e), this.reason = s.reason, this.url = s.url, this.response = s.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const Gm = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, $m = /^([-\w.]+\/[-\w.+]+)/;
function Vl(t, e) {
  return t.toLowerCase() === e.toLowerCase();
}
function Km(t) {
  const e = $m.exec(t);
  return e ? e[1] : t;
}
function Hl(t) {
  const e = Gm.exec(t);
  return e ? e[1] : "";
}
const qf = /\?.*/;
function Ym(t) {
  const e = t.match(qf);
  return e && e[0];
}
function sc(t) {
  return t.replace(qf, "");
}
function Jm(t) {
  if (t.length < 50)
    return t;
  const e = t.slice(t.length - 15);
  return `${t.substr(0, 32)}...${e}`;
}
function wi(t) {
  return ys(t) ? t.url : bs(t) ? t.name || "" : typeof t == "string" ? t : "";
}
function nc(t) {
  if (ys(t)) {
    const e = t, s = e.headers.get("content-type") || "", n = sc(e.url);
    return Km(s) || Hl(n);
  }
  return bs(t) ? t.type || "" : typeof t == "string" ? Hl(t) : "";
}
function qm(t) {
  return ys(t) ? t.headers["content-length"] || -1 : bs(t) ? t.size : typeof t == "string" ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1;
}
async function Zf(t) {
  if (ys(t))
    return t;
  const e = {}, s = qm(t);
  s >= 0 && (e["content-length"] = String(s));
  const n = wi(t), r = nc(t);
  r && (e["content-type"] = r);
  const i = await eA(t);
  i && (e["x-first-bytes"] = i), typeof t == "string" && (t = new TextEncoder().encode(t));
  const o = new Response(t, { headers: e });
  return Object.defineProperty(o, "url", { value: n }), o;
}
async function Zm(t) {
  if (!t.ok)
    throw await Qm(t);
}
async function Qm(t) {
  const e = Jm(t.url);
  let s = `Failed to fetch resource (${t.status}) ${t.statusText}: ${e}`;
  s = s.length > 100 ? `${s.slice(0, 100)}...` : s;
  const n = {
    reason: t.statusText,
    url: t.url,
    response: t
  };
  try {
    const r = t.headers.get("Content-Type");
    n.reason = !t.bodyUsed && r?.includes("application/json") ? await t.json() : await t.text();
  } catch {
  }
  return new Xm(s, n);
}
async function eA(t) {
  if (typeof t == "string")
    return `data:,${t.slice(0, 5)}`;
  if (t instanceof Blob) {
    const s = t.slice(0, 5);
    return await new Promise((n) => {
      const r = new FileReader();
      r.onload = (i) => n(i?.target?.result), r.readAsDataURL(s);
    });
  }
  if (t instanceof ArrayBuffer) {
    const s = t.slice(0, 5);
    return `data:base64,${tA(s)}`;
  }
  return null;
}
function tA(t) {
  let e = "";
  const s = new Uint8Array(t);
  for (let n = 0; n < s.byteLength; n++)
    e += String.fromCharCode(s[n]);
  return btoa(e);
}
function sA(t) {
  return !nA(t) && !rA(t);
}
function nA(t) {
  return t.startsWith("http:") || t.startsWith("https:");
}
function rA(t) {
  return t.startsWith("data:");
}
async function zl(t, e) {
  if (typeof t == "string") {
    const s = Nm(t);
    return sA(s) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(s, e) : await fetch(s, e);
  }
  return await Zf(t);
}
const jl = new ln({ id: "loaders.gl" });
class iA {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class oA {
  console;
  constructor() {
    this.console = console;
  }
  log(...e) {
    return this.console.log.bind(this.console, ...e);
  }
  info(...e) {
    return this.console.info.bind(this.console, ...e);
  }
  warn(...e) {
    return this.console.warn.bind(this.console, ...e);
  }
  error(...e) {
    return this.console.error.bind(this.console, ...e);
  }
}
const Qf = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new oA(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: Ri,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, aA = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function ed() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders: t } = globalThis;
  return t._state || (t._state = {}), t._state;
}
function td() {
  const t = ed();
  return t.globalOptions = t.globalOptions || { ...Qf }, t.globalOptions;
}
function cA(t, e, s, n) {
  return s = s || [], s = Array.isArray(s) ? s : [s], lA(t, s), uA(e, t, n);
}
function lA(t, e) {
  Wl(t, null, Qf, aA, e);
  for (const s of e) {
    const n = t && t[s.id] || {}, r = s.options && s.options[s.id] || {}, i = s.deprecatedOptions && s.deprecatedOptions[s.id] || {};
    Wl(n, s.id, r, i, e);
  }
}
function Wl(t, e, s, n, r) {
  const i = e || "Top level", o = e ? `${e}.` : "";
  for (const a in t) {
    const c = !e && rr(t[a]), l = a === "baseUri" && !e, h = a === "workerUrl" && e;
    if (!(a in s) && !l && !h) {
      if (a in n)
        jl.warn(`${i} loader option '${o}${a}' no longer supported, use '${n[a]}'`)();
      else if (!c) {
        const u = hA(a, r);
        jl.warn(`${i} loader option '${o}${a}' not recognized. ${u}`)();
      }
    }
  }
}
function hA(t, e) {
  const s = t.toLowerCase();
  let n = "";
  for (const r of e)
    for (const i in r.options) {
      if (t === i)
        return `Did you mean '${r.id}.${i}'?`;
      const o = i.toLowerCase();
      (s.startsWith(o) || o.startsWith(s)) && (n = n || `Did you mean '${r.id}.${i}'?`);
    }
  return n;
}
function uA(t, e, s) {
  const r = { ...t.options || {} };
  return fA(r, s), r.log === null && (r.log = new iA()), Xl(r, td()), Xl(r, e), r;
}
function Xl(t, e) {
  for (const s in e)
    if (s in e) {
      const n = e[s];
      kl(n) && kl(t[s]) ? t[s] = {
        ...t[s],
        ...e[s]
      } : t[s] = e[s];
    }
}
function fA(t, e) {
  e && !("baseUri" in t) && (t.baseUri = e);
}
function rc(t) {
  return t ? (Array.isArray(t) && (t = t[0]), Array.isArray(t?.extensions)) : !1;
}
function ic(t) {
  se(t, "null loader"), se(rc(t), "invalid loader");
  let e;
  return Array.isArray(t) && (e = t[1], t = t[0], t = {
    ...t,
    options: { ...t.options, ...e }
  }), (t?.parseTextSync || t?.parseText) && (t.text = !0), t.text || (t.binary = !0), t;
}
const sd = () => {
  const t = ed();
  return t.loaderRegistry = t.loaderRegistry || [], t.loaderRegistry;
};
function dA(t) {
  const e = sd();
  t = Array.isArray(t) ? t : [t];
  for (const s of t) {
    const n = ic(s);
    e.find((r) => n === r) || e.unshift(n);
  }
}
function pA() {
  return sd();
}
const _A = /\.([^.]+)$/;
async function gA(t, e = [], s, n) {
  if (!nd(t))
    return null;
  let r = Gl(t, e, { ...s, nothrow: !0 }, n);
  if (r)
    return r;
  if (bs(t) && (t = await t.slice(0, 10).arrayBuffer(), r = Gl(t, e, s, n)), !r && !s?.nothrow)
    throw new Error(rd(t));
  return r;
}
function Gl(t, e = [], s, n) {
  if (!nd(t))
    return null;
  if (e && !Array.isArray(e))
    return ic(e);
  let r = [];
  e && (r = r.concat(e)), s?.ignoreRegisteredLoaders || r.push(...pA()), AA(r);
  const i = mA(t, r, s, n);
  if (!i && !s?.nothrow)
    throw new Error(rd(t));
  return i;
}
function mA(t, e, s, n) {
  const r = wi(t), i = nc(t), o = sc(r) || n?.url;
  let a = null, c = "";
  return s?.mimeType && (a = lo(e, s?.mimeType), c = `match forced by supplied MIME type ${s?.mimeType}`), a = a || TA(e, o), c = c || (a ? `matched url ${o}` : ""), a = a || lo(e, i), c = c || (a ? `matched MIME type ${i}` : ""), a = a || bA(e, t), c = c || (a ? `matched initial data ${id(t)}` : ""), s?.fallbackMimeType && (a = a || lo(e, s?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : "")), c && Jg.log(1, `selectLoader selected ${a?.name}: ${c}.`), a;
}
function nd(t) {
  return !(t instanceof Response && t.status === 204);
}
function rd(t) {
  const e = wi(t), s = nc(t);
  let n = "No valid loader found (";
  n += e ? `${Yf(e)}, ` : "no url provided, ", n += `MIME type: ${s ? `"${s}"` : "not provided"}, `;
  const r = t ? id(t) : "";
  return n += r ? ` first bytes: "${r}"` : "first bytes: not available", n += ")", n;
}
function AA(t) {
  for (const e of t)
    ic(e);
}
function TA(t, e) {
  const s = e && _A.exec(e), n = s && s[1];
  return n ? yA(t, n) : null;
}
function yA(t, e) {
  e = e.toLowerCase();
  for (const s of t)
    for (const n of s.extensions)
      if (n.toLowerCase() === e)
        return s;
  return null;
}
function lo(t, e) {
  for (const s of t)
    if (s.mimeTypes?.some((n) => Vl(e, n)) || Vl(e, `application/x.${s.id}`))
      return s;
  return null;
}
function bA(t, e) {
  if (!e)
    return null;
  for (const s of t)
    if (typeof e == "string") {
      if (EA(e, s))
        return s;
    } else if (ArrayBuffer.isView(e)) {
      if ($l(e.buffer, e.byteOffset, s))
        return s;
    } else if (e instanceof ArrayBuffer && $l(e, 0, s))
      return s;
  return null;
}
function EA(t, e) {
  return e.testText ? e.testText(t) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((n) => t.startsWith(n));
}
function $l(t, e, s) {
  return (Array.isArray(s.tests) ? s.tests : [s.tests]).some((r) => CA(t, e, s, r));
}
function CA(t, e, s, n) {
  if (n instanceof ArrayBuffer)
    return bm(n, t, n.byteLength);
  switch (typeof n) {
    case "function":
      return n(t);
    case "string":
      const r = la(t, e, n.length);
      return n === r;
    default:
      return !1;
  }
}
function id(t, e = 5) {
  return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? la(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? la(t, 0, e) : "";
}
function la(t, e, s) {
  if (t.byteLength < e + s)
    return "";
  const n = new DataView(t);
  let r = "";
  for (let i = 0; i < s; i++)
    r += String.fromCharCode(n.getUint8(e + i));
  return r;
}
const SA = 256 * 1024;
function* RA(t, e) {
  const s = e?.chunkSize || SA;
  let n = 0;
  const r = new TextEncoder();
  for (; n < t.length; ) {
    const i = Math.min(t.length - n, s), o = t.slice(n, n + i);
    n += i, yield r.encode(o);
  }
}
const wA = 256 * 1024;
function* IA(t, e = {}) {
  const { chunkSize: s = wA } = e;
  let n = 0;
  for (; n < t.byteLength; ) {
    const r = Math.min(t.byteLength - n, s), i = new ArrayBuffer(r), o = new Uint8Array(t, n, r);
    new Uint8Array(i).set(o), n += r, yield i;
  }
}
const vA = 1024 * 1024;
async function* BA(t, e) {
  const s = e?.chunkSize || vA;
  let n = 0;
  for (; n < t.size; ) {
    const r = n + s, i = await t.slice(n, r).arrayBuffer();
    n = r, yield i;
  }
}
function Kl(t, e) {
  return Ri ? MA(t, e) : PA(t);
}
async function* MA(t, e) {
  const s = t.getReader();
  let n;
  try {
    for (; ; ) {
      const r = n || s.read();
      e?._streamReadAhead && (n = s.read());
      const { done: i, value: o } = await r;
      if (i)
        return;
      yield Kf(o);
    }
  } catch {
    s.releaseLock();
  }
}
async function* PA(t, e) {
  for await (const s of t)
    yield Kf(s);
}
function OA(t, e) {
  if (typeof t == "string")
    return RA(t, e);
  if (t instanceof ArrayBuffer)
    return IA(t, e);
  if (bs(t))
    return BA(t, e);
  if (Jf(t))
    return Kl(t, e);
  if (ys(t))
    return Kl(t.body, e);
  throw new Error("makeIterator");
}
const od = "Cannot convert supplied data type";
function xA(t, e, s) {
  if (e.text && typeof t == "string")
    return t;
  if (zm(t) && (t = t.buffer), t instanceof ArrayBuffer) {
    const n = t;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n;
  }
  if (ArrayBuffer.isView(t)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(t);
    let n = t.buffer;
    const r = t.byteLength || t.length;
    return (t.byteOffset !== 0 || r !== n.byteLength) && (n = n.slice(t.byteOffset, t.byteOffset + r)), n;
  }
  throw new Error(od);
}
async function NA(t, e, s) {
  const n = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
  if (typeof t == "string" || n)
    return xA(t, e);
  if (bs(t) && (t = await Zf(t)), ys(t)) {
    const r = t;
    return await Zm(r), e.binary ? await r.arrayBuffer() : await r.text();
  }
  if (Jf(t) && (t = OA(t, s)), Vm(t) || Hm(t))
    return Rm(t);
  throw new Error(od);
}
function ad(t, e) {
  const s = td(), n = t || s;
  return typeof n.fetch == "function" ? n.fetch : rr(n.fetch) ? (r) => zl(r, n.fetch) : e?.fetch ? e?.fetch : zl;
}
function FA(t, e, s) {
  if (s)
    return s;
  const n = {
    fetch: ad(e, t),
    ...t
  };
  if (n.url) {
    const r = sc(n.url);
    n.baseUrl = r, n.queryString = Ym(n.url), n.filename = Yf(r), n.baseUrl = tc(r);
  }
  return Array.isArray(n.loaders) || (n.loaders = null), n;
}
function DA(t, e) {
  if (t && !Array.isArray(t))
    return t;
  let s;
  if (t && (s = Array.isArray(t) ? t : [t]), e && e.loaders) {
    const n = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    s = s ? [...s, ...n] : n;
  }
  return s && s.length ? s : void 0;
}
async function ai(t, e, s, n) {
  e && !Array.isArray(e) && !rc(e) && (n = void 0, s = e, e = void 0), t = await t, s = s || {};
  const r = wi(t), o = DA(e, n), a = await gA(t, o, s);
  return a ? (s = cA(s, a, o, r), n = FA(
    // @ts-expect-error
    { url: r, _parse: ai, loaders: o },
    s,
    n || null
  ), await UA(a, t, s, n)) : null;
}
async function UA(t, e, s, n) {
  if (hm(t), s = qg(t.options, s), ys(e)) {
    const i = e, { ok: o, redirected: a, status: c, statusText: l, type: h, url: u } = i, f = Object.fromEntries(i.headers.entries());
    n.response = { headers: f, ok: o, redirected: a, status: c, statusText: l, type: h, url: u };
  }
  e = await NA(e, t, s);
  const r = t;
  if (r.parseTextSync && typeof e == "string")
    return r.parseTextSync(e, s, n);
  if (gm(t, s))
    return await mm(t, e, s, n, ai);
  if (r.parseText && typeof e == "string")
    return await r.parseText(e, s, n);
  if (r.parse)
    return await r.parse(e, s, n);
  throw Bt(!r.parseSync), new Error(`${t.id} loader - no parser found and worker is disabled`);
}
function LA(t) {
  switch (t.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function cd(t) {
  let e = 1 / 0, s = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0, o = -1 / 0;
  const a = t.POSITION ? t.POSITION.value : [], c = a && a.length;
  for (let l = 0; l < c; l += 3) {
    const h = a[l], u = a[l + 1], f = a[l + 2];
    e = h < e ? h : e, s = u < s ? u : s, n = f < n ? f : n, r = h > r ? h : r, i = u > i ? u : i, o = f > o ? f : o;
  }
  return [
    [e, s, n],
    [r, i, o]
  ];
}
function kA(t, e, s) {
  const n = LA(e.value), r = s || VA(e);
  return {
    name: t,
    type: { type: "fixed-size-list", listSize: e.size, children: [{ name: "value", type: n }] },
    nullable: !1,
    metadata: r
  };
}
function VA(t) {
  const e = {};
  return "byteOffset" in t && (e.byteOffset = t.byteOffset.toString(10)), "byteStride" in t && (e.byteStride = t.byteStride.toString(10)), "normalized" in t && (e.normalized = t.normalized.toString()), e;
}
async function $t(t, e, s, n) {
  let r, i;
  !Array.isArray(e) && !rc(e) ? (r = [], i = e) : (r = e, i = s);
  const o = ad(i);
  let a = t;
  return typeof t == "string" && (a = await o(t)), bs(t) && (a = await o(t)), Array.isArray(r) ? await ai(a, r, i) : await ai(a, r, i);
}
const HA = "4.3.1", zA = globalThis.loaders?.parseImageNode, ha = typeof Image < "u", ua = typeof ImageBitmap < "u", jA = !!zA, fa = Ri ? !0 : jA;
function WA(t) {
  switch (t) {
    case "auto":
      return ua || ha || fa;
    case "imagebitmap":
      return ua;
    case "image":
      return ha;
    case "data":
      return fa;
    default:
      throw new Error(`@loaders.gl/images: image ${t} not supported in this environment`);
  }
}
function XA() {
  if (ua)
    return "imagebitmap";
  if (ha)
    return "image";
  if (fa)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function GA(t) {
  const e = $A(t);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function ld(t) {
  switch (GA(t)) {
    case "data":
      return t;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), s = e.getContext("2d");
      if (!s)
        throw new Error("getImageData");
      return e.width = t.width, e.height = t.height, s.drawImage(t, 0, 0), s.getImageData(0, 0, t.width, t.height);
    default:
      throw new Error("getImageData");
  }
}
function $A(t) {
  return typeof ImageBitmap < "u" && t instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && t instanceof Image ? "image" : t && typeof t == "object" && t.data && t.width && t.height ? "data" : null;
}
const KA = /^data:image\/svg\+xml/, YA = /\.svg((\?|#).*)?$/;
function oc(t) {
  return t && (KA.test(t) || YA.test(t));
}
function JA(t, e) {
  if (oc(e)) {
    let n = new TextDecoder().decode(t);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (n = unescape(encodeURIComponent(n)));
    } catch (i) {
      throw new Error(i.message);
    }
    return `data:image/svg+xml;base64,${btoa(n)}`;
  }
  return hd(t, e);
}
function hd(t, e) {
  if (oc(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(t)]);
}
async function ud(t, e, s) {
  const n = JA(t, s), r = self.URL || self.webkitURL, i = typeof n != "string" && r.createObjectURL(n);
  try {
    return await qA(i || n, e);
  } finally {
    i && r.revokeObjectURL(i);
  }
}
async function qA(t, e) {
  const s = new Image();
  return s.src = t, e.image && e.image.decode && s.decode ? (await s.decode(), s) : await new Promise((n, r) => {
    try {
      s.onload = () => n(s), s.onerror = (i) => {
        const o = i instanceof Error ? i.message : "error";
        r(new Error(o));
      };
    } catch (i) {
      r(i);
    }
  });
}
const ZA = {};
let Yl = !0;
async function QA(t, e, s) {
  let n;
  oc(s) ? n = await ud(t, e, s) : n = hd(t, s);
  const r = e && e.imagebitmap;
  return await eT(n, r);
}
async function eT(t, e = null) {
  if ((tT(e) || !Yl) && (e = null), e)
    try {
      return await createImageBitmap(t, e);
    } catch (s) {
      console.warn(s), Yl = !1;
    }
  return await createImageBitmap(t);
}
function tT(t) {
  for (const e in t || ZA)
    return !1;
  return !0;
}
function sT(t) {
  return !oT(t, "ftyp", 4) || (t[8] & 96) === 0 ? null : nT(t);
}
function nT(t) {
  switch (rT(t, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function rT(t, e, s) {
  return String.fromCharCode(...t.slice(e, s));
}
function iT(t) {
  return [...t].map((e) => e.charCodeAt(0));
}
function oT(t, e, s = 0) {
  const n = iT(e);
  for (let r = 0; r < n.length; ++r)
    if (n[r] !== t[r + s])
      return !1;
  return !0;
}
const _t = !1, kn = !0;
function ac(t) {
  const e = ir(t);
  return cT(e) || uT(e) || lT(e) || hT(e) || aT(e);
}
function aT(t) {
  const e = new Uint8Array(t instanceof DataView ? t.buffer : t), s = sT(e);
  return s ? {
    mimeType: s.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function cT(t) {
  const e = ir(t);
  return e.byteLength >= 24 && e.getUint32(0, _t) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, _t),
    height: e.getUint32(20, _t)
  } : null;
}
function lT(t) {
  const e = ir(t);
  return e.byteLength >= 10 && e.getUint32(0, _t) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, kn),
    height: e.getUint16(8, kn)
  } : null;
}
function hT(t) {
  const e = ir(t);
  return e.byteLength >= 14 && e.getUint16(0, _t) === 16973 && e.getUint32(2, kn) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, kn),
    height: e.getUint32(22, kn)
  } : null;
}
function uT(t) {
  const e = ir(t);
  if (!(e.byteLength >= 3 && e.getUint16(0, _t) === 65496 && e.getUint8(2) === 255))
    return null;
  const { tableMarkers: n, sofMarkers: r } = fT();
  let i = 2;
  for (; i + 9 < e.byteLength; ) {
    const o = e.getUint16(i, _t);
    if (r.has(o))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(i + 5, _t),
        // Number of lines
        width: e.getUint16(i + 7, _t)
        // Number of pixels per line
      };
    if (!n.has(o))
      return null;
    i += 2, i += e.getUint16(i, _t);
  }
  return null;
}
function fT() {
  const t = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let s = 65504; s < 65520; ++s)
    t.add(s);
  return { tableMarkers: t, sofMarkers: /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]) };
}
function ir(t) {
  if (t instanceof DataView)
    return t;
  if (ArrayBuffer.isView(t))
    return new DataView(t.buffer);
  if (t instanceof ArrayBuffer)
    return new DataView(t);
  throw new Error("toDataView");
}
async function dT(t, e) {
  const { mimeType: s } = ac(t) || {}, n = globalThis.loaders?.parseImageNode;
  return se(n), await n(t, s);
}
async function pT(t, e, s) {
  e = e || {};
  const r = (e.image || {}).type || "auto", { url: i } = s || {}, o = _T(r);
  let a;
  switch (o) {
    case "imagebitmap":
      a = await QA(t, e, i);
      break;
    case "image":
      a = await ud(t, e, i);
      break;
    case "data":
      a = await dT(t);
      break;
    default:
      se(!1);
  }
  return r === "data" && (a = ld(a)), a;
}
function _T(t) {
  switch (t) {
    case "auto":
    case "data":
      return XA();
    default:
      return WA(t), t;
  }
}
const gT = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], mT = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
], AT = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, fd = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: HA,
  mimeTypes: mT,
  extensions: gT,
  parse: pT,
  // TODO: byteOffset, byteLength;
  tests: [(t) => !!ac(new DataView(t))],
  options: AT
}, ho = {};
function TT(t) {
  if (ho[t] === void 0) {
    const e = Ri ? bT(t) : yT(t);
    ho[t] = e;
  }
  return ho[t];
}
function yT(t) {
  const e = ["image/png", "image/jpeg", "image/gif"], s = globalThis.loaders?.imageFormatsNode || e;
  return !!globalThis.loaders?.parseImageNode && s.includes(t);
}
function bT(t) {
  switch (t) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return ET(t);
    default:
      return !0;
  }
}
function ET(t) {
  try {
    return document.createElement("canvas").toDataURL(t).indexOf(`data:${t}`) === 0;
  } catch {
    return !1;
  }
}
const $ = new ln({ id: "deck" });
let da = {};
function CT(t) {
  da = t;
}
function Te(t, e, s, n) {
  $.level > 0 && da[t] && da[t].call(null, e, s, n);
}
function ST(t) {
  const e = t[0], s = t[t.length - 1];
  return e === "{" && s === "}" || e === "[" && s === "]";
}
const RT = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: ST,
  parseTextSync: JSON.parse
};
function wT() {
  const t = "9.0.35", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== t)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${t}`);
  return e || ($.log(1, `deck.gl ${t}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: t,
    version: t,
    log: $,
    // experimental
    _registerLoggers: CT
  }, dA([
    RT,
    // @ts-expect-error non-standard Loader format
    [fd, { imagebitmap: { premultiplyAlpha: "none" } }]
  ])), t;
}
const IT = wT();
function ls(t, e) {
  if (!t)
    throw new Error(e || "shadertools: assertion failed.");
}
const uo = {
  number: {
    type: "number",
    validate(t, e) {
      return Number.isFinite(t) && typeof e == "object" && (e.max === void 0 || t <= e.max) && (e.min === void 0 || t >= e.min);
    }
  },
  array: {
    type: "array",
    validate(t, e) {
      return Array.isArray(t) || ArrayBuffer.isView(t);
    }
  }
};
function vT(t) {
  const e = {};
  for (const [s, n] of Object.entries(t))
    e[s] = MT(n);
  return e;
}
function BT(t, e, s) {
  const n = {};
  for (const [r, i] of Object.entries(e))
    t && r in t && !i.private ? (i.validate && ls(i.validate(t[r], i), `${s}: invalid ${r}`), n[r] = t[r]) : n[r] = i.value;
  return n;
}
function MT(t) {
  let e = Jl(t);
  if (e !== "object")
    return { value: t, ...uo[e], type: e };
  if (typeof t == "object")
    return t ? t.type !== void 0 ? { ...t, ...uo[t.type], type: t.type } : t.value === void 0 ? { type: "object", value: t } : (e = Jl(t.value), { ...t, ...uo[e], type: e }) : { type: "object", value: null };
  throw new Error("props");
}
function Jl(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) ? "array" : typeof t;
}
const PT = `#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`, OT = `#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`, xT = {
  vertex: PT,
  fragment: OT
}, ql = /void\s+main\s*\([^)]*\)\s*\{\n?/, Zl = /}\n?[^{}]*$/, fo = [], Zr = "__LUMA_INJECT_DECLARATIONS__";
function NT(t) {
  const e = { vertex: {}, fragment: {} };
  for (const s in t) {
    let n = t[s];
    const r = FT(s);
    typeof n == "string" && (n = {
      order: 0,
      injection: n
    }), e[r][s] = n;
  }
  return e;
}
function FT(t) {
  const e = t.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function ci(t, e, s, n = !1) {
  const r = e === "vertex";
  for (const i in s) {
    const o = s[i];
    o.sort((c, l) => c.order - l.order), fo.length = o.length;
    for (let c = 0, l = o.length; c < l; ++c)
      fo[c] = o[c].injection;
    const a = `${fo.join(`
`)}
`;
    switch (i) {
      // declarations are injected before the main function
      case "vs:#decl":
        r && (t = t.replace(Zr, a));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        r && (t = t.replace(ql, (c) => c + a));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        r && (t = t.replace(Zl, (c) => a + c));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        r || (t = t.replace(Zr, a));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        r || (t = t.replace(ql, (c) => c + a));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        r || (t = t.replace(Zl, (c) => a + c));
        break;
      default:
        t = t.replace(i, (c) => c + a);
    }
  }
  return t = t.replace(Zr, ""), n && (t = t.replace(/\}\s*$/, (i) => i + xT[e])), t;
}
let DT = 1;
class hs {
  name;
  vs;
  fs;
  getModuleUniforms;
  dependencies;
  deprecations;
  defines;
  injections;
  uniforms = {};
  uniformTypes = {};
  static instantiateModules(e) {
    return e.map((s) => {
      if (s instanceof hs)
        return s;
      ls(typeof s != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(s)}' and use it directly.`), s.name || (console.warn("shader module has no name"), s.name = `shader-module-${DT++}`);
      const n = new hs(s);
      return n.dependencies = hs.instantiateModules(s.dependencies || []), n;
    });
  }
  constructor(e) {
    const { name: s, vs: n, fs: r, dependencies: i = [], uniformTypes: o = {}, uniformPropTypes: a = {}, getUniforms: c, deprecations: l = [], defines: h = {}, inject: u = {} } = e;
    ls(typeof s == "string"), this.name = s, this.vs = n, this.fs = r, this.getModuleUniforms = c, this.dependencies = hs.instantiateModules(i), this.deprecations = this._parseDeprecationDefinitions(l), this.defines = h, this.injections = NT(u), this.uniformTypes = o, a && (this.uniforms = vT(a));
  }
  // Extracts the source code chunk for the specified shader type from the named shader module
  getModuleSource(e) {
    let s;
    switch (e) {
      case "vertex":
        s = this.vs || "";
        break;
      case "fragment":
        s = this.fs || "";
        break;
      default:
        ls(!1);
    }
    const n = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    return `// ----- MODULE ${this.name} ---------------

#define MODULE_${n}
${s}

`;
  }
  getUniforms(e, s) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, s) : BT(e, this.uniforms, this.name);
  }
  getDefines() {
    return this.defines;
  }
  // Warn about deprecated uniforms or functions
  checkDeprecations(e, s) {
    this.deprecations.forEach((n) => {
      n.regex?.test(e) && (n.deprecated ? s.deprecated(n.old, n.new)() : s.removed(n.old, n.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((s) => {
      switch (s.type) {
        case "function":
          s.regex = new RegExp(`\\b${s.old}\\(`);
          break;
        default:
          s.regex = new RegExp(`${s.type} ${s.old};`);
      }
    }), e;
  }
  _defaultGetUniforms(e = {}) {
    const s = {}, n = this.uniforms;
    for (const r in n) {
      const i = n[r];
      r in e && !i.private ? (i.validate && ls(i.validate(e[r], i), `${this.name}: invalid ${r}`), s[r] = e[r]) : s[r] = i.value;
    }
    return s;
  }
}
function Ql(t) {
  if (t.source && t.platformInfo.type === "webgpu")
    return { ...t, vs: void 0, fs: void 0 };
  if (!t.vs)
    throw new Error("no vertex shader");
  const e = eh(t.platformInfo, t.vs);
  let s;
  return t.fs && (s = eh(t.platformInfo, t.fs)), { ...t, vs: e, fs: s };
}
function eh(t, e) {
  if (typeof e == "string")
    return e;
  switch (t.type) {
    case "webgpu":
      if (e?.wgsl)
        return e.wgsl;
      throw new Error("WebGPU does not support GLSL shaders");
    default:
      if (e?.glsl)
        return e.glsl;
      throw new Error("WebGL does not support WGSL shaders");
  }
}
function Ii(t) {
  const e = hs.instantiateModules(t);
  return UT(e);
}
function UT(t) {
  const e = {}, s = {};
  return dd({ modules: t, level: 0, moduleMap: e, moduleDepth: s }), Object.keys(s).sort((n, r) => s[r] - s[n]).map((n) => e[n]);
}
function dd(t) {
  const { modules: e, level: s, moduleMap: n, moduleDepth: r } = t;
  if (s >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const i of e)
    n[i.name] = i, (r[i.name] === void 0 || r[i.name] < s) && (r[i.name] = s);
  for (const i of e)
    i.dependencies && dd({ modules: i.dependencies, level: s + 1, moduleMap: n, moduleDepth: r });
}
function LT(t) {
  switch (t?.gpu.toLowerCase()) {
    case "apple":
      return `#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "nvidia":
      return `#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function kT(t, e) {
  if (Number(t.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return t = th(t, VT), t;
    case "fragment":
      return t = th(t, HT), t;
    default:
      throw new Error(e);
  }
}
const pd = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], VT = [
  ...pd,
  // `attribute` keyword replaced with `in`
  [pa("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [pa("varying"), "out $1"]
], HT = [
  ...pd,
  // `varying` keyword replaced with `in`
  [pa("varying"), "in $1"]
];
function th(t, e) {
  for (const [s, n] of e)
    t = t.replace(s, n);
  return t;
}
function pa(t) {
  return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function _d(t, e) {
  let s = "";
  for (const n in t) {
    const r = t[n];
    if (s += `void ${r.signature} {
`, r.header && (s += `  ${r.header}`), e[n]) {
      const i = e[n];
      i.sort((o, a) => o.order - a.order);
      for (const o of i)
        s += `  ${o.injection}
`;
    }
    r.footer && (s += `  ${r.footer}`), s += `}
`;
  }
  return s;
}
function gd(t) {
  const e = { vertex: {}, fragment: {} };
  for (const s of t) {
    let n, r;
    typeof s != "string" ? (n = s, r = n.hook) : (n = {}, r = s), r = r.trim();
    const [i, o] = r.split(":"), a = r.replace(/\(.+/, ""), c = Object.assign(n, { signature: o });
    switch (i) {
      case "vs":
        e.vertex[a] = c;
        break;
      case "fs":
        e.fragment[a] = c;
        break;
      default:
        throw new Error(i);
    }
  }
  return e;
}
function zT(t, e) {
  return {
    name: jT(t, e),
    language: "glsl",
    version: WT(t)
  };
}
function jT(t, e = "unnamed") {
  const n = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(t);
  return n ? n[1] : e;
}
function WT(t) {
  let e = 100;
  const s = t.match(/[^\s]+/g);
  if (s && s.length >= 2 && s[0] === "#version") {
    const n = parseInt(s[1], 10);
    Number.isFinite(n) && (e = n);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const md = `

${Zr}
`, XT = `precision highp float;
`;
function GT(t) {
  const e = Ii(t.modules || []);
  return {
    source: _a(t.platformInfo, {
      ...t,
      source: t.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: cc(e)
  };
}
function $T(t) {
  const e = Ii(t.modules || []);
  return {
    vs: _a(t.platformInfo, {
      ...t,
      source: t.vs,
      stage: "vertex",
      modules: e
    }),
    fs: _a(t.platformInfo, {
      ...t,
      source: t.fs,
      stage: "fragment",
      modules: e
    }),
    getUniforms: cc(e)
  };
}
function KT(t) {
  const { vs: e, fs: s } = t, n = Ii(t.modules || []);
  return {
    vs: sh(t.platformInfo, {
      ...t,
      source: e,
      stage: "vertex",
      modules: n
    }),
    fs: sh(t.platformInfo, {
      ...t,
      source: s,
      stage: "fragment",
      modules: n
    }),
    getUniforms: cc(n)
  };
}
function _a(t, e) {
  const {
    // id,
    source: s,
    stage: n,
    modules: r,
    // defines = {},
    hookFunctions: i = [],
    inject: o = {},
    log: a
  } = e;
  ls(typeof s == "string", "shader source must be a string");
  const c = s;
  let l = "";
  const h = gd(i), u = {}, f = {}, p = {};
  for (const A in o) {
    const E = typeof o[A] == "string" ? { injection: o[A], order: 0 } : o[A], C = /^(v|f)s:(#)?([\w-]+)$/.exec(A);
    if (C) {
      const w = C[2], I = C[3];
      w ? I === "decl" ? f[A] = [E] : p[A] = [E] : u[A] = [E];
    } else
      p[A] = [E];
  }
  const m = t.type !== "webgpu" ? r : [];
  for (const A of m) {
    a && A.checkDeprecations(c, a);
    const E = A.getModuleSource(n, "wgsl");
    l += E;
    const C = A.injections[n];
    for (const w in C) {
      const I = /^(v|f)s:#([\w-]+)$/.exec(w);
      if (I) {
        const x = I[2] === "decl" ? f : p;
        x[w] = x[w] || [], x[w].push(C[w]);
      } else
        u[w] = u[w] || [], u[w].push(C[w]);
    }
  }
  return l += md, l = ci(l, n, f), l += _d(h[n], u), l += c, l = ci(l, n, p), l;
}
function sh(t, e) {
  const { id: s, source: n, stage: r, language: i = "glsl", modules: o, defines: a = {}, hookFunctions: c = [], inject: l = {}, prologue: h = !0, log: u } = e;
  ls(typeof n == "string", "shader source must be a string");
  const f = i === "glsl" ? zT(n).version : -1, p = t.shaderLanguageVersion, m = f === 100 ? "#version 100" : "#version 300 es", E = n.split(`
`).slice(1).join(`
`), C = {};
  o.forEach((L) => {
    Object.assign(C, L.getDefines());
  }), Object.assign(C, a);
  let w = "";
  switch (i) {
    case "wgsl":
      break;
    case "glsl":
      w = h ? `${m}

// ----- PROLOGUE -------------------------
${YT({ id: s, source: n, stage: r })}
${`#define SHADER_TYPE_${r.toUpperCase()}`}
${LT(t)}
${r === "fragment" ? XT : ""}

// ----- APPLICATION DEFINES -------------------------

${JT(C)}

` : `${m}
`;
      break;
  }
  const I = gd(c), B = {}, x = {}, N = {};
  for (const L in l) {
    const k = typeof l[L] == "string" ? { injection: l[L], order: 0 } : l[L], F = /^(v|f)s:(#)?([\w-]+)$/.exec(L);
    if (F) {
      const U = F[2], H = F[3];
      U ? H === "decl" ? x[L] = [k] : N[L] = [k] : B[L] = [k];
    } else
      N[L] = [k];
  }
  for (const L of o) {
    u && L.checkDeprecations(E, u);
    const k = L.getModuleSource(r);
    w += k;
    const F = L.injections[r];
    for (const U in F) {
      const H = /^(v|f)s:#([\w-]+)$/.exec(U);
      if (H) {
        const te = H[2] === "decl" ? x : N;
        te[U] = te[U] || [], te[U].push(F[U]);
      } else
        B[U] = B[U] || [], B[U].push(F[U]);
    }
  }
  return w += "// ----- MAIN SHADER SOURCE -------------------------", w += md, w = ci(w, r, x), w += _d(I[r], B), w += E, w = ci(w, r, N), i === "glsl" && f !== p && (w = kT(w, r)), w.trim();
}
function cc(t) {
  return function(s) {
    const n = {};
    for (const r of t) {
      const i = r.getUniforms(s, n);
      Object.assign(n, i);
    }
    return n;
  };
}
function YT(t) {
  const { id: e, source: s, stage: n } = t;
  return e && s.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${n}

` : "";
}
function JT(t = {}) {
  let e = "";
  for (const s in t) {
    const n = t[s];
    (n || Number.isFinite(n)) && (e += `#define ${s.toUpperCase()} ${t[s]}
`);
  }
  return e;
}
class us {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return us.defaultShaderAssembler = us.defaultShaderAssembler || new us(), us.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((s) => s.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const s = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((n) => n.name !== s);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, s) {
    s && (e = Object.assign(s, { hook: e })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShader(e) {
    const s = this._getModuleList(e.modules), n = this._hookFunctions, r = Ql(e);
    return { ...GT({
      platformInfo: e.platformInfo,
      ...r,
      modules: s,
      hookFunctions: n
    }), modules: s };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleShaderPair(e) {
    const s = Ql(e), n = this._getModuleList(e.modules), r = this._hookFunctions, { platformInfo: i } = e;
    return { ...e.platformInfo.shaderLanguage === "wgsl" ? $T({ platformInfo: i, ...s, modules: n, hookFunctions: r }) : KT({ platformInfo: i, ...s, modules: n, hookFunctions: r }), modules: n };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(e = []) {
    const s = new Array(this._defaultModules.length + e.length), n = {};
    let r = 0;
    for (let i = 0, o = this._defaultModules.length; i < o; ++i) {
      const a = this._defaultModules[i], c = a.name;
      s[r++] = a, n[c] = !0;
    }
    for (let i = 0, o = e.length; i < o; ++i) {
      const a = e[i], c = a.name;
      n[c] || (s[r++] = a, n[c] = !0);
    }
    return s.length = r, hs.instantiateModules(s);
  }
}
const qT = `out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`, ZT = `#version 300 es
${qT}`;
function QT(t) {
  const { input: e, inputChannels: s, output: n } = {};
  if (!e)
    return ZT;
  if (!s)
    throw new Error("inputChannels");
  const r = ey(s), i = ty(e, s);
  return `#version 300 es
in ${r} ${e};
out vec4 ${n};
void main() {
  ${n} = ${i};
}`;
}
function ey(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${t}`);
  }
}
function ty(t, e) {
  switch (e) {
    case 1:
      return `vec4(${t}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${t}, 0.0, 1.0)`;
    case 3:
      return `vec4(${t}, 1.0)`;
    case 4:
      return t;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
const P = new ln({ id: "luma.gl" });
class sy {
  stats = /* @__PURE__ */ new Map();
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new hn({ id: e })), this.stats.get(e);
  }
}
const lc = new sy();
function ny() {
  const t = "9.0.27", e = "set luma.log.level=1 (or higher) to trace rendering";
  if (globalThis.luma && globalThis.luma.VERSION !== t)
    throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${t}`);
  return globalThis.luma || (Zt() && P.log(1, `${t} - ${e}`)(), globalThis.luma = globalThis.luma || {
    VERSION: t,
    version: t,
    log: P,
    // A global stats object that various components can add information to
    // E.g. see webgl/resource.js
    stats: lc
  }), t;
}
const ry = ny();
function iy(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView) ? t : null;
}
function Xn(t) {
  return Array.isArray(t) ? t.length === 0 || typeof t[0] == "number" ? t : null : iy(t);
}
const po = {};
function Qt(t = "id") {
  po[t] = po[t] || 1;
  const e = po[t]++;
  return `${t}-${e}`;
}
function li(t) {
  let e = !0;
  for (const s in t) {
    e = !1;
    break;
  }
  return e;
}
let ee = class {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = !1;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, s, n) {
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = oy(s, n);
    const r = this.props.id !== "undefined" ? this.props.id : Qt(this[Symbol.toStringTag]);
    this.props.id = r, this.id = r, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), s = this[Symbol.toStringTag];
    e.get(`${s}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e, s = this[Symbol.toStringTag]) {
    const n = this._device.statsManager.getStats("Resource Counts");
    n.get("GPU Memory").addCount(e), n.get(`${s} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
    const s = this._device.statsManager.getStats("Resource Counts");
    s.get("GPU Memory").subtractCount(this.allocatedBytes), s.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), s = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${s}s Created`).incrementCount(), e.get(`${s}s Active`).incrementCount();
  }
};
function oy(t, e) {
  const s = { ...e };
  for (const n in t)
    t[n] !== void 0 && (s[n] = t[n]);
  return s;
}
class re extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: !1
  };
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update */
  updateTimestamp;
  constructor(e, s) {
    const n = { ...s };
    (s.usage || 0) & re.INDEX && !s.indexType && (s.data instanceof Uint32Array ? n.indexType = "uint32" : s.data instanceof Uint16Array && (n.indexType = "uint16")), super(e, n, re.defaultProps), this.usage = s.usage || 0, this.indexType = n.indexType, this.updateTimestamp = e.incrementTimestamp();
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(e, s) {
    throw new Error("not implemented");
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(e, s, n) {
    const r = ArrayBuffer.isView(e) ? e.buffer : e, i = Math.min(e ? e.byteLength : n, re.DEBUG_DATA_MAX_LENGTH);
    e === null ? this.debugData = new ArrayBuffer(i) : s === 0 && n === e.byteLength ? this.debugData = r.slice(0, i) : this.debugData = r.slice(s, s + i);
  }
}
function Ad(t) {
  const e = nh[t], s = ay(e), n = t.includes("norm"), r = !n && !t.startsWith("float"), i = t.startsWith("s");
  return {
    dataType: nh[t],
    byteLength: s,
    integer: r,
    signed: i,
    normalized: n
  };
}
function ay(t) {
  return cy[t];
}
const nh = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, cy = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, ly = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
], hy = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
function uy(t) {
  return ly.some((e) => t.startsWith(e));
}
function Td(t) {
  const e = hy.exec(t);
  if (e) {
    const [, s, n, r, i, o] = e;
    if (s) {
      const a = `${r}${n}`, c = Ad(a);
      return {
        format: s,
        components: s.length,
        // dataType - overwritten by decodedType
        srgb: i === "-srgb",
        unsized: o === "-unsized",
        webgl: o === "-webgl",
        ...c
      };
    }
  }
  return dy(t);
}
const fy = {
  // Packed 16 bit formats
  "rgba4unorm-webgl": { format: "rgba", bpp: 2 },
  "rgb565unorm-webgl": { format: "rgb", bpp: 2 },
  "rgb5a1unorm-webgl": { format: "rgba", bbp: 2 },
  // Packed 32 bit formats
  rgb9e5ufloat: { format: "rgb", bbp: 4 },
  rg11b10ufloat: { format: "rgb", bbp: 4 },
  rgb10a2unorm: { format: "rgba", bbp: 4 },
  "rgb10a2uint-webgl": { format: "rgba", bbp: 4 },
  // Depth/stencil
  stencil8: { components: 1, bpp: 1, a: "stencil" },
  depth16unorm: { components: 1, bpp: 2, a: "depth" },
  depth24plus: { components: 1, bpp: 3, a: "depth" },
  depth32float: { components: 1, bpp: 4, a: "depth" },
  "depth24plus-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { components: 2, bpp: 4, a: "depth-stencil" }
};
function dy(t) {
  const e = fy[t];
  if (!e)
    throw new Error(`Unknown format ${t}`);
  return {
    format: e.format || "",
    components: e.components || e.format?.length || 1,
    byteLength: e.bpp || 1,
    srgb: !1,
    unsized: !1
  };
}
class py {
}
class _y {
  features;
  disabledFeatures;
  constructor(e = [], s) {
    this.features = new Set(e), this.disabledFeatures = s || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    return !this.disabledFeatures[e] && this.features.has(e);
  }
}
class Zs {
  static defaultProps = {
    id: null,
    canvas: null,
    container: null,
    manageState: !0,
    width: 800,
    // width are height are only used by headless gl
    height: 600,
    requestMaxLimits: !0,
    debug: !!P.get("debug"),
    // Instrument context (at the expense of performance)
    spector: !!(P.get("spector") || P.get("spectorjs")),
    // Initialize the SpectorJS WebGL debugger
    break: [],
    // TODO - Change these after confirming things work as expected
    initalizeFeatures: !0,
    disabledFeatures: {
      "compilation-status-async-webgl": !0
    },
    // alpha: undefined,
    // depth: undefined,
    // stencil: undefined,
    // antialias: undefined,
    // premultipliedAlpha: undefined,
    // preserveDrawingBuffer: undefined,
    // failIfMajorPerformanceCaveat: undefined
    gl: null,
    // Callbacks
    onError: (e) => P.error(e.message)
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  static VERSION = ry;
  constructor(e) {
    this.props = { ...Zs.defaultProps, ...e }, this.id = this.props.id || Qt(this[Symbol.toStringTag].toLowerCase());
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = lc;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return uy(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no CanvasContext");
    return this.canvasContext;
  }
  createTexture(e) {
    return (e instanceof Promise || typeof e == "string") && (e = { data: e }), this._createTexture(e);
  }
  createCommandEncoder(e = {}) {
    throw new Error("not implemented");
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, s) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, s) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, s) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  timestamp = 0;
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(e) {
    this.props.onError(e);
  }
  // IMPLEMENTATION
  _getBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = { data: e });
    const s = { ...e };
    return (e.usage || 0) & re.INDEX && !e.indexType && (e.data instanceof Uint32Array ? s.indexType = "uint32" : e.data instanceof Uint16Array ? s.indexType = "uint16" : P.warn("indices buffer content must be of integer type")()), s;
  }
}
function q(t, e) {
  if (!t)
    throw new Error(e || "luma.gl: assertion failed.");
}
const bn = /* @__PURE__ */ new Map();
class Xs {
  static defaultProps = {
    ...Zs.defaultProps,
    type: "best-available",
    devices: void 0
  };
  /** Global stats for all devices */
  static stats = lc;
  /** Global log */
  static log = P;
  static registerDevices(e) {
    for (const s of e)
      q(s.type && s.isSupported && s.create), bn.set(s.type, s);
  }
  static getAvailableDevices() {
    return Array.from(bn).map((e) => e.type);
  }
  static getSupportedDevices() {
    return Array.from(bn).filter((e) => e.isSupported()).map((e) => e.type);
  }
  static setDefaultDeviceProps(e) {
    Object.assign(Zs.defaultProps, e);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  static async attachDevice(e) {
    const s = rh(e.devices) || bn;
    if (e.handle instanceof WebGL2RenderingContext) {
      const n = s.get("webgl");
      if (n)
        return await n.attach(e.handle);
    }
    if (e.handle === null) {
      const n = s.get("unknown");
      if (n)
        return await n.attach(null);
    }
    throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  /** Creates a device. Asynchronously. */
  static async createDevice(e = {}) {
    e = { ...Xs.defaultProps, ...e }, e.gl && (e.type = "webgl");
    const s = rh(e.devices) || bn;
    let n, r;
    switch (e.type) {
      case "webgpu":
        if (n = s.get("webgpu"), n)
          return await n.create(e);
        break;
      case "webgl":
        if (r = s.get("webgl"), r)
          return await r.create(e);
        break;
      case "unknown":
        const i = s.get("unknown");
        if (i)
          return await i.create(e);
        break;
      case "best-available":
        if (n = s.get("webgpu"), n?.isSupported?.())
          return await n.create(e);
        if (r = s.get("webgl"), r?.isSupported?.())
          return await r.create(e);
        break;
    }
    throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
  }
  static enforceWebGL2(e = !0) {
    const s = HTMLCanvasElement.prototype;
    if (!e && s.originalGetContext) {
      s.getContext = s.originalGetContext, s.originalGetContext = void 0;
      return;
    }
    s.originalGetContext = s.getContext, s.getContext = function(n, r) {
      return n === "webgl" || n === "experimental-webgl" ? this.originalGetContext("webgl2", r) : this.originalGetContext(n, r);
    };
  }
}
function rh(t) {
  if (!t || t?.length === 0)
    return null;
  const e = /* @__PURE__ */ new Map();
  for (const s of t)
    e.set(s.type, s);
  return e;
}
const gy = Zt() && typeof document < "u", vi = () => gy && document.readyState === "complete", my = {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: !0,
  autoResize: !0,
  container: null,
  visible: !0,
  colorSpace: "srgb",
  alphaMode: "opaque"
};
class yd {
  id;
  props;
  canvas;
  htmlCanvas;
  offscreenCanvas;
  type;
  width = 1;
  height = 1;
  resizeObserver;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** Check if the DOM is loaded */
  static get isPageLoaded() {
    return vi();
  }
  /**
   * Get a 'lazy' promise that resolves when the DOM is loaded.
   * @note Since there may be limitations on number of `load` event listeners,
   * it is recommended avoid calling this function until actually needed.
   * I.e. don't call it until you know that you will be looking up a string in the DOM.
   */
  static pageLoaded = Ay();
  constructor(e) {
    if (this.props = { ...my, ...e }, e = this.props, !Zt()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (e.canvas)
      typeof e.canvas == "string" ? this.canvas = yy(e.canvas) : this.canvas = e.canvas;
    else {
      const s = by(e), n = Ty(e?.container || null);
      n.insertBefore(s, n.firstChild), this.canvas = s, e?.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((s) => {
      for (const n of s)
        n.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(e) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const e = this.getDevicePixelRatio(), s = this.canvas;
        return s.parentElement ? [s.clientWidth * e, s.clientHeight * e] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [e, s] = this.getPixelSize();
    return e / s;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [e] = this.getDrawingBufferSize(), { clientWidth: s } = this._canvasSizeInfo;
      return s ? e / s : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e, s = !0) {
    const n = this.cssToDeviceRatio(), [r, i] = this.getDrawingBufferSize();
    return Ey(e, n, r, i, s);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(e, s = {}) {
    if (!this.htmlCanvas)
      return;
    let n = "width" in s ? s.width : this.htmlCanvas.clientWidth, r = "height" in s ? s.height : this.htmlCanvas.clientHeight;
    (!n || !r) && (P.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, n = this.htmlCanvas.width || 1, r = this.htmlCanvas.height || 1);
    const i = this._canvasSizeInfo;
    if (i.clientWidth !== n || i.clientHeight !== r || i.devicePixelRatio !== e) {
      let o = e;
      const a = Math.floor(n * o), c = Math.floor(r * o);
      this.htmlCanvas.width = a, this.htmlCanvas.height = c;
      const [l, h] = this.getDrawingBufferSize();
      (l !== a || h !== c) && (o = Math.min(l / n, h / r), this.htmlCanvas.width = Math.floor(n * o), this.htmlCanvas.height = Math.floor(r * o), P.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = n, this._canvasSizeInfo.clientHeight = r, this._canvasSizeInfo.devicePixelRatio = e;
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const e = this.device.gl;
    if (!e)
      throw new Error("canvas size");
    return [e.drawingBufferWidth, e.drawingBufferHeight];
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
}
function Ay() {
  return vi() || typeof window > "u" ? Promise.resolve() : new Promise((t) => {
    window.addEventListener("load", () => t());
  });
}
function Ty(t) {
  if (typeof t == "string") {
    const e = document.getElementById(t);
    if (!e && !vi())
      throw new Error(`Accessing '${t}' before page was loaded`);
    if (!e)
      throw new Error(`${t} is not an HTML element`);
    return e;
  } else if (t)
    return t;
  return document.body;
}
function yy(t) {
  const e = document.getElementById(t);
  if (!e && !vi())
    throw new Error(`Accessing '${t}' before page was loaded`);
  if (!(e instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return e;
}
function by(t) {
  const { width: e, height: s } = t, n = document.createElement("canvas");
  return n.id = "lumagl-auto-created-canvas", n.width = e || 1, n.height = s || 1, n.style.width = Number.isFinite(e) ? `${e}px` : "100%", n.style.height = Number.isFinite(s) ? `${s}px` : "100%", n;
}
function Ey(t, e, s, n, r) {
  const i = t, o = ih(i[0], e, s);
  let a = oh(i[1], e, n, r), c = ih(i[0] + 1, e, s);
  const l = c === s - 1 ? c : c - 1;
  c = oh(i[1] + 1, e, n, r);
  let h;
  return r ? (c = c === 0 ? c : c + 1, h = a, a = c) : h = c === n - 1 ? c : c - 1, {
    x: o,
    y: a,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(l - o + 1, 1),
    height: Math.max(h - a + 1, 1)
  };
}
function ih(t, e, s) {
  return Math.min(Math.round(t * e), s - 1);
}
function oh(t, e, s, n) {
  return n ? Math.max(0, s - 1 - Math.round(t * e)) : Math.min(Math.round(t * e), s - 1);
}
class Ne extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: !0,
    // type: undefined,
    compressed: !1,
    // mipLevels: 1,
    usage: 0,
    // usage: GPUTextureUsage.COPY_DST
    mipLevels: void 0,
    samples: void 0,
    type: void 0,
    sampler: {},
    view: void 0
  };
  static COPY_SRC = 1;
  static COPY_DST = 2;
  static TEXTURE_BINDING = 4;
  static STORAGE_BINDING = 8;
  static RENDER_ATTACHMENT = 16;
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  /** dimension of this texture */
  dimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** "Time" of last update. Monotonically increasing timestamp */
  updateTimestamp;
  /** Do not use directly. Create with device.createTexture() */
  constructor(e, s, n = Ne.defaultProps) {
    super(e, s, n), this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.updateTimestamp = e.incrementTimestamp();
  }
}
class Bi extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, s) {
    super(e, s, Bi.defaultProps);
  }
}
function Cy(t, e, s) {
  let n = "";
  const r = e.split(/\r?\n/), i = t.slice().sort((o, a) => o.lineNum - a.lineNum);
  switch (s?.showSourceCode || "no") {
    case "all":
      let o = 0;
      for (let a = 1; a <= r.length; a++)
        for (n += bd(r[a - 1], a, s); i.length > o && i[o].lineNum === a; ) {
          const c = i[o++];
          n += ah(c, r, c.lineNum, {
            ...s,
            inlineSource: !1
          });
        }
      return n;
    case "issues":
    case "no":
      for (const a of t)
        n += ah(a, r, a.lineNum, {
          inlineSource: s?.showSourceCode !== "no"
        });
      return n;
  }
}
function ah(t, e, s, n) {
  if (n?.inlineSource) {
    const r = Sy(e, s), i = t.linePos > 0 ? `${" ".repeat(t.linePos + 5)}^^^
` : "";
    return `
${r}${i}${t.type.toUpperCase()}: ${t.message}

`;
  }
  return n?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${t.type.toUpperCase()}: ${t.message}</b></div>` : `${t.type.toUpperCase()}: ${t.message}`;
}
function Sy(t, e, s) {
  let n = "";
  for (let r = e - 2; r <= e; r++) {
    const i = t[r - 1];
    i !== void 0 && (n += bd(i, e, s));
  }
  return n;
}
function bd(t, e, s) {
  const n = s?.html ? wy(t) : t;
  return `${Ry(String(e), 4)}: ${n}${s?.html ? "<br/>" : `
`}`;
}
function Ry(t, e) {
  let s = "";
  for (let n = t.length; n < e; ++n)
    s += " ";
  return s + t;
}
function wy(t) {
  return t.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
function Ed(t, e) {
  return {
    name: Iy(t, e),
    language: "glsl",
    version: vy(t)
  };
}
function Iy(t, e = "unnamed") {
  const n = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(t);
  return n ? n[1] : e;
}
function vy(t) {
  let e = 100;
  const s = t.match(/[^\s]+/g);
  if (s && s.length >= 2 && s[0] === "#version") {
    const n = parseInt(s[1], 10);
    Number.isFinite(n) && (e = n);
  }
  return e;
}
class Mi extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  };
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(e, s) {
    super(e, { id: By(s), ...s }, Mi.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader(e = this.props.debug) {
    switch (e) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const s = await this.getCompilationInfo();
    this.props.debug === "warnings" && s?.length === 0 || this._displayShaderLog(s);
  }
  // PRIVATE
  /** In-browser UI logging of errors */
  _displayShaderLog(e) {
    if (typeof document > "u" || !document?.createElement)
      return;
    const s = Ed(this.source).name, n = `${this.stage} ${s}`;
    let r = Cy(e, this.source, { showSourceCode: "all", html: !0 });
    const i = this.getTranslatedSource();
    i && (r += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${i}</pre></code>`);
    const o = document.createElement("Button");
    o.innerHTML = `
<h1>Shader Compilation Error in ${n}</h1><br /><br />
<code style="user-select:text;"><pre>
${r}
</pre></code>`, o.style.top = "10px", o.style.left = "10px", o.style.position = "absolute", o.style.zIndex = "9999", o.style.width = "100%", o.style.textAlign = "left", document.body.appendChild(o);
    const a = document.getElementsByClassName("luma-compiler-log-error");
    a[0]?.scrollIntoView && a[0].scrollIntoView(), o.onclick = () => {
      const c = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(c);
    };
  }
}
function By(t) {
  return Ed(t.source).name || t.id || Qt(`unnamed ${t.stage}-shader`);
}
class Pi extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, s) {
    super(e, s, Pi.defaultProps);
  }
}
class Oi extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  /** Color attachments */
  colorAttachments = [];
  /** Depth-stencil attachment, if provided */
  depthStencilAttachment = null;
  constructor(e, s = {}) {
    super(e, s, Oi.defaultProps), this.width = this.props.width, this.height = this.props.height;
  }
  resize(e) {
    let s = !e;
    if (e) {
      const [n, r] = Array.isArray(e) ? e : [e.width, e.height];
      s = s || r !== this.height || n !== this.width, this.width = n, this.height = r;
    }
    s && (P.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((s) => {
      if (typeof s == "string") {
        const n = this.createColorTexture(s);
        return this.attachResource(n), n.view;
      }
      return s instanceof Ne ? s.view : s;
    });
    const e = this.props.depthStencilAttachment;
    if (e)
      if (typeof e == "string") {
        const s = this.createDepthStencilTexture(e);
        this.attachResource(s), this.depthStencilAttachment = s.view;
      } else e instanceof Ne ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
  }
  /** Create a color texture */
  createColorTexture(e) {
    return this.device.createTexture({
      id: "color-attachment",
      usage: Ne.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(e) {
    return this.device.createTexture({
      id: "depth-stencil-attachment",
      usage: Ne.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(e, s) {
    for (let n = 0; n < this.colorAttachments.length; ++n)
      if (this.colorAttachments[n]) {
        const r = this.device._createTexture({
          ...this.colorAttachments[n].props,
          width: e,
          height: s
        });
        this.destroyAttachedResource(this.colorAttachments[n]), this.colorAttachments[n] = r.view, this.attachResource(r.view);
      }
    if (this.depthStencilAttachment) {
      const n = this.device._createTexture({
        ...this.depthStencilAttachment.props,
        width: e,
        height: s
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = n.view, this.attachResource(n);
    }
  }
}
class Qs extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    // isInstanced: false,
    // instanceCount: 0,
    // vertexCount: 0,
    bindings: {},
    uniforms: {}
  };
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(e, s) {
    super(e, s, Qs.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(e) {
    throw new Error("Use uniform blocks");
  }
}
class hc extends ee {
  /** Default properties for RenderPass */
  static defaultProps = {
    ...ee.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: !1,
    stencilReadOnly: !1,
    discard: !1,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, s) {
    super(e, s, hc.defaultProps);
  }
}
class hi extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  constructor(e, s) {
    super(e, s, hi.defaultProps);
  }
}
class uc extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    measureExecutionTime: void 0
  };
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, s) {
    super(e, s, uc.defaultProps);
  }
}
class fc extends ee {
  static defaultProps = {
    ...ee.defaultProps
  };
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, s) {
    super(e, s, fc.defaultProps);
  }
}
function My(t) {
  const [e, s] = Oy[t], n = e === "i32" || e === "u32", r = e !== "u32", i = xy[e] * s, o = Py(e, s);
  return {
    dataType: e,
    components: s,
    defaultVertexFormat: o,
    byteLength: i,
    integer: n,
    signed: r
  };
}
function Py(t, e) {
  let s;
  switch (t) {
    case "f32":
      s = "float32";
      break;
    case "i32":
      s = "sint32";
      break;
    case "u32":
      s = "uint32";
      break;
    case "f16":
      return e <= 2 ? "float16x2" : "float16x4";
  }
  return e === 1 ? s : `${s}x${e}`;
}
const Oy = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, xy = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function Cd(t) {
  let e;
  t.endsWith("-webgl") && (t.replace("-webgl", ""), e = !0);
  const [s, n] = t.split("x"), r = s, i = n ? parseInt(n) : 1, o = Ad(r), a = {
    type: r,
    components: i,
    byteLength: o.byteLength * i,
    integer: o.integer,
    signed: o.signed,
    normalized: o.normalized
  };
  return e && (a.webglOnly = !0), a;
}
function Sd(t, e) {
  const s = {};
  for (const n of t.attributes)
    s[n.name] = Fy(t, e, n.name);
  return s;
}
function Ny(t, e, s = 16) {
  const n = Sd(t, e), r = new Array(s).fill(null);
  for (const i of Object.values(n))
    r[i.location] = i;
  return r;
}
function Fy(t, e, s) {
  const n = Dy(t, s), r = Uy(e, s);
  if (!n)
    return null;
  const i = My(n.type), o = r?.vertexFormat || i.defaultVertexFormat, a = Cd(o);
  return {
    attributeName: r?.attributeName || n.name,
    bufferName: r?.bufferName || n.name,
    location: n.location,
    shaderType: n.type,
    shaderDataType: i.dataType,
    shaderComponents: i.components,
    vertexFormat: o,
    bufferDataType: a.type,
    bufferComponents: a.components,
    // normalized is a property of the buffer's vertex format
    normalized: a.normalized,
    // integer is a property of the shader declaration
    integer: i.integer,
    stepMode: r?.stepMode || n.stepMode,
    byteOffset: r?.byteOffset || 0,
    byteStride: r?.byteStride || 0
  };
}
function Dy(t, e) {
  const s = t.attributes.find((n) => n.name === e);
  return s || P.warn(`shader layout attribute "${e}" not present in shader`), s || null;
}
function Uy(t, e) {
  Ly(t);
  let s = ky(t, e);
  return s || (s = Vy(t, e), s) ? s : (P.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function Ly(t) {
  for (const e of t)
    (e.attributes && e.format || !e.attributes && !e.format) && P.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function ky(t, e) {
  for (const s of t)
    if (s.format && s.name === e)
      return {
        attributeName: s.name,
        bufferName: e,
        stepMode: s.stepMode,
        vertexFormat: s.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: s.byteStride || 0
      };
  return null;
}
function Vy(t, e) {
  for (const s of t) {
    let n = s.byteStride;
    if (typeof s.byteStride != "number")
      for (const i of s.attributes || []) {
        const o = Cd(i.format);
        n += o.byteLength;
      }
    const r = s.attributes?.find((i) => i.attribute === e);
    if (r)
      return {
        attributeName: r.attribute,
        bufferName: s.name,
        stepMode: s.stepMode,
        vertexFormat: r.format,
        byteOffset: r.byteOffset,
        byteStride: n
      };
  }
  return null;
}
function Hy(t, e) {
  const s = {
    ...t,
    attributes: t.attributes.map((n) => ({ ...n }))
  };
  for (const n of e?.attributes || []) {
    const r = s.attributes.find((i) => i.name === n.name);
    r ? (r.type = n.type || r.type, r.stepMode = n.stepMode || r.stepMode) : P.warn(`shader layout attribute ${n.name} not present in shader`);
  }
  return s;
}
class dc extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    renderPipeline: null
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(e, s) {
    super(e, s, dc.defaultProps), this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = Ny(s.renderPipeline.shaderLayout, s.renderPipeline.bufferLayout, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(e, s) {
    throw new Error("constant attributes not supported");
  }
}
class pc extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, s) {
    super(e, s, pc.defaultProps);
  }
}
class _c extends ee {
  static defaultProps = {
    ...ee.defaultProps,
    type: void 0,
    count: void 0
  };
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, s) {
    super(e, s, _c.defaultProps);
  }
}
const zy = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function jy(t) {
  const e = zy[t];
  return q(t), e;
}
function Wy(t, e) {
  switch (e) {
    case 1:
      return t;
    // Pad upwards to even multiple of 2
    case 2:
      return t + t % 2;
    // Pad upwards to even multiple of 2
    default:
      return t + (4 - t % 4) % 4;
  }
}
let Cr;
function Rd(t) {
  return (!Cr || Cr.byteLength < t) && (Cr = new ArrayBuffer(t)), Cr;
}
function Xy(t, e) {
  const s = Rd(t.BYTES_PER_ELEMENT * e);
  return new t(s, 0, e);
}
function Gy(t) {
  const { target: e, source: s, start: n = 0, count: r = 1 } = t, i = s.length, o = r * i;
  let a = 0;
  for (let c = n; a < i; a++)
    e[c++] = s[a];
  for (; a < o; )
    a < o - a ? (e.copyWithin(n + a, n, n + a), a *= 2) : (e.copyWithin(n + a, n, n + o - a), a = o);
  return t.target;
}
const ch = 1024;
class $y {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e) {
    let s = 0;
    for (const [r, i] of Object.entries(e)) {
      const o = jy(i), { type: a, components: c } = o;
      s = Wy(s, c);
      const l = s;
      s += c, this.layout[r] = { type: a, size: c, offset: l };
    }
    s += (4 - s % 4) % 4;
    const n = s * 4;
    this.byteLength = Math.max(n, ch);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const s = Math.max(this.byteLength, ch), n = Rd(s), r = {
      i32: new Int32Array(n),
      u32: new Uint32Array(n),
      f32: new Float32Array(n),
      // TODO not implemented
      f16: new Uint16Array(n)
    };
    for (const [i, o] of Object.entries(e)) {
      const a = this.layout[i];
      if (!a) {
        P.warn(`Supplied uniform value ${i} not present in uniform block layout`)();
        continue;
      }
      const { type: c, size: l, offset: h } = a, u = r[c];
      if (l === 1) {
        if (typeof o != "number" && typeof o != "boolean") {
          P.warn(`Supplied value for single component uniform ${i} is not a number: ${o}`)();
          continue;
        }
        u[h] = Number(o);
      } else {
        const f = Xn(o);
        if (!f) {
          P.warn(`Supplied value for multi component / array uniform ${i} is not a numeric array: ${o}`)();
          continue;
        }
        u.set(f, h);
      }
    }
    return new Uint8Array(n);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function Ky(t, e, s = 16) {
  if (t !== e)
    return !1;
  const n = Xn(t);
  if (!n)
    return !1;
  const r = Xn(e);
  if (r && n.length === r.length) {
    for (let i = 0; i < n.length; ++i)
      if (r[i] !== n[i])
        return !1;
  }
  return !0;
}
function Yy(t) {
  const e = Xn(t);
  return e ? e.slice() : t;
}
class Jy {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = !0;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(e) {
    if (this.name = e?.name, e?.name && e?.shaderLayout) {
      const s = e?.shaderLayout.bindings?.find((r) => r.type === "uniform" && r.name === e?.name);
      if (!s)
        throw new Error(e?.name);
      const n = s;
      for (const r of n.uniforms || [])
        this.bindingLayout[r.name] = r;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [s, n] of Object.entries(e))
      this._setUniform(s, n), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${s}=${n}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, s) {
    Ky(this.uniforms[e], s) || (this.uniforms[e] = Yy(s), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class qy {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    for (const [s, n] of Object.entries(e)) {
      const r = s, i = new $y(n.uniformTypes || {});
      this.uniformBufferLayouts.set(r, i);
      const o = new Jy({ name: s });
      o.setUniforms(n.defaultUniforms || {}), this.uniformBlocks.set(r, o);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    for (const [s, n] of Object.entries(e))
      this.uniformBlocks.get(s).setUniforms(n);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    return this.uniformBufferLayouts.get(e).byteLength;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    const s = this.uniformBlocks.get(e).getAllUniforms();
    return this.uniformBufferLayouts.get(e).getData(s);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, s, n) {
    n && this.setUniforms(n);
    const r = this.getUniformBufferByteLength(s), i = e.createBuffer({
      usage: re.UNIFORM | re.COPY_DST,
      byteLength: r
    }), o = this.getUniformBufferData(s);
    return i.write(o), i;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, s) {
    if (!this.uniformBuffers.get(s)) {
      const n = this.getUniformBufferByteLength(s), r = e.createBuffer({
        usage: re.UNIFORM | re.COPY_DST,
        byteLength: n
      });
      this.uniformBuffers.set(s, r);
    }
    return this.uniformBuffers.get(s);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const s of this.uniformBlocks.keys()) {
      const n = this.updateUniformBuffer(s);
      e ||= n;
    }
    return e && P.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    const s = this.uniformBlocks.get(e), n = this.uniformBuffers.get(e);
    let r = !1;
    if (n && s.needsRedraw) {
      r ||= s.needsRedraw;
      const i = this.getUniformBufferData(e);
      this.uniformBuffers.get(e).write(i);
      const a = this.uniformBlocks.get(e).getAllUniforms();
      P.log(4, `Writing to uniform buffer ${String(e)}`, i, a)();
    }
    return r;
  }
}
function wd(t) {
  const e = ArrayBuffer.isView(t) ? t.constructor : t;
  switch (e) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(e.constructor.name);
  }
}
function Id(t) {
  switch (t) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(t);
  }
}
function Zy(t, e, s) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const n = e;
  let r = wd(t);
  if (r === "uint8" && s && n === 1)
    return "unorm8-webgl";
  if (r === "uint8" && s && n === 3)
    return "unorm8x3-webgl";
  if (r === "uint8" || r === "sint8") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return s && (r = r.replace("int", "norm")), `${r}x${n}`;
  }
  if (r === "uint16" || r === "sint16") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return s && (r = r.replace("int", "norm")), `${r}x${n}`;
  }
  return n === 1 ? r : `${r}x${n}`;
}
function Qy(t) {
  return Xn(t) !== null || typeof t == "number" || typeof t == "boolean";
}
function gc(t) {
  const e = { bindings: {}, uniforms: {} };
  return Object.keys(t).forEach((s) => {
    const n = t[s];
    Qy(n) ? e.uniforms[s] = n : e.bindings[s] = n;
  }), e;
}
function eb(t, e, s) {
  const { removedProps: n = {}, deprecatedProps: r = {}, replacedProps: i = {} } = s;
  for (const a in n)
    if (a in e) {
      const l = n[a] ? `${t}.${n[a]}` : "N/A";
      P.removed(`${t}.${a}`, l)();
    }
  for (const a in r)
    if (a in e) {
      const c = r[a];
      P.deprecated(`${t}.${a}`, `${t}.${c}`)();
    }
  let o = null;
  for (const [a, c] of Object.entries(i))
    a in e && (P.deprecated(`${t}.${a}`, `${t}.${c}`)(), o = o || Object.assign({}, e), o[c] = e[a], delete o[a]);
  return o || e;
}
let tb = "";
async function sb(t, e) {
  return await new Promise((s, n) => {
    try {
      const r = new Image();
      r.onload = () => s(r), r.onerror = () => n(new Error(`Could not load image ${t}.`)), r.crossOrigin = e?.crossOrigin || "anonymous", r.src = t.startsWith("http") ? t : tb + t;
    } catch (r) {
      n(r);
    }
  });
}
async function vd(t, e) {
  const s = document.getElementsByTagName("head")[0];
  if (!s)
    throw new Error("loadScript");
  const n = document.createElement("script");
  return n.setAttribute("type", "text/javascript"), n.setAttribute("src", t), new Promise((r, i) => {
    n.onload = r, n.onerror = (o) => i(new Error(`Unable to load script '${t}': ${o}`)), s.appendChild(n);
  });
}
function ga(t, e, s) {
  if (t === e)
    return !0;
  if (!s || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (!ga(t[n], e[n], s - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const n = Object.keys(t), r = Object.keys(e);
    if (n.length !== r.length)
      return !1;
    for (const i of n)
      if (!e.hasOwnProperty(i) || !ga(t[i], e[i], s - 1))
        return !1;
    return !0;
  }
  return !1;
}
function nb(t) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(t) : setTimeout(t, 1e3 / 60);
}
function rb(t) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(t) : clearTimeout(t);
}
class ib {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class Pt {
  constructor() {
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  evaluate(e) {
    throw new Error("Cannot evaluate node");
  }
  evaluateString(e) {
    return this.evaluate(e).toString();
  }
  search(e) {
  }
  searchBlock(e, s) {
    if (e) {
      s(ui.instance);
      for (const n of e)
        n instanceof Array ? this.searchBlock(n, s) : n.search(s);
      s(fi.instance);
    }
  }
}
class ui extends Pt {
}
ui.instance = new ui();
class fi extends Pt {
}
fi.instance = new fi();
class ie extends Pt {
  constructor() {
    super();
  }
}
class ma extends ie {
  constructor(e, s, n, r, i, o) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = s, this.returnType = n, this.body = r, this.startLine = i, this.endLine = o;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class ob extends ie {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class ab extends ie {
  constructor(e, s) {
    super(), this.condition = e, this.body = s;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class cb extends ie {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class lb extends ie {
  constructor(e, s, n, r) {
    super(), this.init = e, this.condition = s, this.increment = n, this.body = r;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var s, n, r;
    (s = this.init) === null || s === void 0 || s.search(e), (n = this.condition) === null || n === void 0 || n.search(e), (r = this.increment) === null || r === void 0 || r.search(e), this.searchBlock(this.body, e);
  }
}
class cs extends ie {
  constructor(e, s, n, r, i) {
    super(), this.name = e, this.type = s, this.storage = n, this.access = r, this.value = i;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var s;
    e(this), (s = this.value) === null || s === void 0 || s.search(e);
  }
}
class Bd extends ie {
  constructor(e, s, n) {
    super(), this.name = e, this.type = s, this.value = n;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var s;
    (s = this.value) === null || s === void 0 || s.search(e);
  }
}
class Aa extends ie {
  constructor(e, s, n, r, i) {
    super(), this.name = e, this.type = s, this.storage = n, this.access = r, this.value = i;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var s;
    e(this), (s = this.value) === null || s === void 0 || s.search(e);
  }
}
class lh extends ie {
  constructor(e, s, n, r, i) {
    super(), this.name = e, this.type = s, this.storage = n, this.access = r, this.value = i;
  }
  get astNodeType() {
    return "const";
  }
  evaluate(e) {
    return this.value.evaluate(e);
  }
  search(e) {
    var s;
    e(this), (s = this.value) === null || s === void 0 || s.search(e);
  }
}
var en;
(function(t) {
  t.increment = "++", t.decrement = "--";
})(en || (en = {}));
(function(t) {
  function e(s) {
    const n = s;
    if (n == "parse")
      throw new Error("Invalid value for IncrementOperator");
    return t[n];
  }
  t.parse = e;
})(en || (en = {}));
class hb extends ie {
  constructor(e, s) {
    super(), this.operator = e, this.variable = s;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
var Gn;
(function(t) {
  t.assign = "=", t.addAssign = "+=", t.subtractAssin = "-=", t.multiplyAssign = "*=", t.divideAssign = "/=", t.moduloAssign = "%=", t.andAssign = "&=", t.orAssign = "|=", t.xorAssign = "^=", t.shiftLeftAssign = "<<=", t.shiftRightAssign = ">>=";
})(Gn || (Gn = {}));
(function(t) {
  function e(s) {
    const n = s;
    if (n == "parse")
      throw new Error("Invalid value for AssignOperator");
    return n;
  }
  t.parse = e;
})(Gn || (Gn = {}));
class ub extends ie {
  constructor(e, s, n) {
    super(), this.operator = e, this.variable = s, this.value = n;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class Md extends ie {
  constructor(e, s) {
    super(), this.name = e, this.args = s;
  }
  get astNodeType() {
    return "call";
  }
  search(e) {
    for (const s of this.args)
      s.search(e);
    e(this);
  }
}
class fb extends ie {
  constructor(e, s) {
    super(), this.body = e, this.continuing = s;
  }
  get astNodeType() {
    return "loop";
  }
}
class db extends ie {
  constructor(e, s) {
    super(), this.condition = e, this.body = s;
  }
  get astNodeType() {
    return "body";
  }
}
class pb extends ie {
  constructor(e, s, n, r) {
    super(), this.condition = e, this.body = s, this.elseif = n, this.else = r;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class _b extends ie {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var s;
    (s = this.value) === null || s === void 0 || s.search(e);
  }
}
class gb extends ie {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class mb extends ie {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class Ab extends ie {
  constructor(e, s) {
    super(), this.severity = e, this.rule = s;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class Pd extends ie {
  constructor(e, s) {
    super(), this.name = e, this.type = s;
  }
  get astNodeType() {
    return "alias";
  }
}
class Tb extends ie {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class yb extends ie {
  constructor() {
    super();
  }
  get astNodeType() {
    return "break";
  }
}
class bb extends ie {
  constructor() {
    super();
  }
  get astNodeType() {
    return "continue";
  }
}
class Es extends ie {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
}
class as extends Es {
  constructor(e, s, n, r) {
    super(e), this.members = s, this.startLine = n, this.endLine = r;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  /// Return the index of the member with the given name, or -1 if not found.
  getMemberIndex(e) {
    for (let s = 0; s < this.members.length; s++)
      if (this.members[s].name == e)
        return s;
    return -1;
  }
}
class Od extends Es {
  constructor(e, s, n) {
    super(e), this.format = s, this.access = n;
  }
  get astNodeType() {
    return "template";
  }
}
class Eb extends Es {
  constructor(e, s, n, r) {
    super(e), this.storage = s, this.type = n, this.access = r;
  }
  get astNodeType() {
    return "pointer";
  }
}
class xd extends Es {
  constructor(e, s, n, r) {
    super(e), this.attributes = s, this.format = n, this.count = r;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class xn extends Es {
  constructor(e, s, n) {
    super(e), this.format = s, this.access = n;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Tt extends Pt {
  constructor() {
    super();
  }
}
class Cb extends Tt {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  evaluateString() {
    return this.value;
  }
}
class Us extends Tt {
  constructor(e, s) {
    super(), this.type = e, this.args = s;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args)
      for (const s of this.args)
        s.search(e);
  }
  evaluate(e) {
    return this.args[0].evaluate(e);
  }
}
class Nd extends Tt {
  constructor(e, s) {
    super(), this.name = e, this.args = s;
  }
  get astNodeType() {
    return "callExpr";
  }
  evaluate(e) {
    switch (this.name) {
      case "abs":
        return Math.abs(this.args[0].evaluate(e));
      case "acos":
        return Math.acos(this.args[0].evaluate(e));
      case "acosh":
        return Math.acosh(this.args[0].evaluate(e));
      case "asin":
        return Math.asin(this.args[0].evaluate(e));
      case "asinh":
        return Math.asinh(this.args[0].evaluate(e));
      case "atan":
        return Math.atan(this.args[0].evaluate(e));
      case "atan2":
        return Math.atan2(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "atanh":
        return Math.atanh(this.args[0].evaluate(e));
      case "ceil":
        return Math.ceil(this.args[0].evaluate(e));
      case "clamp":
        return Math.min(Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e)), this.args[2].evaluate(e));
      case "cos":
        return Math.cos(this.args[0].evaluate(e));
      //case "cross":
      //TODO: (x[i] * y[j] - x[j] * y[i])
      case "degrees":
        return this.args[0].evaluate(e) * 180 / Math.PI;
      //case "determinant":
      //TODO implement
      case "distance":
        return Math.sqrt(Math.pow(this.args[0].evaluate(e) - this.args[1].evaluate(e), 2));
      case "dot":
      //TODO: (x[i] * y[i])
      case "exp":
        return Math.exp(this.args[0].evaluate(e));
      case "exp2":
        return Math.pow(2, this.args[0].evaluate(e));
      //case "extractBits":
      //TODO: implement
      //case "firstLeadingBit":
      //TODO: implement
      case "floor":
        return Math.floor(this.args[0].evaluate(e));
      case "fma":
        return this.args[0].evaluate(e) * this.args[1].evaluate(e) + this.args[2].evaluate(e);
      case "fract":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      //case "frexp":
      //TODO: implement
      case "inverseSqrt":
        return 1 / Math.sqrt(this.args[0].evaluate(e));
      //case "length":
      //TODO: implement
      case "log":
        return Math.log(this.args[0].evaluate(e));
      case "log2":
        return Math.log2(this.args[0].evaluate(e));
      case "max":
        return Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "min":
        return Math.min(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "mix":
        return this.args[0].evaluate(e) * (1 - this.args[2].evaluate(e)) + this.args[1].evaluate(e) * this.args[2].evaluate(e);
      case "modf":
        return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
      case "pow":
        return Math.pow(this.args[0].evaluate(e), this.args[1].evaluate(e));
      case "radians":
        return this.args[0].evaluate(e) * Math.PI / 180;
      case "round":
        return Math.round(this.args[0].evaluate(e));
      case "sign":
        return Math.sign(this.args[0].evaluate(e));
      case "sin":
        return Math.sin(this.args[0].evaluate(e));
      case "sinh":
        return Math.sinh(this.args[0].evaluate(e));
      case "saturate":
        return Math.min(Math.max(this.args[0].evaluate(e), 0), 1);
      case "smoothstep":
        return this.args[0].evaluate(e) * this.args[0].evaluate(e) * (3 - 2 * this.args[0].evaluate(e));
      case "sqrt":
        return Math.sqrt(this.args[0].evaluate(e));
      case "step":
        return this.args[0].evaluate(e) < this.args[1].evaluate(e) ? 0 : 1;
      case "tan":
        return Math.tan(this.args[0].evaluate(e));
      case "tanh":
        return Math.tanh(this.args[0].evaluate(e));
      case "trunc":
        return Math.trunc(this.args[0].evaluate(e));
      default:
        throw new Error("Non const function: " + this.name);
    }
  }
  search(e) {
    for (const s of this.args)
      s.search(e);
    e(this);
  }
}
class Ta extends Tt {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  evaluate(e) {
    const s = e.constants.get(this.name);
    if (!s)
      throw new Error("Cannot evaluate node");
    return s.evaluate(e);
  }
}
class hh extends Tt {
  constructor(e, s) {
    super(), this.name = e, this.initializer = s;
  }
  get astNodeType() {
    return "constExpr";
  }
  evaluate(e) {
    var s, n;
    if (this.initializer instanceof Us) {
      const r = (s = this.postfix) === null || s === void 0 ? void 0 : s.evaluateString(e), i = (n = this.initializer.type) === null || n === void 0 ? void 0 : n.name, o = e.structs.get(i), a = o?.getMemberIndex(r);
      return a !== void 0 && a != -1 ? this.initializer.args[a].evaluate(e) : this.initializer.evaluate(e);
    }
    return this.initializer.evaluate(e);
  }
  search(e) {
    this.initializer.search(e);
  }
}
class uh extends Tt {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "literalExpr";
  }
  evaluate() {
    return this.value;
  }
}
class Sb extends Tt {
  constructor(e, s) {
    super(), this.type = e, this.value = s;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class fh extends Tt {
  constructor(e) {
    super(), this.contents = e;
  }
  get astNodeType() {
    return "groupExpr";
  }
  evaluate(e) {
    return this.contents[0].evaluate(e);
  }
  search(e) {
    this.searchBlock(this.contents, e);
  }
}
class Rb extends Tt {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
class Fd extends Tt {
  constructor() {
    super();
  }
}
class wb extends Fd {
  constructor(e, s) {
    super(), this.operator = e, this.right = s;
  }
  get astNodeType() {
    return "unaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.right.evaluate(e);
      case "-":
        return -this.right.evaluate(e);
      case "!":
        return this.right.evaluate(e) ? 0 : 1;
      case "~":
        return ~this.right.evaluate(e);
      default:
        throw new Error("Unknown unary operator: " + this.operator);
    }
  }
  search(e) {
    this.right.search(e);
  }
}
class ct extends Fd {
  constructor(e, s, n) {
    super(), this.operator = e, this.left = s, this.right = n;
  }
  get astNodeType() {
    return "binaryOp";
  }
  evaluate(e) {
    switch (this.operator) {
      case "+":
        return this.left.evaluate(e) + this.right.evaluate(e);
      case "-":
        return this.left.evaluate(e) - this.right.evaluate(e);
      case "*":
        return this.left.evaluate(e) * this.right.evaluate(e);
      case "/":
        return this.left.evaluate(e) / this.right.evaluate(e);
      case "%":
        return this.left.evaluate(e) % this.right.evaluate(e);
      case "==":
        return this.left.evaluate(e) == this.right.evaluate(e) ? 1 : 0;
      case "!=":
        return this.left.evaluate(e) != this.right.evaluate(e) ? 1 : 0;
      case "<":
        return this.left.evaluate(e) < this.right.evaluate(e) ? 1 : 0;
      case ">":
        return this.left.evaluate(e) > this.right.evaluate(e) ? 1 : 0;
      case "<=":
        return this.left.evaluate(e) <= this.right.evaluate(e) ? 1 : 0;
      case ">=":
        return this.left.evaluate(e) >= this.right.evaluate(e) ? 1 : 0;
      case "&&":
        return this.left.evaluate(e) && this.right.evaluate(e) ? 1 : 0;
      case "||":
        return this.left.evaluate(e) || this.right.evaluate(e) ? 1 : 0;
      default:
        throw new Error(`Unknown operator ${this.operator}`);
    }
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class Dd extends Pt {
  constructor() {
    super();
  }
}
class Ib extends Dd {
  constructor(e, s) {
    super(), this.selector = e, this.body = s;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class vb extends Dd {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class Bb extends Pt {
  constructor(e, s, n) {
    super(), this.name = e, this.type = s, this.attributes = n;
  }
  get astNodeType() {
    return "argument";
  }
}
class Mb extends Pt {
  constructor(e, s) {
    super(), this.condition = e, this.body = s;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class Pb extends Pt {
  constructor(e, s, n) {
    super(), this.name = e, this.type = s, this.attributes = n;
  }
  get astNodeType() {
    return "member";
  }
}
let Ob = class extends Pt {
  constructor(e, s) {
    super(), this.name = e, this.value = s;
  }
  get astNodeType() {
    return "attribute";
  }
};
var R, y;
(function(t) {
  t[t.token = 0] = "token", t[t.keyword = 1] = "keyword", t[t.reserved = 2] = "reserved";
})(y || (y = {}));
class b {
  constructor(e, s, n) {
    this.name = e, this.type = s, this.rule = n;
  }
  toString() {
    return this.name;
  }
}
class g {
}
R = g;
g.none = new b("", y.reserved, "");
g.eof = new b("EOF", y.token, "");
g.reserved = {
  asm: new b("asm", y.reserved, "asm"),
  bf16: new b("bf16", y.reserved, "bf16"),
  do: new b("do", y.reserved, "do"),
  enum: new b("enum", y.reserved, "enum"),
  f16: new b("f16", y.reserved, "f16"),
  f64: new b("f64", y.reserved, "f64"),
  handle: new b("handle", y.reserved, "handle"),
  i8: new b("i8", y.reserved, "i8"),
  i16: new b("i16", y.reserved, "i16"),
  i64: new b("i64", y.reserved, "i64"),
  mat: new b("mat", y.reserved, "mat"),
  premerge: new b("premerge", y.reserved, "premerge"),
  regardless: new b("regardless", y.reserved, "regardless"),
  typedef: new b("typedef", y.reserved, "typedef"),
  u8: new b("u8", y.reserved, "u8"),
  u16: new b("u16", y.reserved, "u16"),
  u64: new b("u64", y.reserved, "u64"),
  unless: new b("unless", y.reserved, "unless"),
  using: new b("using", y.reserved, "using"),
  vec: new b("vec", y.reserved, "vec"),
  void: new b("void", y.reserved, "void")
};
g.keywords = {
  array: new b("array", y.keyword, "array"),
  atomic: new b("atomic", y.keyword, "atomic"),
  bool: new b("bool", y.keyword, "bool"),
  f32: new b("f32", y.keyword, "f32"),
  i32: new b("i32", y.keyword, "i32"),
  mat2x2: new b("mat2x2", y.keyword, "mat2x2"),
  mat2x3: new b("mat2x3", y.keyword, "mat2x3"),
  mat2x4: new b("mat2x4", y.keyword, "mat2x4"),
  mat3x2: new b("mat3x2", y.keyword, "mat3x2"),
  mat3x3: new b("mat3x3", y.keyword, "mat3x3"),
  mat3x4: new b("mat3x4", y.keyword, "mat3x4"),
  mat4x2: new b("mat4x2", y.keyword, "mat4x2"),
  mat4x3: new b("mat4x3", y.keyword, "mat4x3"),
  mat4x4: new b("mat4x4", y.keyword, "mat4x4"),
  ptr: new b("ptr", y.keyword, "ptr"),
  sampler: new b("sampler", y.keyword, "sampler"),
  sampler_comparison: new b("sampler_comparison", y.keyword, "sampler_comparison"),
  struct: new b("struct", y.keyword, "struct"),
  texture_1d: new b("texture_1d", y.keyword, "texture_1d"),
  texture_2d: new b("texture_2d", y.keyword, "texture_2d"),
  texture_2d_array: new b("texture_2d_array", y.keyword, "texture_2d_array"),
  texture_3d: new b("texture_3d", y.keyword, "texture_3d"),
  texture_cube: new b("texture_cube", y.keyword, "texture_cube"),
  texture_cube_array: new b("texture_cube_array", y.keyword, "texture_cube_array"),
  texture_multisampled_2d: new b("texture_multisampled_2d", y.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new b("texture_storage_1d", y.keyword, "texture_storage_1d"),
  texture_storage_2d: new b("texture_storage_2d", y.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new b("texture_storage_2d_array", y.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new b("texture_storage_3d", y.keyword, "texture_storage_3d"),
  texture_depth_2d: new b("texture_depth_2d", y.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new b("texture_depth_2d_array", y.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new b("texture_depth_cube", y.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new b("texture_depth_cube_array", y.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new b("texture_depth_multisampled_2d", y.keyword, "texture_depth_multisampled_2d"),
  texture_external: new b("texture_external", y.keyword, "texture_external"),
  u32: new b("u32", y.keyword, "u32"),
  vec2: new b("vec2", y.keyword, "vec2"),
  vec3: new b("vec3", y.keyword, "vec3"),
  vec4: new b("vec4", y.keyword, "vec4"),
  bitcast: new b("bitcast", y.keyword, "bitcast"),
  block: new b("block", y.keyword, "block"),
  break: new b("break", y.keyword, "break"),
  case: new b("case", y.keyword, "case"),
  continue: new b("continue", y.keyword, "continue"),
  continuing: new b("continuing", y.keyword, "continuing"),
  default: new b("default", y.keyword, "default"),
  diagnostic: new b("diagnostic", y.keyword, "diagnostic"),
  discard: new b("discard", y.keyword, "discard"),
  else: new b("else", y.keyword, "else"),
  enable: new b("enable", y.keyword, "enable"),
  fallthrough: new b("fallthrough", y.keyword, "fallthrough"),
  false: new b("false", y.keyword, "false"),
  fn: new b("fn", y.keyword, "fn"),
  for: new b("for", y.keyword, "for"),
  function: new b("function", y.keyword, "function"),
  if: new b("if", y.keyword, "if"),
  let: new b("let", y.keyword, "let"),
  const: new b("const", y.keyword, "const"),
  loop: new b("loop", y.keyword, "loop"),
  while: new b("while", y.keyword, "while"),
  private: new b("private", y.keyword, "private"),
  read: new b("read", y.keyword, "read"),
  read_write: new b("read_write", y.keyword, "read_write"),
  return: new b("return", y.keyword, "return"),
  requires: new b("requires", y.keyword, "requires"),
  storage: new b("storage", y.keyword, "storage"),
  switch: new b("switch", y.keyword, "switch"),
  true: new b("true", y.keyword, "true"),
  alias: new b("alias", y.keyword, "alias"),
  type: new b("type", y.keyword, "type"),
  uniform: new b("uniform", y.keyword, "uniform"),
  var: new b("var", y.keyword, "var"),
  override: new b("override", y.keyword, "override"),
  workgroup: new b("workgroup", y.keyword, "workgroup"),
  write: new b("write", y.keyword, "write"),
  r8unorm: new b("r8unorm", y.keyword, "r8unorm"),
  r8snorm: new b("r8snorm", y.keyword, "r8snorm"),
  r8uint: new b("r8uint", y.keyword, "r8uint"),
  r8sint: new b("r8sint", y.keyword, "r8sint"),
  r16uint: new b("r16uint", y.keyword, "r16uint"),
  r16sint: new b("r16sint", y.keyword, "r16sint"),
  r16float: new b("r16float", y.keyword, "r16float"),
  rg8unorm: new b("rg8unorm", y.keyword, "rg8unorm"),
  rg8snorm: new b("rg8snorm", y.keyword, "rg8snorm"),
  rg8uint: new b("rg8uint", y.keyword, "rg8uint"),
  rg8sint: new b("rg8sint", y.keyword, "rg8sint"),
  r32uint: new b("r32uint", y.keyword, "r32uint"),
  r32sint: new b("r32sint", y.keyword, "r32sint"),
  r32float: new b("r32float", y.keyword, "r32float"),
  rg16uint: new b("rg16uint", y.keyword, "rg16uint"),
  rg16sint: new b("rg16sint", y.keyword, "rg16sint"),
  rg16float: new b("rg16float", y.keyword, "rg16float"),
  rgba8unorm: new b("rgba8unorm", y.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new b("rgba8unorm_srgb", y.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new b("rgba8snorm", y.keyword, "rgba8snorm"),
  rgba8uint: new b("rgba8uint", y.keyword, "rgba8uint"),
  rgba8sint: new b("rgba8sint", y.keyword, "rgba8sint"),
  bgra8unorm: new b("bgra8unorm", y.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new b("bgra8unorm_srgb", y.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new b("rgb10a2unorm", y.keyword, "rgb10a2unorm"),
  rg11b10float: new b("rg11b10float", y.keyword, "rg11b10float"),
  rg32uint: new b("rg32uint", y.keyword, "rg32uint"),
  rg32sint: new b("rg32sint", y.keyword, "rg32sint"),
  rg32float: new b("rg32float", y.keyword, "rg32float"),
  rgba16uint: new b("rgba16uint", y.keyword, "rgba16uint"),
  rgba16sint: new b("rgba16sint", y.keyword, "rgba16sint"),
  rgba16float: new b("rgba16float", y.keyword, "rgba16float"),
  rgba32uint: new b("rgba32uint", y.keyword, "rgba32uint"),
  rgba32sint: new b("rgba32sint", y.keyword, "rgba32sint"),
  rgba32float: new b("rgba32float", y.keyword, "rgba32float"),
  static_assert: new b("static_assert", y.keyword, "static_assert")
  // WGSL grammar has a few keywords that have different token names than the strings they
  // represent. Aliasing them here.
  /*int32: new TokenType("i32", TokenClass.keyword, "i32"),
      uint32: new TokenType("u32", TokenClass.keyword, "u32"),
      float32: new TokenType("f32", TokenClass.keyword, "f32"),
      pointer: new TokenType("ptr", TokenClass.keyword, "ptr"),*/
};
g.tokens = {
  decimal_float_literal: new b("decimal_float_literal", y.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
  hex_float_literal: new b("hex_float_literal", y.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
  int_literal: new b("int_literal", y.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new b("uint_literal", y.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  ident: new b("ident", y.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new b("and", y.token, "&"),
  and_and: new b("and_and", y.token, "&&"),
  arrow: new b("arrow ", y.token, "->"),
  attr: new b("attr", y.token, "@"),
  forward_slash: new b("forward_slash", y.token, "/"),
  bang: new b("bang", y.token, "!"),
  bracket_left: new b("bracket_left", y.token, "["),
  bracket_right: new b("bracket_right", y.token, "]"),
  brace_left: new b("brace_left", y.token, "{"),
  brace_right: new b("brace_right", y.token, "}"),
  colon: new b("colon", y.token, ":"),
  comma: new b("comma", y.token, ","),
  equal: new b("equal", y.token, "="),
  equal_equal: new b("equal_equal", y.token, "=="),
  not_equal: new b("not_equal", y.token, "!="),
  greater_than: new b("greater_than", y.token, ">"),
  greater_than_equal: new b("greater_than_equal", y.token, ">="),
  shift_right: new b("shift_right", y.token, ">>"),
  less_than: new b("less_than", y.token, "<"),
  less_than_equal: new b("less_than_equal", y.token, "<="),
  shift_left: new b("shift_left", y.token, "<<"),
  modulo: new b("modulo", y.token, "%"),
  minus: new b("minus", y.token, "-"),
  minus_minus: new b("minus_minus", y.token, "--"),
  period: new b("period", y.token, "."),
  plus: new b("plus", y.token, "+"),
  plus_plus: new b("plus_plus", y.token, "++"),
  or: new b("or", y.token, "|"),
  or_or: new b("or_or", y.token, "||"),
  paren_left: new b("paren_left", y.token, "("),
  paren_right: new b("paren_right", y.token, ")"),
  semicolon: new b("semicolon", y.token, ";"),
  star: new b("star", y.token, "*"),
  tilde: new b("tilde", y.token, "~"),
  underscore: new b("underscore", y.token, "_"),
  xor: new b("xor", y.token, "^"),
  plus_equal: new b("plus_equal", y.token, "+="),
  minus_equal: new b("minus_equal", y.token, "-="),
  times_equal: new b("times_equal", y.token, "*="),
  division_equal: new b("division_equal", y.token, "/="),
  modulo_equal: new b("modulo_equal", y.token, "%="),
  and_equal: new b("and_equal", y.token, "&="),
  or_equal: new b("or_equal", y.token, "|="),
  xor_equal: new b("xor_equal", y.token, "^="),
  shift_right_equal: new b("shift_right_equal", y.token, ">>="),
  shift_left_equal: new b("shift_left_equal", y.token, "<<=")
};
g.simpleTokens = {
  "@": R.tokens.attr,
  "{": R.tokens.brace_left,
  "}": R.tokens.brace_right,
  ":": R.tokens.colon,
  ",": R.tokens.comma,
  "(": R.tokens.paren_left,
  ")": R.tokens.paren_right,
  ";": R.tokens.semicolon
};
g.literalTokens = {
  "&": R.tokens.and,
  "&&": R.tokens.and_and,
  "->": R.tokens.arrow,
  "/": R.tokens.forward_slash,
  "!": R.tokens.bang,
  "[": R.tokens.bracket_left,
  "]": R.tokens.bracket_right,
  "=": R.tokens.equal,
  "==": R.tokens.equal_equal,
  "!=": R.tokens.not_equal,
  ">": R.tokens.greater_than,
  ">=": R.tokens.greater_than_equal,
  ">>": R.tokens.shift_right,
  "<": R.tokens.less_than,
  "<=": R.tokens.less_than_equal,
  "<<": R.tokens.shift_left,
  "%": R.tokens.modulo,
  "-": R.tokens.minus,
  "--": R.tokens.minus_minus,
  ".": R.tokens.period,
  "+": R.tokens.plus,
  "++": R.tokens.plus_plus,
  "|": R.tokens.or,
  "||": R.tokens.or_or,
  "*": R.tokens.star,
  "~": R.tokens.tilde,
  _: R.tokens.underscore,
  "^": R.tokens.xor,
  "+=": R.tokens.plus_equal,
  "-=": R.tokens.minus_equal,
  "*=": R.tokens.times_equal,
  "/=": R.tokens.division_equal,
  "%=": R.tokens.modulo_equal,
  "&=": R.tokens.and_equal,
  "|=": R.tokens.or_equal,
  "^=": R.tokens.xor_equal,
  ">>=": R.tokens.shift_right_equal,
  "<<=": R.tokens.shift_left_equal
};
g.regexTokens = {
  decimal_float_literal: R.tokens.decimal_float_literal,
  hex_float_literal: R.tokens.hex_float_literal,
  int_literal: R.tokens.int_literal,
  uint_literal: R.tokens.uint_literal,
  ident: R.tokens.ident
};
g.storage_class = [
  R.keywords.function,
  R.keywords.private,
  R.keywords.workgroup,
  R.keywords.uniform,
  R.keywords.storage
];
g.access_mode = [
  R.keywords.read,
  R.keywords.write,
  R.keywords.read_write
];
g.sampler_type = [
  R.keywords.sampler,
  R.keywords.sampler_comparison
];
g.sampled_texture_type = [
  R.keywords.texture_1d,
  R.keywords.texture_2d,
  R.keywords.texture_2d_array,
  R.keywords.texture_3d,
  R.keywords.texture_cube,
  R.keywords.texture_cube_array
];
g.multisampled_texture_type = [
  R.keywords.texture_multisampled_2d
];
g.storage_texture_type = [
  R.keywords.texture_storage_1d,
  R.keywords.texture_storage_2d,
  R.keywords.texture_storage_2d_array,
  R.keywords.texture_storage_3d
];
g.depth_texture_type = [
  R.keywords.texture_depth_2d,
  R.keywords.texture_depth_2d_array,
  R.keywords.texture_depth_cube,
  R.keywords.texture_depth_cube_array,
  R.keywords.texture_depth_multisampled_2d
];
g.texture_external_type = [R.keywords.texture_external];
g.any_texture_type = [
  ...R.sampled_texture_type,
  ...R.multisampled_texture_type,
  ...R.storage_texture_type,
  ...R.depth_texture_type,
  ...R.texture_external_type
];
g.texel_format = [
  R.keywords.r8unorm,
  R.keywords.r8snorm,
  R.keywords.r8uint,
  R.keywords.r8sint,
  R.keywords.r16uint,
  R.keywords.r16sint,
  R.keywords.r16float,
  R.keywords.rg8unorm,
  R.keywords.rg8snorm,
  R.keywords.rg8uint,
  R.keywords.rg8sint,
  R.keywords.r32uint,
  R.keywords.r32sint,
  R.keywords.r32float,
  R.keywords.rg16uint,
  R.keywords.rg16sint,
  R.keywords.rg16float,
  R.keywords.rgba8unorm,
  R.keywords.rgba8unorm_srgb,
  R.keywords.rgba8snorm,
  R.keywords.rgba8uint,
  R.keywords.rgba8sint,
  R.keywords.bgra8unorm,
  R.keywords.bgra8unorm_srgb,
  R.keywords.rgb10a2unorm,
  R.keywords.rg11b10float,
  R.keywords.rg32uint,
  R.keywords.rg32sint,
  R.keywords.rg32float,
  R.keywords.rgba16uint,
  R.keywords.rgba16sint,
  R.keywords.rgba16float,
  R.keywords.rgba32uint,
  R.keywords.rgba32sint,
  R.keywords.rgba32float
];
g.const_literal = [
  R.tokens.int_literal,
  R.tokens.uint_literal,
  R.tokens.decimal_float_literal,
  R.tokens.hex_float_literal,
  R.keywords.true,
  R.keywords.false
];
g.literal_or_ident = [
  R.tokens.ident,
  R.tokens.int_literal,
  R.tokens.uint_literal,
  R.tokens.decimal_float_literal,
  R.tokens.hex_float_literal
];
g.element_count_expression = [
  R.tokens.int_literal,
  R.tokens.uint_literal,
  R.tokens.ident
];
g.template_types = [
  R.keywords.vec2,
  R.keywords.vec3,
  R.keywords.vec4,
  R.keywords.mat2x2,
  R.keywords.mat2x3,
  R.keywords.mat2x4,
  R.keywords.mat3x2,
  R.keywords.mat3x3,
  R.keywords.mat3x4,
  R.keywords.mat4x2,
  R.keywords.mat4x3,
  R.keywords.mat4x4,
  R.keywords.atomic,
  R.keywords.bitcast,
  ...R.any_texture_type
];
g.attribute_name = [R.tokens.ident, R.keywords.block, R.keywords.diagnostic];
g.assignment_operators = [
  R.tokens.equal,
  R.tokens.plus_equal,
  R.tokens.minus_equal,
  R.tokens.times_equal,
  R.tokens.division_equal,
  R.tokens.modulo_equal,
  R.tokens.and_equal,
  R.tokens.or_equal,
  R.tokens.xor_equal,
  R.tokens.shift_right_equal,
  R.tokens.shift_left_equal
];
g.increment_operators = [
  R.tokens.plus_plus,
  R.tokens.minus_minus
];
class dh {
  constructor(e, s, n) {
    this.type = e, this.lexeme = s, this.line = n;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return g.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == g.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class xb {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  /// Scan all tokens from the source.
  scanTokens() {
    for (; !this._isAtEnd(); )
      if (this._start = this._current, !this.scanToken())
        throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new dh(g.eof, "", this._line)), this._tokens;
  }
  /// Scan a single token from the source.
  scanToken() {
    let e = this._advance();
    if (e == `
`)
      return this._line++, !0;
    if (this._isWhitespace(e))
      return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd())
            return !0;
          e = this._advance();
        }
        return this._line++, !0;
      } else if (this._peekAhead() == "*") {
        this._advance();
        let o = 1;
        for (; o > 0; ) {
          if (this._isAtEnd())
            return !0;
          if (e = this._advance(), e == `
`)
            this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), o--, o == 0))
              return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), o++);
        }
        return !0;
      }
    }
    const s = g.simpleTokens[e];
    if (s)
      return this._addToken(s), !0;
    let n = g.none;
    const r = this._isAlpha(e), i = e === "_";
    if (this._isAlphaNumeric(e)) {
      let o = this._peekAhead();
      for (; this._isAlphaNumeric(o); )
        e += this._advance(), o = this._peekAhead();
    }
    if (r) {
      const o = g.keywords[e];
      if (o)
        return this._addToken(o), !0;
    }
    if (r || i)
      return this._addToken(g.tokens.ident), !0;
    for (; ; ) {
      let o = this._findType(e);
      const a = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (a == "=")
          return this._current++, e += a, this._addToken(g.tokens.minus_equal), !0;
        if (a == "-")
          return this._current++, e += a, this._addToken(g.tokens.minus_minus), !0;
        const c = this._tokens.length - 1;
        if ((g.literal_or_ident.indexOf(this._tokens[c].type) != -1 || this._tokens[c].type == g.tokens.paren_right) && a != ">")
          return this._addToken(o), !0;
      }
      if (e == ">" && (a == ">" || a == "=")) {
        let c = !1, l = this._tokens.length - 1;
        for (let h = 0; h < 5 && l >= 0 && g.assignment_operators.indexOf(this._tokens[l].type) === -1; ++h, --l)
          if (this._tokens[l].type === g.tokens.less_than) {
            l > 0 && this._tokens[l - 1].isArrayOrTemplateType() && (c = !0);
            break;
          }
        if (c)
          return this._addToken(o), !0;
      }
      if (o === g.none) {
        let c = e, l = 0;
        const h = 2;
        for (let u = 0; u < h; ++u)
          if (c += this._peekAhead(u), o = this._findType(c), o !== g.none) {
            l = u;
            break;
          }
        if (o === g.none)
          return n === g.none ? !1 : (this._current--, this._addToken(n), !0);
        e = c, this._current += l + 1;
      }
      if (n = o, this._isAtEnd())
        break;
      e += this._advance();
    }
    return n === g.none ? !1 : (this._addToken(n), !0);
  }
  _findType(e) {
    for (const n in g.regexTokens) {
      const r = g.regexTokens[n];
      if (this._match(e, r.rule))
        return r;
    }
    const s = g.literalTokens[e];
    return s || g.none;
  }
  _match(e, s) {
    const n = s.exec(e);
    return n && n.index == 0 && n[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  _isAlphaNumeric(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e == "_" || e >= "0" && e <= "9";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance(e = 0) {
    let s = this._source[this._current];
    return e = e || 0, e++, this._current += e, s;
  }
  _peekAhead(e = 0) {
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const s = this._source.substring(this._start, this._current);
    this._tokens.push(new dh(e, s, this._line));
  }
}
class Nb {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 0, this._context = new ib(), this._deferArrayCountEval = [];
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const s = [];
    for (; !this._isAtEnd(); ) {
      const n = this._global_decl_or_directive();
      if (!n)
        break;
      s.push(n);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const n of this._deferArrayCountEval) {
        const r = n.arrayType, i = n.countNode;
        if (i instanceof Ta) {
          const a = i.name, c = this._context.constants.get(a);
          if (c)
            try {
              const l = c.evaluate(this._context);
              r.count = l;
            } catch {
            }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    return s;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const s = new xb(e);
        this._tokens = s.scanTokens();
      } else
        this._tokens = e;
    else
      this._tokens = [];
    this._current = 0;
  }
  _error(e, s) {
    return {
      token: e,
      message: s,
      toString: function() {
        return `${s}`;
      }
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == g.eof;
  }
  _match(e) {
    if (e instanceof b)
      return this._check(e) ? (this._advance(), !0) : !1;
    for (let s = 0, n = e.length; s < n; ++s) {
      const r = e[s];
      if (this._check(r))
        return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, s) {
    if (this._check(e))
      return this._advance();
    throw this._error(this._peek(), s);
  }
  _check(e) {
    if (this._isAtEnd())
      return !1;
    const s = this._peek();
    if (e instanceof Array) {
      const n = s.type;
      return e.indexOf(n) != -1;
    }
    return s.type == e;
  }
  _advance() {
    var e, s;
    return this._currentLine = (s = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && s !== void 0 ? s : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(g.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._match(g.keywords.alias)) {
      const s = this._type_alias();
      return this._consume(g.tokens.semicolon, "Expected ';'"), s;
    }
    if (this._match(g.keywords.diagnostic)) {
      const s = this._diagnostic();
      return this._consume(g.tokens.semicolon, "Expected ';'"), s;
    }
    if (this._match(g.keywords.requires)) {
      const s = this._requires_directive();
      return this._consume(g.tokens.semicolon, "Expected ';'"), s;
    }
    if (this._match(g.keywords.enable)) {
      const s = this._enable_directive();
      return this._consume(g.tokens.semicolon, "Expected ';'"), s;
    }
    const e = this._attribute();
    if (this._check(g.keywords.var)) {
      const s = this._global_variable_decl();
      return s != null && (s.attributes = e), this._consume(g.tokens.semicolon, "Expected ';'."), s;
    }
    if (this._check(g.keywords.override)) {
      const s = this._override_variable_decl();
      return s != null && (s.attributes = e), this._consume(g.tokens.semicolon, "Expected ';'."), s;
    }
    if (this._check(g.keywords.let)) {
      const s = this._global_let_decl();
      return s != null && (s.attributes = e), this._consume(g.tokens.semicolon, "Expected ';'."), s;
    }
    if (this._check(g.keywords.const)) {
      const s = this._global_const_decl();
      return s != null && (s.attributes = e), this._consume(g.tokens.semicolon, "Expected ';'."), s;
    }
    if (this._check(g.keywords.struct)) {
      const s = this._struct_decl();
      return s != null && (s.attributes = e), s;
    }
    if (this._check(g.keywords.fn)) {
      const s = this._function_decl();
      return s != null && (s.attributes = e), s;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(g.keywords.fn))
      return null;
    const e = this._currentLine, s = this._consume(g.tokens.ident, "Expected function name.").toString();
    this._consume(g.tokens.paren_left, "Expected '(' for function arguments.");
    const n = [];
    if (!this._check(g.tokens.paren_right))
      do {
        if (this._check(g.tokens.paren_right))
          break;
        const a = this._attribute(), c = this._consume(g.tokens.ident, "Expected argument name.").toString();
        this._consume(g.tokens.colon, "Expected ':' for argument type.");
        const l = this._attribute(), h = this._type_decl();
        h != null && (h.attributes = l, n.push(new Bb(c, h, a)));
      } while (this._match(g.tokens.comma));
    this._consume(g.tokens.paren_right, "Expected ')' after function arguments.");
    let r = null;
    if (this._match(g.tokens.arrow)) {
      const a = this._attribute();
      r = this._type_decl(), r != null && (r.attributes = a);
    }
    const i = this._compound_statement(), o = this._currentLine;
    return new ma(s, n, r, i, e, o);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(g.tokens.brace_left, "Expected '{' for block."); !this._check(g.tokens.brace_right); ) {
      const s = this._statement();
      s !== null && e.push(s);
    }
    return this._consume(g.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(g.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._check(g.tokens.attr) && this._attribute(), this._check(g.keywords.if))
      return this._if_statement();
    if (this._check(g.keywords.switch))
      return this._switch_statement();
    if (this._check(g.keywords.loop))
      return this._loop_statement();
    if (this._check(g.keywords.for))
      return this._for_statement();
    if (this._check(g.keywords.while))
      return this._while_statement();
    if (this._check(g.keywords.continuing))
      return this._continuing_statement();
    if (this._check(g.keywords.static_assert))
      return this._static_assert_statement();
    if (this._check(g.tokens.brace_left))
      return this._compound_statement();
    let e = null;
    return this._check(g.keywords.return) ? e = this._return_statement() : this._check([
      g.keywords.var,
      g.keywords.let,
      g.keywords.const
    ]) ? e = this._variable_statement() : this._match(g.keywords.discard) ? e = new Tb() : this._match(g.keywords.break) ? e = new yb() : this._match(g.keywords.continue) ? e = new bb() : e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), e != null && this._consume(g.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(g.keywords.static_assert))
      return null;
    const e = this._optional_paren_expression();
    return new ob(e);
  }
  _while_statement() {
    if (!this._match(g.keywords.while))
      return null;
    const e = this._optional_paren_expression();
    this._check(g.tokens.attr) && this._attribute();
    const s = this._compound_statement();
    return new ab(e, s);
  }
  _continuing_statement() {
    if (!this._match(g.keywords.continuing))
      return null;
    const e = this._compound_statement();
    return new cb(e);
  }
  _for_statement() {
    if (!this._match(g.keywords.for))
      return null;
    this._consume(g.tokens.paren_left, "Expected '('.");
    const e = this._check(g.tokens.semicolon) ? null : this._for_init();
    this._consume(g.tokens.semicolon, "Expected ';'.");
    const s = this._check(g.tokens.semicolon) ? null : this._short_circuit_or_expression();
    this._consume(g.tokens.semicolon, "Expected ';'.");
    const n = this._check(g.tokens.paren_right) ? null : this._for_increment();
    this._consume(g.tokens.paren_right, "Expected ')'."), this._check(g.tokens.attr) && this._attribute();
    const r = this._compound_statement();
    return new lb(e, s, n, r);
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(g.keywords.var)) {
      const e = this._variable_decl();
      if (e === null)
        throw this._error(this._peek(), "Variable declaration expected.");
      let s = null;
      return this._match(g.tokens.equal) && (s = this._short_circuit_or_expression()), new cs(e.name, e.type, e.storage, e.access, s);
    }
    if (this._match(g.keywords.let)) {
      const e = this._consume(g.tokens.ident, "Expected name for let.").toString();
      let s = null;
      if (this._match(g.tokens.colon)) {
        const r = this._attribute();
        s = this._type_decl(), s != null && (s.attributes = r);
      }
      this._consume(g.tokens.equal, "Expected '=' for let.");
      const n = this._short_circuit_or_expression();
      return new Aa(e, s, null, null, n);
    }
    if (this._match(g.keywords.const)) {
      const e = this._consume(g.tokens.ident, "Expected name for const.").toString();
      let s = null;
      if (this._match(g.tokens.colon)) {
        const r = this._attribute();
        s = this._type_decl(), s != null && (s.attributes = r);
      }
      this._consume(g.tokens.equal, "Expected '=' for const.");
      const n = this._short_circuit_or_expression();
      return new lh(e, s, null, null, n);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, s = this._unary_expression();
    if (s == null)
      return null;
    if (!this._check(g.increment_operators))
      return this._current = e, null;
    const n = this._consume(g.increment_operators, "Expected increment operator");
    return new hb(n.type === g.tokens.plus_plus ? en.increment : en.decrement, s);
  }
  _assignment_statement() {
    let e = null;
    if (this._check(g.tokens.brace_right))
      return null;
    let s = this._match(g.tokens.underscore);
    if (s || (e = this._unary_expression()), !s && e == null)
      return null;
    const n = this._consume(g.assignment_operators, "Expected assignment operator."), r = this._short_circuit_or_expression();
    return new ub(Gn.parse(n.lexeme), e, r);
  }
  _func_call_statement() {
    if (!this._check(g.tokens.ident))
      return null;
    const e = this._current, s = this._consume(g.tokens.ident, "Expected function name."), n = this._argument_expression_list();
    return n === null ? (this._current = e, null) : new Md(s.lexeme, n);
  }
  _loop_statement() {
    if (!this._match(g.keywords.loop))
      return null;
    this._check(g.tokens.attr) && this._attribute(), this._consume(g.tokens.brace_left, "Expected '{' for loop.");
    const e = [];
    let s = this._statement();
    for (; s !== null; ) {
      if (Array.isArray(s))
        for (let r of s)
          e.push(r);
      else
        e.push(s);
      s = this._statement();
    }
    let n = null;
    return this._match(g.keywords.continuing) && (n = this._compound_statement()), this._consume(g.tokens.brace_right, "Expected '}' for loop."), new fb(e, n);
  }
  _switch_statement() {
    if (!this._match(g.keywords.switch))
      return null;
    const e = this._optional_paren_expression();
    this._check(g.tokens.attr) && this._attribute(), this._consume(g.tokens.brace_left, "Expected '{' for switch.");
    const s = this._switch_body();
    if (s == null || s.length == 0)
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(g.tokens.brace_right, "Expected '}' for switch."), new db(e, s);
  }
  _switch_body() {
    const e = [];
    if (this._match(g.keywords.case)) {
      const s = this._case_selectors();
      this._match(g.tokens.colon), this._check(g.tokens.attr) && this._attribute(), this._consume(g.tokens.brace_left, "Exected '{' for switch case.");
      const n = this._case_body();
      this._consume(g.tokens.brace_right, "Exected '}' for switch case."), e.push(new Ib(s, n));
    }
    if (this._match(g.keywords.default)) {
      this._match(g.tokens.colon), this._check(g.tokens.attr) && this._attribute(), this._consume(g.tokens.brace_left, "Exected '{' for switch default.");
      const s = this._case_body();
      this._consume(g.tokens.brace_right, "Exected '}' for switch default."), e.push(new vb(s));
    }
    if (this._check([g.keywords.default, g.keywords.case])) {
      const s = this._switch_body();
      e.push(s[0]);
    }
    return e;
  }
  _case_selectors() {
    const e = [
      this._shift_expression()
      //?.evaluate(this._context).toString() ?? "",
    ];
    for (; this._match(g.tokens.comma); )
      e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(g.keywords.fallthrough))
      return this._consume(g.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null)
      return [];
    e instanceof Array || (e = [e]);
    const s = this._case_body();
    return s.length == 0 ? e : [...e, s[0]];
  }
  _if_statement() {
    if (!this._match(g.keywords.if))
      return null;
    const e = this._optional_paren_expression();
    this._check(g.tokens.attr) && this._attribute();
    const s = this._compound_statement();
    let n = [];
    this._match_elseif() && (this._check(g.tokens.attr) && this._attribute(), n = this._elseif_statement(n));
    let r = null;
    return this._match(g.keywords.else) && (this._check(g.tokens.attr) && this._attribute(), r = this._compound_statement()), new pb(e, s, n, r);
  }
  _match_elseif() {
    return this._tokens[this._current].type === g.keywords.else && this._tokens[this._current + 1].type === g.keywords.if ? (this._advance(), this._advance(), !0) : !1;
  }
  _elseif_statement(e = []) {
    const s = this._optional_paren_expression(), n = this._compound_statement();
    return e.push(new Mb(s, n)), this._match_elseif() && (this._check(g.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(g.keywords.return))
      return null;
    const e = this._short_circuit_or_expression();
    return new _b(e);
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(g.tokens.or_or); )
      e = new ct(this._previous().toString(), e, this._short_circuit_and_expr());
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(g.tokens.and_and); )
      e = new ct(this._previous().toString(), e, this._inclusive_or_expression());
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(g.tokens.or); )
      e = new ct(this._previous().toString(), e, this._exclusive_or_expression());
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(g.tokens.xor); )
      e = new ct(this._previous().toString(), e, this._and_expression());
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(g.tokens.and); )
      e = new ct(this._previous().toString(), e, this._equality_expression());
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([g.tokens.equal_equal, g.tokens.not_equal]) ? new ct(this._previous().toString(), e, this._relational_expression()) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([
      g.tokens.less_than,
      g.tokens.greater_than,
      g.tokens.less_than_equal,
      g.tokens.greater_than_equal
    ]); )
      e = new ct(this._previous().toString(), e, this._shift_expression());
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([g.tokens.shift_left, g.tokens.shift_right]); )
      e = new ct(this._previous().toString(), e, this._additive_expression());
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([g.tokens.plus, g.tokens.minus]); )
      e = new ct(this._previous().toString(), e, this._multiplicative_expression());
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([
      g.tokens.star,
      g.tokens.forward_slash,
      g.tokens.modulo
    ]); )
      e = new ct(this._previous().toString(), e, this._unary_expression());
    return e;
  }
  _unary_expression() {
    return this._match([
      g.tokens.minus,
      g.tokens.bang,
      g.tokens.tilde,
      g.tokens.star,
      g.tokens.and
    ]) ? new wb(this._previous().toString(), this._unary_expression()) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), s = this._postfix_expression();
    return s && (e.postfix = s), e;
  }
  _postfix_expression() {
    if (this._match(g.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(g.tokens.bracket_right, "Expected ']'.");
      const s = new Rb(e), n = this._postfix_expression();
      return n && (s.postfix = n), s;
    }
    if (this._match(g.tokens.period)) {
      const e = this._consume(g.tokens.ident, "Expected member name."), s = this._postfix_expression(), n = new Cb(e.lexeme);
      return s && (n.postfix = s), n;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _primary_expression() {
    if (this._match(g.tokens.ident)) {
      const n = this._previous().toString();
      if (this._check(g.tokens.paren_left)) {
        const r = this._argument_expression_list(), i = this._getStruct(n);
        return i != null ? new Us(i, r) : new Nd(n, r);
      }
      if (this._context.constants.has(n)) {
        const r = this._context.constants.get(n);
        return new hh(n, r.value);
      }
      return new Ta(n);
    }
    if (this._match(g.const_literal))
      return new uh(parseFloat(this._previous().toString()));
    if (this._check(g.tokens.paren_left))
      return this._paren_expression();
    if (this._match(g.keywords.bitcast)) {
      this._consume(g.tokens.less_than, "Expected '<'.");
      const n = this._type_decl();
      this._consume(g.tokens.greater_than, "Expected '>'.");
      const r = this._paren_expression();
      return new Sb(n, r);
    }
    const e = this._type_decl(), s = this._argument_expression_list();
    return new Us(e, s);
  }
  _argument_expression_list() {
    if (!this._match(g.tokens.paren_left))
      return null;
    const e = [];
    do {
      if (this._check(g.tokens.paren_right))
        break;
      const s = this._short_circuit_or_expression();
      e.push(s);
    } while (this._match(g.tokens.comma));
    return this._consume(g.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(g.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(g.tokens.paren_right), new fh([e]);
  }
  _paren_expression() {
    this._consume(g.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(g.tokens.paren_right, "Expected ')'."), new fh([e]);
  }
  _struct_decl() {
    if (!this._match(g.keywords.struct))
      return null;
    const e = this._currentLine, s = this._consume(g.tokens.ident, "Expected name for struct.").toString();
    this._consume(g.tokens.brace_left, "Expected '{' for struct body.");
    const n = [];
    for (; !this._check(g.tokens.brace_right); ) {
      const o = this._attribute(), a = this._consume(g.tokens.ident, "Expected variable name.").toString();
      this._consume(g.tokens.colon, "Expected ':' for struct member type.");
      const c = this._attribute(), l = this._type_decl();
      l != null && (l.attributes = c), this._check(g.tokens.brace_right) ? this._match(g.tokens.comma) : this._consume(g.tokens.comma, "Expected ',' for struct member."), n.push(new Pb(a, l, o));
    }
    this._consume(g.tokens.brace_right, "Expected '}' after struct body.");
    const r = this._currentLine, i = new as(s, n, e, r);
    return this._context.structs.set(s, i), i;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    return e && this._match(g.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(g.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    if (!this._match(g.keywords.const))
      return null;
    const e = this._consume(g.tokens.ident, "Expected variable name");
    let s = null;
    if (this._match(g.tokens.colon)) {
      const i = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = i);
    }
    let n = null;
    if (this._match(g.tokens.equal)) {
      const i = this._short_circuit_or_expression();
      if (i instanceof Us)
        n = i;
      else if (i instanceof hh && i.initializer instanceof Us)
        n = i.initializer;
      else
        try {
          const o = i.evaluate(this._context);
          n = new uh(o);
        } catch {
          n = i;
        }
    }
    const r = new lh(e.toString(), s, "", "", n);
    return this._context.constants.set(r.name, r), r;
  }
  _global_let_decl() {
    if (!this._match(g.keywords.let))
      return null;
    const e = this._consume(g.tokens.ident, "Expected variable name");
    let s = null;
    if (this._match(g.tokens.colon)) {
      const r = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = r);
    }
    let n = null;
    return this._match(g.tokens.equal) && (n = this._const_expression()), new Aa(e.toString(), s, "", "", n);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(g.keywords.var))
      return null;
    let e = "", s = "";
    this._match(g.tokens.less_than) && (e = this._consume(g.storage_class, "Expected storage_class.").toString(), this._match(g.tokens.comma) && (s = this._consume(g.access_mode, "Expected access_mode.").toString()), this._consume(g.tokens.greater_than, "Expected '>'."));
    const n = this._consume(g.tokens.ident, "Expected variable name");
    let r = null;
    if (this._match(g.tokens.colon)) {
      const i = this._attribute();
      r = this._type_decl(), r != null && (r.attributes = i);
    }
    return new cs(n.toString(), r, e, s, null);
  }
  _override_decl() {
    if (!this._match(g.keywords.override))
      return null;
    const e = this._consume(g.tokens.ident, "Expected variable name");
    let s = null;
    if (this._match(g.tokens.colon)) {
      const n = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = n);
    }
    return new Bd(e.toString(), s, null);
  }
  _diagnostic() {
    this._consume(g.tokens.paren_left, "Expected '('");
    const e = this._consume(g.tokens.ident, "Expected severity control name.");
    this._consume(g.tokens.comma, "Expected ','");
    const s = this._consume(g.tokens.ident, "Expected diagnostic rule name.");
    return this._consume(g.tokens.paren_right, "Expected ')'"), new Ab(e.toString(), s.toString());
  }
  _enable_directive() {
    const e = this._consume(g.tokens.ident, "identity expected.");
    return new gb(e.toString());
  }
  _requires_directive() {
    const e = [this._consume(g.tokens.ident, "identity expected.").toString()];
    for (; this._match(g.tokens.comma); ) {
      const s = this._consume(g.tokens.ident, "identity expected.");
      e.push(s.toString());
    }
    return new mb(e);
  }
  _type_alias() {
    const e = this._consume(g.tokens.ident, "identity expected.");
    this._consume(g.tokens.equal, "Expected '=' for type alias.");
    let s = this._type_decl();
    if (s === null)
      throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(s.name) && (s = this._context.aliases.get(s.name).type);
    const n = new Pd(e.toString(), s);
    return this._context.aliases.set(n.name, n), n;
  }
  _type_decl() {
    if (this._check([
      g.tokens.ident,
      ...g.texel_format,
      g.keywords.bool,
      g.keywords.f32,
      g.keywords.i32,
      g.keywords.u32
    ])) {
      const n = this._advance(), r = n.toString();
      return this._context.structs.has(r) ? this._context.structs.get(r) : this._context.aliases.has(r) ? this._context.aliases.get(r).type : new Es(n.toString());
    }
    let e = this._texture_sampler_types();
    if (e)
      return e;
    if (this._check(g.template_types)) {
      let n = this._advance().toString(), r = null, i = null;
      return this._match(g.tokens.less_than) && (r = this._type_decl(), i = null, this._match(g.tokens.comma) && (i = this._consume(g.access_mode, "Expected access_mode for pointer").toString()), this._consume(g.tokens.greater_than, "Expected '>' for type.")), new Od(n, r, i);
    }
    if (this._match(g.keywords.ptr)) {
      let n = this._previous().toString();
      this._consume(g.tokens.less_than, "Expected '<' for pointer.");
      const r = this._consume(g.storage_class, "Expected storage_class for pointer");
      this._consume(g.tokens.comma, "Expected ',' for pointer.");
      const i = this._type_decl();
      let o = null;
      return this._match(g.tokens.comma) && (o = this._consume(g.access_mode, "Expected access_mode for pointer").toString()), this._consume(g.tokens.greater_than, "Expected '>' for pointer."), new Eb(n, r.toString(), i, o);
    }
    const s = this._attribute();
    if (this._match(g.keywords.array)) {
      let n = null, r = -1;
      const i = this._previous();
      let o = null;
      if (this._match(g.tokens.less_than)) {
        n = this._type_decl(), this._context.aliases.has(n.name) && (n = this._context.aliases.get(n.name).type);
        let c = "";
        if (this._match(g.tokens.comma)) {
          o = this._shift_expression();
          try {
            c = o.evaluate(this._context).toString(), o = null;
          } catch {
            c = "1";
          }
        }
        this._consume(g.tokens.greater_than, "Expected '>' for array."), r = c ? parseInt(c) : 0;
      }
      const a = new xd(i.toString(), s, n, r);
      return o && this._deferArrayCountEval.push({ arrayType: a, countNode: o }), a;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(g.sampler_type))
      return new xn(this._previous().toString(), null, null);
    if (this._match(g.depth_texture_type))
      return new xn(this._previous().toString(), null, null);
    if (this._match(g.sampled_texture_type) || this._match(g.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(g.tokens.less_than, "Expected '<' for sampler type.");
      const s = this._type_decl();
      return this._consume(g.tokens.greater_than, "Expected '>' for sampler type."), new xn(e.toString(), s, null);
    }
    if (this._match(g.storage_texture_type)) {
      const e = this._previous();
      this._consume(g.tokens.less_than, "Expected '<' for sampler type.");
      const s = this._consume(g.texel_format, "Invalid texel format.").toString();
      this._consume(g.tokens.comma, "Expected ',' after texel format.");
      const n = this._consume(g.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(g.tokens.greater_than, "Expected '>' for sampler type."), new xn(e.toString(), s, n);
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(g.tokens.attr); ) {
      const s = this._consume(g.attribute_name, "Expected attribute name"), n = new Ob(s.toString(), null);
      if (this._match(g.tokens.paren_left)) {
        if (n.value = this._consume(g.literal_or_ident, "Expected attribute value").toString(), this._check(g.tokens.comma)) {
          this._advance();
          do {
            const r = this._consume(g.literal_or_ident, "Expected attribute value").toString();
            n.value instanceof Array || (n.value = [n.value]), n.value.push(r);
          } while (this._match(g.tokens.comma));
        }
        this._consume(g.tokens.paren_right, "Expected ')'");
      }
      e.push(n);
    }
    return e.length == 0 ? null : e;
  }
}
class Gs {
  constructor(e, s) {
    this.name = e, this.attributes = s, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
}
class ph {
  constructor(e, s, n) {
    this.name = e, this.type = s, this.attributes = n, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class Sr extends Gs {
  constructor(e, s) {
    super(e, s), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class _o extends Gs {
  constructor(e, s) {
    super(e, s), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
}
class _h extends Gs {
  constructor(e, s, n, r) {
    super(e, n), this.format = s, this.access = r;
  }
  get isTemplate() {
    return !0;
  }
}
var Vt;
(function(t) {
  t[t.Uniform = 0] = "Uniform", t[t.Storage = 1] = "Storage", t[t.Texture = 2] = "Texture", t[t.Sampler = 3] = "Sampler", t[t.StorageTexture = 4] = "StorageTexture";
})(Vt || (Vt = {}));
class Rr {
  constructor(e, s, n, r, i, o, a) {
    this.name = e, this.type = s, this.group = n, this.binding = r, this.attributes = i, this.resourceType = o, this.access = a;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class Fb {
  constructor(e, s) {
    this.name = e, this.type = s;
  }
}
class wr {
  constructor(e, s) {
    this.align = e, this.size = s;
  }
}
class Db {
  constructor(e, s, n, r) {
    this.name = e, this.type = s, this.locationType = n, this.location = r, this.interpolation = null;
  }
}
class gh {
  constructor(e, s, n, r) {
    this.name = e, this.type = s, this.locationType = n, this.location = r;
  }
}
class Ub {
  constructor(e, s, n, r) {
    this.name = e, this.type = s, this.attributes = n, this.id = r;
  }
}
class Lb {
  constructor(e, s) {
    this.name = e, this.type = s;
  }
}
class kb {
  constructor(e, s = null) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = s;
  }
}
class Vb {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
class Hb {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class Rt {
  constructor(e) {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new Vb(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map(), e && this.update(e);
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  update(e) {
    const n = new Nb().parse(e);
    for (const r of n)
      r instanceof ma && this._functions.set(r.name, new Hb(r));
    for (const r of n)
      if (r instanceof as) {
        const i = this._getTypeInfo(r, null);
        i instanceof Sr && this.structs.push(i);
      }
    for (const r of n) {
      if (r instanceof Pd) {
        this.aliases.push(this._getAliasInfo(r));
        continue;
      }
      if (r instanceof Bd) {
        const i = r, o = this._getAttributeNum(i.attributes, "id", 0), a = i.type != null ? this._getTypeInfo(i.type, i.attributes) : null;
        this.overrides.push(new Ub(i.name, a, i.attributes, o));
        continue;
      }
      if (this._isUniformVar(r)) {
        const i = r, o = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), c = this._getTypeInfo(i.type, i.attributes), l = new Rr(i.name, c, o, a, i.attributes, Vt.Uniform, i.access);
        this.uniforms.push(l);
        continue;
      }
      if (this._isStorageVar(r)) {
        const i = r, o = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), c = this._getTypeInfo(i.type, i.attributes), l = this._isStorageTexture(c), h = new Rr(i.name, c, o, a, i.attributes, l ? Vt.StorageTexture : Vt.Storage, i.access);
        this.storage.push(h);
        continue;
      }
      if (this._isTextureVar(r)) {
        const i = r, o = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), c = this._getTypeInfo(i.type, i.attributes), l = this._isStorageTexture(c), h = new Rr(i.name, c, o, a, i.attributes, l ? Vt.StorageTexture : Vt.Texture, i.access);
        l ? this.storage.push(h) : this.textures.push(h);
        continue;
      }
      if (this._isSamplerVar(r)) {
        const i = r, o = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), c = this._getTypeInfo(i.type, i.attributes), l = new Rr(i.name, c, o, a, i.attributes, Vt.Sampler, i.access);
        this.samplers.push(l);
        continue;
      }
      if (r instanceof ma) {
        const i = this._getAttribute(r, "vertex"), o = this._getAttribute(r, "fragment"), a = this._getAttribute(r, "compute"), c = i || o || a, l = new kb(r.name, c?.name);
        l.startLine = r.startLine, l.endLine = r.endLine, this.functions.push(l), this._functions.get(r.name).info = l, c ? (this._functions.get(r.name).inUse = !0, l.inUse = !0, l.resources = this._findResources(r, !!c), l.inputs = this._getInputs(r.args), l.outputs = this._getOutputs(r.returnType), this.entry[c.name].push(l)) : (l.arguments = r.args.map((h) => new Lb(h.name, this._getTypeInfo(h.type, h.attributes))), l.returnType = r.returnType ? this._getTypeInfo(r.returnType, r.attributes) : null);
        continue;
      }
    }
    for (const r of this._functions.values())
      r.info && (r.info.inUse = r.inUse, this._addCalls(r.node, r.info.calls));
    for (const r of this._functions.values())
      r.node.search((i) => {
        var o;
        if (i.astNodeType === "varExpr") {
          const a = i;
          for (const c of this.overrides)
            a.name == c.name && ((o = r.info) === null || o === void 0 || o.overrides.push(c));
        }
      });
    for (const r of this.uniforms)
      this._markStructsInUse(r.type);
    for (const r of this.storage)
      this._markStructsInUse(r.type);
  }
  _markStructsInUse(e) {
    if (e)
      if (e.isStruct) {
        if (e.inUse = !0, e.members)
          for (const s of e.members)
            this._markStructsInUse(s.type);
      } else if (e.isArray)
        this._markStructsInUse(e.format);
      else if (e.isTemplate)
        e.format && this._markStructsInUse(e.format);
      else {
        const s = this._getAlias(e.name);
        s && this._markStructsInUse(s);
      }
  }
  _addCalls(e, s) {
    var n;
    for (const r of e.calls) {
      const i = (n = this._functions.get(r.name)) === null || n === void 0 ? void 0 : n.info;
      i && s.add(i);
    }
  }
  /// Find a resource by its group and binding.
  findResource(e, s) {
    for (const n of this.uniforms)
      if (n.group == e && n.binding == s)
        return n;
    for (const n of this.storage)
      if (n.group == e && n.binding == s)
        return n;
    for (const n of this.textures)
      if (n.group == e && n.binding == s)
        return n;
    for (const n of this.samplers)
      if (n.group == e && n.binding == s)
        return n;
    return null;
  }
  _findResource(e) {
    for (const s of this.uniforms)
      if (s.name == e)
        return s;
    for (const s of this.storage)
      if (s.name == e)
        return s;
    for (const s of this.textures)
      if (s.name == e)
        return s;
    for (const s of this.samplers)
      if (s.name == e)
        return s;
    return null;
  }
  _markStructsFromAST(e) {
    const s = this._getTypeInfo(e, null);
    this._markStructsInUse(s);
  }
  _findResources(e, s) {
    const n = [], r = this, i = [];
    return e.search((o) => {
      if (o instanceof ui)
        i.push({});
      else if (o instanceof fi)
        i.pop();
      else if (o instanceof cs) {
        const a = o;
        s && a.type !== null && this._markStructsFromAST(a.type), i.length > 0 && (i[i.length - 1][a.name] = a);
      } else if (o instanceof Us) {
        const a = o;
        s && a.type !== null && this._markStructsFromAST(a.type);
      } else if (o instanceof Aa) {
        const a = o;
        s && a.type !== null && this._markStructsFromAST(a.type), i.length > 0 && (i[i.length - 1][a.name] = a);
      } else if (o instanceof Ta) {
        const a = o;
        if (i.length > 0 && i[i.length - 1][a.name])
          return;
        const c = r._findResource(a.name);
        c && n.push(c);
      } else if (o instanceof Nd) {
        const a = o, c = r._functions.get(a.name);
        c && (s && (c.inUse = !0), e.calls.add(c.node), c.resources === null && (c.resources = r._findResources(c.node, s)), n.push(...c.resources));
      } else if (o instanceof Md) {
        const a = o, c = r._functions.get(a.name);
        c && (s && (c.inUse = !0), e.calls.add(c.node), c.resources === null && (c.resources = r._findResources(c.node, s)), n.push(...c.resources));
      }
    }), [...new Map(n.map((o) => [o.name, o])).values()];
  }
  getBindGroups() {
    const e = [];
    function s(n, r) {
      n >= e.length && (e.length = n + 1), e[n] === void 0 && (e[n] = []), r >= e[n].length && (e[n].length = r + 1);
    }
    for (const n of this.uniforms) {
      s(n.group, n.binding);
      const r = e[n.group];
      r[n.binding] = n;
    }
    for (const n of this.storage) {
      s(n.group, n.binding);
      const r = e[n.group];
      r[n.binding] = n;
    }
    for (const n of this.textures) {
      s(n.group, n.binding);
      const r = e[n.group];
      r[n.binding] = n;
    }
    for (const n of this.samplers) {
      s(n.group, n.binding);
      const r = e[n.group];
      r[n.binding] = n;
    }
    return e;
  }
  _getOutputs(e, s = void 0) {
    if (s === void 0 && (s = []), e instanceof as)
      this._getStructOutputs(e, s);
    else {
      const n = this._getOutputInfo(e);
      n !== null && s.push(n);
    }
    return s;
  }
  _getStructOutputs(e, s) {
    for (const n of e.members)
      if (n.type instanceof as)
        this._getStructOutputs(n.type, s);
      else {
        const r = this._getAttribute(n, "location") || this._getAttribute(n, "builtin");
        if (r !== null) {
          const i = this._getTypeInfo(n.type, n.type.attributes), o = this._parseInt(r.value), a = new gh(n.name, i, r.name, o);
          s.push(a);
        }
      }
  }
  _getOutputInfo(e) {
    const s = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (s !== null) {
      const n = this._getTypeInfo(e, e.attributes), r = this._parseInt(s.value);
      return new gh("", n, s.name, r);
    }
    return null;
  }
  _getInputs(e, s = void 0) {
    s === void 0 && (s = []);
    for (const n of e)
      if (n.type instanceof as)
        this._getStructInputs(n.type, s);
      else {
        const r = this._getInputInfo(n);
        r !== null && s.push(r);
      }
    return s;
  }
  _getStructInputs(e, s) {
    for (const n of e.members)
      if (n.type instanceof as)
        this._getStructInputs(n.type, s);
      else {
        const r = this._getInputInfo(n);
        r !== null && s.push(r);
      }
  }
  _getInputInfo(e) {
    const s = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (s !== null) {
      const n = this._getAttribute(e, "interpolation"), r = this._getTypeInfo(e.type, e.attributes), i = this._parseInt(s.value), o = new Db(e.name, r, s.name, i);
      return n !== null && (o.interpolation = this._parseString(n.value)), o;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const s = parseInt(e);
    return isNaN(s) ? e : s;
  }
  _getAlias(e) {
    for (const s of this.aliases)
      if (s.name == e)
        return s.type;
    return null;
  }
  _getAliasInfo(e) {
    return new Fb(e.name, this._getTypeInfo(e.type, null));
  }
  _getTypeInfo(e, s) {
    if (this._types.has(e))
      return this._types.get(e);
    if (e instanceof xd) {
      const r = e, i = r.format ? this._getTypeInfo(r.format, r.attributes) : null, o = new _o(r.name, s);
      return o.format = i, o.count = r.count, this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    if (e instanceof as) {
      const r = e, i = new Sr(r.name, s);
      i.startLine = r.startLine, i.endLine = r.endLine;
      for (const o of r.members) {
        const a = this._getTypeInfo(o.type, o.attributes);
        i.members.push(new ph(o.name, a, o.attributes));
      }
      return this._types.set(e, i), this._updateTypeInfo(i), i;
    }
    if (e instanceof xn) {
      const r = e, i = r.format instanceof Es, o = r.format ? i ? this._getTypeInfo(r.format, null) : new Gs(r.format, null) : null, a = new _h(r.name, o, s, r.access);
      return this._types.set(e, a), this._updateTypeInfo(a), a;
    }
    if (e instanceof Od) {
      const r = e, i = r.format ? this._getTypeInfo(r.format, null) : null, o = new _h(r.name, i, s, r.access);
      return this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    const n = new Gs(e.name, s);
    return this._types.set(e, n), this._updateTypeInfo(n), n;
  }
  _updateTypeInfo(e) {
    var s, n;
    const r = this._getTypeSize(e);
    if (e.size = (s = r?.size) !== null && s !== void 0 ? s : 0, e instanceof _o && e.format) {
      const i = this._getTypeSize(e.format);
      e.stride = (n = i?.size) !== null && n !== void 0 ? n : 0, this._updateTypeInfo(e.format);
    }
    e instanceof Sr && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var s;
    let n = 0, r = 0, i = 0, o = 0;
    for (let a = 0, c = e.members.length; a < c; ++a) {
      const l = e.members[a], h = this._getTypeSize(l);
      if (!h)
        continue;
      (s = this._getAlias(l.type.name)) !== null && s !== void 0 || l.type;
      const u = h.align, f = h.size;
      n = this._roundUp(u, n + r), r = f, i = n, o = Math.max(o, u), l.offset = n, l.size = f, this._updateTypeInfo(l.type);
    }
    e.size = this._roundUp(o, i + r), e.align = o;
  }
  _getTypeSize(e) {
    var s, n;
    if (e == null)
      return null;
    const r = this._getAttributeNum(e.attributes, "size", 0), i = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof ph && (e = e.type), e instanceof Gs) {
      const o = this._getAlias(e.name);
      o !== null && (e = o);
    }
    {
      const o = Rt._typeInfo[e.name];
      if (o !== void 0) {
        const a = ((s = e.format) === null || s === void 0 ? void 0 : s.name) === "f16" ? 2 : 1;
        return new wr(Math.max(i, o.align / a), Math.max(r, o.size / a));
      }
    }
    {
      const o = Rt._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (o) {
        const a = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new wr(Math.max(i, o.align / a), Math.max(r, o.size / a));
      }
    }
    if (e instanceof _o) {
      let o = e, a = 8, c = 8;
      const l = this._getTypeSize(o.format);
      l !== null && (c = l.size, a = l.align);
      const h = o.count, u = this._getAttributeNum((n = e?.attributes) !== null && n !== void 0 ? n : null, "stride", this._roundUp(a, c));
      return c = h * u, r && (c = r), new wr(Math.max(i, a), Math.max(r, c));
    }
    if (e instanceof Sr) {
      let o = 0, a = 0, c = 0, l = 0, h = 0;
      for (const u of e.members) {
        const f = this._getTypeSize(u.type);
        f !== null && (o = Math.max(f.align, o), c = this._roundUp(f.align, c + l), l = f.size, h = c);
      }
      return a = this._roundUp(o, h + l), new wr(Math.max(i, o), Math.max(r, a));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof cs && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof cs && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof cs && e.type !== null && Rt._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof cs && e.type !== null && Rt._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, s) {
    const n = e;
    if (!n || !n.attributes)
      return null;
    const r = n.attributes;
    for (let i of r)
      if (i.name == s)
        return i;
    return null;
  }
  _getAttributeNum(e, s, n) {
    if (e === null)
      return n;
    for (let r of e)
      if (r.name == s) {
        let i = r !== null && r.value !== null ? r.value : n;
        return i instanceof Array && (i = i[0]), typeof i == "number" ? i : typeof i == "string" ? parseInt(i) : n;
      }
    return n;
  }
  _roundUp(e, s) {
    return Math.ceil(s / e) * e;
  }
}
Rt._typeInfo = {
  f16: { align: 2, size: 2 },
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  atomic: { align: 4, size: 4 },
  vec2: { align: 8, size: 8 },
  vec3: { align: 16, size: 12 },
  vec4: { align: 16, size: 16 },
  mat2x2: { align: 8, size: 16 },
  mat3x2: { align: 8, size: 24 },
  mat4x2: { align: 8, size: 32 },
  mat2x3: { align: 16, size: 32 },
  mat3x3: { align: 16, size: 48 },
  mat4x3: { align: 16, size: 64 },
  mat2x4: { align: 16, size: 32 },
  mat3x4: { align: 16, size: 48 },
  mat4x4: { align: 16, size: 64 }
};
Rt._textureTypes = g.any_texture_type.map((t) => t.name);
Rt._samplerTypes = g.sampler_type.map((t) => t.name);
function zb(t) {
  const e = { attributes: [], bindings: [] };
  let s;
  try {
    s = jb(t);
  } catch (i) {
    return P.error(i.message)(), e;
  }
  for (const i of s.uniforms) {
    const o = [];
    for (const a of i.type?.members || [])
      o.push({
        name: a.name,
        type: mh(a.type)
      });
    e.bindings.push({
      type: "uniform",
      name: i.name,
      location: i.binding,
      // @ts-expect-error
      group: i.group,
      members: o
    });
  }
  const n = s.entry.vertex[0], r = n?.inputs.length || 0;
  for (let i = 0; i < r; i++) {
    const o = n.inputs[i];
    if (o.locationType === "location") {
      const a = mh(o.type);
      e.attributes.push({
        name: o.name,
        location: Number(o.location),
        type: a
      });
    }
  }
  return e;
}
function mh(t) {
  return t.format ? `${t.name}<${t.format.name}>` : t.name;
}
function jb(t) {
  try {
    return new Rt(t);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let s = "WGSL parse error";
    throw typeof e == "object" && e?.message && (s += `: ${e.message} `), typeof e == "object" && e?.token && (s += e.token.line || ""), new Error(s, { cause: e });
  }
}
const Wb = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`, Xb = {
  name: "fp32",
  vs: Wb
}, Gb = [0, 1, 1, 1], $b = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`, Kb = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`, Ah = {
  name: "picking",
  vs: $b,
  fs: Kb,
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: Gb
  },
  getUniforms: Yb
};
function Yb(t = {}, e) {
  const s = {};
  if (t.highlightedObjectColor !== void 0) if (t.highlightedObjectColor === null)
    s.isHighlightActive = !1;
  else {
    s.isHighlightActive = !0;
    const n = t.highlightedObjectColor.slice(0, 3);
    s.highlightedObjectColor = n;
  }
  if (t.highlightColor) {
    const n = Array.from(t.highlightColor, (r) => r / 255);
    Number.isFinite(n[3]) || (n[3] = 1), s.highlightColor = n;
  }
  return t.isActive !== void 0 && (s.isActive = !!t.isActive, s.isAttribute = !!t.isAttribute), t.useFloatColors !== void 0 && (s.useFloatColors = !!t.useFloatColors), s;
}
function Ud(t, e = [], s = 0) {
  const n = Math.fround(t), r = t - n;
  return e[s] = n, e[s + 1] = r, e;
}
function Jb(t) {
  return t - Math.fround(t);
}
function qb(t) {
  const e = new Float32Array(32);
  for (let s = 0; s < 4; ++s)
    for (let n = 0; n < 4; ++n) {
      const r = s * 4 + n;
      Ud(t[n * 4 + s], e, r * 2);
    }
  return e;
}
const Zb = `uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`, Qb = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
function eE() {
  return Qb;
}
const tE = {
  name: "fp64-arithmetic",
  vs: Zb,
  getUniforms: eE,
  fp64ify: Ud,
  fp64LowPart: Jb,
  fp64ifyMatrix4: qb
}, sE = 1 / Math.PI * 180, nE = 1 / 180 * Math.PI, rE = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || { config: { ...rE } };
const fe = globalThis.mathgl.config;
function iE(t, { precision: e = fe.precision } = {}) {
  return t = lE(t), `${parseFloat(t.toPrecision(e))}`;
}
function Kt(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function oE(t) {
  return cE(t);
}
function aE(t) {
  return Ge(t);
}
function cE(t, e) {
  return mc(t, (s) => s * nE, e);
}
function Ge(t, e) {
  return mc(t, (s) => s * sE, e);
}
function wt(t, e, s) {
  return mc(t, (n) => Math.max(e, Math.min(s, n)));
}
function di(t, e, s) {
  return Kt(t) ? t.map((n, r) => di(n, e[r], s)) : s * e + (1 - s) * t;
}
function Qe(t, e, s) {
  const n = fe.EPSILON;
  s && (fe.EPSILON = s);
  try {
    if (t === e)
      return !0;
    if (Kt(t) && Kt(e)) {
      if (t.length !== e.length)
        return !1;
      for (let r = 0; r < t.length; ++r)
        if (!Qe(t[r], e[r]))
          return !1;
      return !0;
    }
    return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : typeof t == "number" && typeof e == "number" ? Math.abs(t - e) <= fe.EPSILON * Math.max(1, Math.abs(t), Math.abs(e)) : !1;
  } finally {
    fe.EPSILON = n;
  }
}
function lE(t) {
  return Math.round(t / fe.EPSILON) * fe.EPSILON;
}
function hE(t) {
  return t.clone ? t.clone() : new Array(t.length);
}
function mc(t, e, s) {
  if (Kt(t)) {
    const n = t;
    s = s || hE(n);
    for (let r = 0; r < s.length && r < n.length; ++r) {
      const i = typeof t == "number" ? t : t[r];
      s[r] = e(i, r, s);
    }
    return s;
  }
  return e(t);
}
class Ac extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, s = 0) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = e[n + s];
    return this.check();
  }
  toArray(e = [], s = 0) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      e[s + n] = this[n];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Kt(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(fe);
  }
  /** Formats string according to options */
  formatString(e) {
    let s = "";
    for (let n = 0; n < this.ELEMENTS; ++n)
      s += (n > 0 ? ", " : "") + iE(this[n], e);
    return `${e.printTypes ? this.constructor.name : ""}[${s}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let s = 0; s < this.ELEMENTS; ++s)
      if (!Qe(this[s], e[s]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let s = 0; s < this.ELEMENTS; ++s)
      if (this[s] !== e[s])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, s, n) {
    if (n === void 0)
      return this.lerp(this, e, s);
    for (let r = 0; r < this.ELEMENTS; ++r) {
      const i = e[r], o = typeof s == "number" ? s : s[r];
      this[r] = i + n * (o - i);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.min(e[s], this[s]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = Math.max(e[s], this[s]);
    return this.check();
  }
  clamp(e, s) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e[n]), s[n]);
    return this.check();
  }
  add(...e) {
    for (const s of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] += s[n];
    return this.check();
  }
  subtract(...e) {
    for (const s of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] -= s[n];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= e;
    else
      for (let s = 0; s < this.ELEMENTS && s < e.length; ++s)
        this[s] *= e[s];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (fe.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let s = 0; s < this.ELEMENTS; ++s)
      e = e && Number.isFinite(this[s]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let s = 0; s < this.ELEMENTS; ++s)
      this[s] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, s) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e), s);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function uE(t, e) {
  if (t.length !== e)
    return !1;
  for (let s = 0; s < t.length; ++s)
    if (!Number.isFinite(t[s]))
      return !1;
  return !0;
}
function J(t) {
  if (!Number.isFinite(t))
    throw new Error(`Invalid number ${JSON.stringify(t)}`);
  return t;
}
function Vn(t, e, s = "") {
  if (fe.debug && !uE(t, e))
    throw new Error(`math.gl: ${s} some fields set to invalid numbers'`);
  return t;
}
function $e(t, e) {
  if (!t)
    throw new Error(`math.gl assertion ${e}`);
}
class Tc extends Ac {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = J(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = J(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let s = 0; s < this.ELEMENTS; ++s)
      e += this[s] * this[s];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let s = 0;
    for (let n = 0; n < this.ELEMENTS; ++n) {
      const r = this[n] - e[n];
      s += r * r;
    }
    return J(s);
  }
  dot(e) {
    let s = 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      s += this[n] * e[n];
    return J(s);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= e;
    return this.check();
  }
  multiply(...e) {
    for (const s of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] *= s[n];
    return this.check();
  }
  divide(...e) {
    for (const s of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] /= s[n];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return $e(e >= 0 && e < this.ELEMENTS, "index is out of range"), J(this[e]);
  }
  setComponent(e, s) {
    return $e(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = s, this.check();
  }
  addVectors(e, s) {
    return this.copy(e).add(s);
  }
  subVectors(e, s) {
    return this.copy(e).subtract(s);
  }
  multiplyVectors(e, s) {
    return this.copy(e).multiply(s);
  }
  addScaledVector(e, s) {
    return this.add(new this.constructor(e).multiplyScalar(s));
  }
}
const Hn = 1e-6;
let tt = typeof Float32Array < "u" ? Float32Array : Array;
function fE() {
  const t = new tt(2);
  return tt != Float32Array && (t[0] = 0, t[1] = 0), t;
}
function Th(t, e, s) {
  return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t;
}
function dE(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t;
}
function Ld(t, e, s, n) {
  const r = e[0], i = e[1];
  return t[0] = r + n * (s[0] - r), t[1] = i + n * (s[1] - i), t;
}
function pE(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[2] * r, t[1] = s[1] * n + s[3] * r, t;
}
function _E(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[2] * r + s[4], t[1] = s[1] * n + s[3] * r + s[5], t;
}
function kd(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[3] * r + s[6], t[1] = s[1] * n + s[4] * r + s[7], t;
}
function Vd(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[4] * r + s[12], t[1] = s[1] * n + s[5] * r + s[13], t;
}
(function() {
  const t = fE();
  return function(e, s, n, r, i, o) {
    let a, c;
    for (s || (s = 2), n || (n = 0), r ? c = Math.min(r * s + n, e.length) : c = e.length, a = n; a < c; a += s)
      t[0] = e[a], t[1] = e[a + 1], i(t, t, o), e[a] = t[0], e[a + 1] = t[1];
    return e;
  };
})();
function Hd(t, e, s) {
  const n = e[0], r = e[1], i = s[3] * n + s[7] * r || 1;
  return t[0] = (s[0] * n + s[4] * r) / i, t[1] = (s[1] * n + s[5] * r) / i, t;
}
function zd(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = s[3] * n + s[7] * r + s[11] * i || 1;
  return t[0] = (s[0] * n + s[4] * r + s[8] * i) / o, t[1] = (s[1] * n + s[5] * r + s[9] * i) / o, t[2] = (s[2] * n + s[6] * r + s[10] * i) / o, t;
}
function gE(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[2] * r, t[1] = s[1] * n + s[3] * r, t[2] = e[2], t;
}
function mE(t, e, s) {
  const n = e[0], r = e[1];
  return t[0] = s[0] * n + s[2] * r, t[1] = s[1] * n + s[3] * r, t[2] = e[2], t[3] = e[3], t;
}
function jd(t, e, s) {
  const n = e[0], r = e[1], i = e[2];
  return t[0] = s[0] * n + s[3] * r + s[6] * i, t[1] = s[1] * n + s[4] * r + s[7] * i, t[2] = s[2] * n + s[5] * r + s[8] * i, t[3] = e[3], t;
}
class yc extends Tc {
  // Creates a new, empty vec2
  constructor(e = 0, s = 0) {
    super(2), Kt(e) && arguments.length === 1 ? this.copy(e) : (fe.debug && (J(e), J(s)), this[0] = e, this[1] = s);
  }
  set(e, s) {
    return this[0] = e, this[1] = s, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return fe.debug && (J(e.x), J(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return Vd(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return Hd(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return kd(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return _E(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return pE(this, this, e), this.check();
  }
}
function Wd() {
  const t = new tt(3);
  return tt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
}
function Xd(t) {
  const e = t[0], s = t[1], n = t[2];
  return Math.sqrt(e * e + s * s + n * n);
}
function yh(t, e, s) {
  const n = new tt(3);
  return n[0] = t, n[1] = e, n[2] = s, n;
}
function AE(t, e, s) {
  return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], t;
}
function TE(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
}
function yE(t, e) {
  const s = e[0], n = e[1], r = e[2];
  let i = s * s + n * n + r * r;
  return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t;
}
function bc(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function Qr(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = s[0], a = s[1], c = s[2];
  return t[0] = r * c - i * a, t[1] = i * o - n * c, t[2] = n * a - r * o, t;
}
function Ec(t, e, s) {
  const n = e[0], r = e[1], i = e[2];
  let o = s[3] * n + s[7] * r + s[11] * i + s[15];
  return o = o || 1, t[0] = (s[0] * n + s[4] * r + s[8] * i + s[12]) / o, t[1] = (s[1] * n + s[5] * r + s[9] * i + s[13]) / o, t[2] = (s[2] * n + s[6] * r + s[10] * i + s[14]) / o, t;
}
function Gd(t, e, s) {
  const n = e[0], r = e[1], i = e[2];
  return t[0] = n * s[0] + r * s[3] + i * s[6], t[1] = n * s[1] + r * s[4] + i * s[7], t[2] = n * s[2] + r * s[5] + i * s[8], t;
}
function $d(t, e, s) {
  const n = s[0], r = s[1], i = s[2], o = s[3], a = e[0], c = e[1], l = e[2];
  let h = r * l - i * c, u = i * a - n * l, f = n * c - r * a, p = r * f - i * u, m = i * h - n * f, A = n * u - r * h;
  const E = o * 2;
  return h *= E, u *= E, f *= E, p *= 2, m *= 2, A *= 2, t[0] = a + h + p, t[1] = c + u + m, t[2] = l + f + A, t;
}
function bE(t, e, s, n) {
  const r = [], i = [];
  return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], i[0] = r[0], i[1] = r[1] * Math.cos(n) - r[2] * Math.sin(n), i[2] = r[1] * Math.sin(n) + r[2] * Math.cos(n), t[0] = i[0] + s[0], t[1] = i[1] + s[1], t[2] = i[2] + s[2], t;
}
function EE(t, e, s, n) {
  const r = [], i = [];
  return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], i[0] = r[2] * Math.sin(n) + r[0] * Math.cos(n), i[1] = r[1], i[2] = r[2] * Math.cos(n) - r[0] * Math.sin(n), t[0] = i[0] + s[0], t[1] = i[1] + s[1], t[2] = i[2] + s[2], t;
}
function CE(t, e, s, n) {
  const r = [], i = [];
  return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], i[0] = r[0] * Math.cos(n) - r[1] * Math.sin(n), i[1] = r[0] * Math.sin(n) + r[1] * Math.cos(n), i[2] = r[2], t[0] = i[0] + s[0], t[1] = i[1] + s[1], t[2] = i[2] + s[2], t;
}
function SE(t, e) {
  const s = t[0], n = t[1], r = t[2], i = e[0], o = e[1], a = e[2], c = Math.sqrt((s * s + n * n + r * r) * (i * i + o * o + a * a)), l = c && bc(t, e) / c;
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
const RE = AE, wE = Xd;
(function() {
  const t = Wd();
  return function(e, s, n, r, i, o) {
    let a, c;
    for (s || (s = 3), n || (n = 0), r ? c = Math.min(r * s + n, e.length) : c = e.length, a = n; a < c; a += s)
      t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], i(t, t, o), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2];
    return e;
  };
})();
const go = [0, 0, 0];
let Ir;
class S extends Tc {
  static get ZERO() {
    return Ir || (Ir = new S(0, 0, 0), Object.freeze(Ir)), Ir;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(e = 0, s = 0, n = 0) {
    super(-0, -0, -0), arguments.length === 1 && Kt(e) ? this.copy(e) : (fe.debug && (J(e), J(s), J(n)), this[0] = e, this[1] = s, this[2] = n);
  }
  set(e, s, n) {
    return this[0] = e, this[1] = s, this[2] = n, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return fe.debug && (J(e.x), J(e.y), J(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = J(e);
  }
  // ACCESSORS
  angle(e) {
    return SE(this, e);
  }
  // MODIFIERS
  cross(e) {
    return Qr(this, this, e), this.check();
  }
  rotateX({ radians: e, origin: s = go }) {
    return bE(this, this, s, e), this.check();
  }
  rotateY({ radians: e, origin: s = go }) {
    return EE(this, this, s, e), this.check();
  }
  rotateZ({ radians: e, origin: s = go }) {
    return CE(this, this, s, e), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return Ec(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return zd(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return Gd(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return gE(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return $d(this, this, e), this.check();
  }
}
let vr;
class Cc extends Tc {
  static get ZERO() {
    return vr || (vr = new Cc(0, 0, 0, 0), Object.freeze(vr)), vr;
  }
  constructor(e = 0, s = 0, n = 0, r = 0) {
    super(-0, -0, -0, -0), Kt(e) && arguments.length === 1 ? this.copy(e) : (fe.debug && (J(e), J(s), J(n), J(r)), this[0] = e, this[1] = s, this[2] = n, this[3] = r);
  }
  set(e, s, n, r) {
    return this[0] = e, this[1] = s, this[2] = n, this[3] = r, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return fe.debug && (J(e.x), J(e.y), J(e.z), J(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = J(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = J(e);
  }
  transform(e) {
    return Ec(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return jd(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return mE(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return $d(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class Kd extends Ac {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (fe.printRowMajor) {
      e += "row-major:";
      for (let s = 0; s < this.RANK; ++s)
        for (let n = 0; n < this.RANK; ++n)
          e += ` ${this[n * this.RANK + s]}`;
    } else {
      e += "column-major:";
      for (let s = 0; s < this.ELEMENTS; ++s)
        e += ` ${this[s]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, s) {
    return s * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, s) {
    return this[s * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, s, n) {
    return this[s * this.RANK + e] = J(n), this;
  }
  getColumn(e, s = new Array(this.RANK).fill(-0)) {
    const n = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      s[r] = this[n + r];
    return s;
  }
  setColumn(e, s) {
    const n = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      this[n + r] = s[r];
    return this;
  }
}
function IE() {
  const t = new tt(9);
  return tt != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function vE(t, e) {
  if (t === e) {
    const s = e[1], n = e[2], r = e[5];
    t[1] = e[3], t[2] = e[6], t[3] = s, t[5] = e[7], t[6] = n, t[7] = r;
  } else
    t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
  return t;
}
function BE(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3], o = e[4], a = e[5], c = e[6], l = e[7], h = e[8], u = h * o - a * l, f = -h * i + a * c, p = l * i - o * c;
  let m = s * u + n * f + r * p;
  return m ? (m = 1 / m, t[0] = u * m, t[1] = (-h * n + r * l) * m, t[2] = (a * n - r * o) * m, t[3] = f * m, t[4] = (h * s - r * c) * m, t[5] = (-a * s + r * i) * m, t[6] = p * m, t[7] = (-l * s + n * c) * m, t[8] = (o * s - n * i) * m, t) : null;
}
function ME(t) {
  const e = t[0], s = t[1], n = t[2], r = t[3], i = t[4], o = t[5], a = t[6], c = t[7], l = t[8];
  return e * (l * i - o * c) + s * (-l * r + o * a) + n * (c * r - i * a);
}
function bh(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], c = e[5], l = e[6], h = e[7], u = e[8], f = s[0], p = s[1], m = s[2], A = s[3], E = s[4], C = s[5], w = s[6], I = s[7], B = s[8];
  return t[0] = f * n + p * o + m * l, t[1] = f * r + p * a + m * h, t[2] = f * i + p * c + m * u, t[3] = A * n + E * o + C * l, t[4] = A * r + E * a + C * h, t[5] = A * i + E * c + C * u, t[6] = w * n + I * o + B * l, t[7] = w * r + I * a + B * h, t[8] = w * i + I * c + B * u, t;
}
function PE(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], c = e[5], l = e[6], h = e[7], u = e[8], f = s[0], p = s[1];
  return t[0] = n, t[1] = r, t[2] = i, t[3] = o, t[4] = a, t[5] = c, t[6] = f * n + p * o + l, t[7] = f * r + p * a + h, t[8] = f * i + p * c + u, t;
}
function OE(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], c = e[5], l = e[6], h = e[7], u = e[8], f = Math.sin(s), p = Math.cos(s);
  return t[0] = p * n + f * o, t[1] = p * r + f * a, t[2] = p * i + f * c, t[3] = p * o - f * n, t[4] = p * a - f * r, t[5] = p * c - f * i, t[6] = l, t[7] = h, t[8] = u, t;
}
function Eh(t, e, s) {
  const n = s[0], r = s[1];
  return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = r * e[3], t[4] = r * e[4], t[5] = r * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function xE(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3], o = s + s, a = n + n, c = r + r, l = s * o, h = n * o, u = n * a, f = r * o, p = r * a, m = r * c, A = i * o, E = i * a, C = i * c;
  return t[0] = 1 - u - m, t[3] = h - C, t[6] = f + E, t[1] = h + C, t[4] = 1 - l - m, t[7] = p - A, t[2] = f - E, t[5] = p + A, t[8] = 1 - l - u, t;
}
var ya;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL1ROW0 = 3] = "COL1ROW0", t[t.COL1ROW1 = 4] = "COL1ROW1", t[t.COL1ROW2 = 5] = "COL1ROW2", t[t.COL2ROW0 = 6] = "COL2ROW0", t[t.COL2ROW1 = 7] = "COL2ROW1", t[t.COL2ROW2 = 8] = "COL2ROW2";
})(ya || (ya = {}));
const NE = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class ae extends Kd {
  static get IDENTITY() {
    return DE();
  }
  static get ZERO() {
    return FE();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return ya;
  }
  constructor(e, ...s) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : s.length > 0 ? this.copy([e, ...s]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(NE);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return xE(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, s, n, r, i, o, a, c, l) {
    return this[0] = e, this[1] = s, this[2] = n, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, s, n, r, i, o, a, c, l) {
    return this[0] = e, this[1] = r, this[2] = a, this[3] = s, this[4] = i, this[5] = c, this[6] = n, this[7] = o, this[8] = l, this.check();
  }
  // Accessors
  determinant() {
    return ME(this);
  }
  // Modifiers
  transpose() {
    return vE(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return BE(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return bh(this, e, this), this.check();
  }
  multiplyRight(e) {
    return bh(this, this, e), this.check();
  }
  rotate(e) {
    return OE(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? Eh(this, this, e) : Eh(this, this, [e, e]), this.check();
  }
  translate(e) {
    return PE(this, this, e), this.check();
  }
  // Transforms
  transform(e, s) {
    let n;
    switch (e.length) {
      case 2:
        n = kd(s || [-0, -0], e, this);
        break;
      case 3:
        n = Gd(s || [-0, -0, -0], e, this);
        break;
      case 4:
        n = jd(s || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vn(n, e.length), n;
  }
  /** @deprecated */
  transformVector(e, s) {
    return this.transform(e, s);
  }
  /** @deprecated */
  transformVector2(e, s) {
    return this.transform(e, s);
  }
  /** @deprecated */
  transformVector3(e, s) {
    return this.transform(e, s);
  }
}
let Br, Mr = null;
function FE() {
  return Br || (Br = new ae([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Br)), Br;
}
function DE() {
  return Mr || (Mr = new ae(), Object.freeze(Mr)), Mr;
}
function UE(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function LE(t, e) {
  if (t === e) {
    const s = e[1], n = e[2], r = e[3], i = e[6], o = e[7], a = e[11];
    t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = s, t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = i, t[11] = e[14], t[12] = r, t[13] = o, t[14] = a;
  } else
    t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
  return t;
}
function ba(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3], o = e[4], a = e[5], c = e[6], l = e[7], h = e[8], u = e[9], f = e[10], p = e[11], m = e[12], A = e[13], E = e[14], C = e[15], w = s * a - n * o, I = s * c - r * o, B = s * l - i * o, x = n * c - r * a, N = n * l - i * a, L = r * l - i * c, k = h * A - u * m, F = h * E - f * m, U = h * C - p * m, H = u * E - f * A, Y = u * C - p * A, te = f * C - p * E;
  let z = w * te - I * Y + B * H + x * U - N * F + L * k;
  return z ? (z = 1 / z, t[0] = (a * te - c * Y + l * H) * z, t[1] = (r * Y - n * te - i * H) * z, t[2] = (A * L - E * N + C * x) * z, t[3] = (f * N - u * L - p * x) * z, t[4] = (c * U - o * te - l * F) * z, t[5] = (s * te - r * U + i * F) * z, t[6] = (E * B - m * L - C * I) * z, t[7] = (h * L - f * B + p * I) * z, t[8] = (o * Y - a * U + l * k) * z, t[9] = (n * U - s * Y - i * k) * z, t[10] = (m * N - A * B + C * w) * z, t[11] = (u * B - h * N - p * w) * z, t[12] = (a * F - o * H - c * k) * z, t[13] = (s * H - n * F + r * k) * z, t[14] = (A * I - m * x - E * w) * z, t[15] = (h * x - u * I + f * w) * z, t) : null;
}
function kE(t) {
  const e = t[0], s = t[1], n = t[2], r = t[3], i = t[4], o = t[5], a = t[6], c = t[7], l = t[8], h = t[9], u = t[10], f = t[11], p = t[12], m = t[13], A = t[14], E = t[15], C = e * o - s * i, w = e * a - n * i, I = s * a - n * o, B = l * m - h * p, x = l * A - u * p, N = h * A - u * m, L = e * N - s * x + n * B, k = i * N - o * x + a * B, F = l * I - h * w + u * C, U = p * I - m * w + A * C;
  return c * L - r * k + E * F - f * U;
}
function _s(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], c = e[5], l = e[6], h = e[7], u = e[8], f = e[9], p = e[10], m = e[11], A = e[12], E = e[13], C = e[14], w = e[15];
  let I = s[0], B = s[1], x = s[2], N = s[3];
  return t[0] = I * n + B * a + x * u + N * A, t[1] = I * r + B * c + x * f + N * E, t[2] = I * i + B * l + x * p + N * C, t[3] = I * o + B * h + x * m + N * w, I = s[4], B = s[5], x = s[6], N = s[7], t[4] = I * n + B * a + x * u + N * A, t[5] = I * r + B * c + x * f + N * E, t[6] = I * i + B * l + x * p + N * C, t[7] = I * o + B * h + x * m + N * w, I = s[8], B = s[9], x = s[10], N = s[11], t[8] = I * n + B * a + x * u + N * A, t[9] = I * r + B * c + x * f + N * E, t[10] = I * i + B * l + x * p + N * C, t[11] = I * o + B * h + x * m + N * w, I = s[12], B = s[13], x = s[14], N = s[15], t[12] = I * n + B * a + x * u + N * A, t[13] = I * r + B * c + x * f + N * E, t[14] = I * i + B * l + x * p + N * C, t[15] = I * o + B * h + x * m + N * w, t;
}
function pi(t, e, s) {
  const n = s[0], r = s[1], i = s[2];
  let o, a, c, l, h, u, f, p, m, A, E, C;
  return e === t ? (t[12] = e[0] * n + e[4] * r + e[8] * i + e[12], t[13] = e[1] * n + e[5] * r + e[9] * i + e[13], t[14] = e[2] * n + e[6] * r + e[10] * i + e[14], t[15] = e[3] * n + e[7] * r + e[11] * i + e[15]) : (o = e[0], a = e[1], c = e[2], l = e[3], h = e[4], u = e[5], f = e[6], p = e[7], m = e[8], A = e[9], E = e[10], C = e[11], t[0] = o, t[1] = a, t[2] = c, t[3] = l, t[4] = h, t[5] = u, t[6] = f, t[7] = p, t[8] = m, t[9] = A, t[10] = E, t[11] = C, t[12] = o * n + h * r + m * i + e[12], t[13] = a * n + u * r + A * i + e[13], t[14] = c * n + f * r + E * i + e[14], t[15] = l * n + p * r + C * i + e[15]), t;
}
function Sc(t, e, s) {
  const n = s[0], r = s[1], i = s[2];
  return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * i, t[9] = e[9] * i, t[10] = e[10] * i, t[11] = e[11] * i, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
}
function VE(t, e, s, n) {
  let r = n[0], i = n[1], o = n[2], a = Math.sqrt(r * r + i * i + o * o), c, l, h, u, f, p, m, A, E, C, w, I, B, x, N, L, k, F, U, H, Y, te, z, me;
  return a < Hn ? null : (a = 1 / a, r *= a, i *= a, o *= a, l = Math.sin(s), c = Math.cos(s), h = 1 - c, u = e[0], f = e[1], p = e[2], m = e[3], A = e[4], E = e[5], C = e[6], w = e[7], I = e[8], B = e[9], x = e[10], N = e[11], L = r * r * h + c, k = i * r * h + o * l, F = o * r * h - i * l, U = r * i * h - o * l, H = i * i * h + c, Y = o * i * h + r * l, te = r * o * h + i * l, z = i * o * h - r * l, me = o * o * h + c, t[0] = u * L + A * k + I * F, t[1] = f * L + E * k + B * F, t[2] = p * L + C * k + x * F, t[3] = m * L + w * k + N * F, t[4] = u * U + A * H + I * Y, t[5] = f * U + E * H + B * Y, t[6] = p * U + C * H + x * Y, t[7] = m * U + w * H + N * Y, t[8] = u * te + A * z + I * me, t[9] = f * te + E * z + B * me, t[10] = p * te + C * z + x * me, t[11] = m * te + w * z + N * me, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
}
function Yd(t, e, s) {
  const n = Math.sin(s), r = Math.cos(s), i = e[4], o = e[5], a = e[6], c = e[7], l = e[8], h = e[9], u = e[10], f = e[11];
  return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = i * r + l * n, t[5] = o * r + h * n, t[6] = a * r + u * n, t[7] = c * r + f * n, t[8] = l * r - i * n, t[9] = h * r - o * n, t[10] = u * r - a * n, t[11] = f * r - c * n, t;
}
function HE(t, e, s) {
  const n = Math.sin(s), r = Math.cos(s), i = e[0], o = e[1], a = e[2], c = e[3], l = e[8], h = e[9], u = e[10], f = e[11];
  return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = i * r - l * n, t[1] = o * r - h * n, t[2] = a * r - u * n, t[3] = c * r - f * n, t[8] = i * n + l * r, t[9] = o * n + h * r, t[10] = a * n + u * r, t[11] = c * n + f * r, t;
}
function Jd(t, e, s) {
  const n = Math.sin(s), r = Math.cos(s), i = e[0], o = e[1], a = e[2], c = e[3], l = e[4], h = e[5], u = e[6], f = e[7];
  return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = i * r + l * n, t[1] = o * r + h * n, t[2] = a * r + u * n, t[3] = c * r + f * n, t[4] = l * r - i * n, t[5] = h * r - o * n, t[6] = u * r - a * n, t[7] = f * r - c * n, t;
}
function zE(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[4], o = e[5], a = e[6], c = e[8], l = e[9], h = e[10];
  return t[0] = Math.sqrt(s * s + n * n + r * r), t[1] = Math.sqrt(i * i + o * o + a * a), t[2] = Math.sqrt(c * c + l * l + h * h), t;
}
function jE(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3], o = s + s, a = n + n, c = r + r, l = s * o, h = n * o, u = n * a, f = r * o, p = r * a, m = r * c, A = i * o, E = i * a, C = i * c;
  return t[0] = 1 - u - m, t[1] = h + C, t[2] = f - E, t[3] = 0, t[4] = h - C, t[5] = 1 - l - m, t[6] = p + A, t[7] = 0, t[8] = f + E, t[9] = p - A, t[10] = 1 - l - u, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function WE(t, e, s, n, r, i, o) {
  const a = 1 / (s - e), c = 1 / (r - n), l = 1 / (i - o);
  return t[0] = i * 2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = i * 2 * c, t[6] = 0, t[7] = 0, t[8] = (s + e) * a, t[9] = (r + n) * c, t[10] = (o + i) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * i * 2 * l, t[15] = 0, t;
}
function XE(t, e, s, n, r) {
  const i = 1 / Math.tan(e / 2);
  if (t[0] = i / s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, r != null && r !== 1 / 0) {
    const o = 1 / (n - r);
    t[10] = (r + n) * o, t[14] = 2 * r * n * o;
  } else
    t[10] = -1, t[14] = -2 * n;
  return t;
}
const GE = XE;
function $E(t, e, s, n, r, i, o) {
  const a = 1 / (e - s), c = 1 / (n - r), l = 1 / (i - o);
  return t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + s) * a, t[13] = (r + n) * c, t[14] = (o + i) * l, t[15] = 1, t;
}
const KE = $E;
function YE(t, e, s, n) {
  let r, i, o, a, c, l, h, u, f, p;
  const m = e[0], A = e[1], E = e[2], C = n[0], w = n[1], I = n[2], B = s[0], x = s[1], N = s[2];
  return Math.abs(m - B) < Hn && Math.abs(A - x) < Hn && Math.abs(E - N) < Hn ? UE(t) : (u = m - B, f = A - x, p = E - N, r = 1 / Math.sqrt(u * u + f * f + p * p), u *= r, f *= r, p *= r, i = w * p - I * f, o = I * u - C * p, a = C * f - w * u, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - p * o, l = p * i - u * a, h = u * o - f * i, r = Math.sqrt(c * c + l * l + h * h), r ? (r = 1 / r, c *= r, l *= r, h *= r) : (c = 0, l = 0, h = 0), t[0] = i, t[1] = c, t[2] = u, t[3] = 0, t[4] = o, t[5] = l, t[6] = f, t[7] = 0, t[8] = a, t[9] = h, t[10] = p, t[11] = 0, t[12] = -(i * m + o * A + a * E), t[13] = -(c * m + l * A + h * E), t[14] = -(u * m + f * A + p * E), t[15] = 1, t);
}
function JE() {
  const t = new tt(4);
  return tt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
}
function qE(t, e, s) {
  return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], t[3] = e[3] + s[3], t;
}
function qd(t, e, s) {
  return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, t;
}
function ZE(t) {
  const e = t[0], s = t[1], n = t[2], r = t[3];
  return Math.sqrt(e * e + s * s + n * n + r * r);
}
function QE(t) {
  const e = t[0], s = t[1], n = t[2], r = t[3];
  return e * e + s * s + n * n + r * r;
}
function e0(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3];
  let o = s * s + n * n + r * r + i * i;
  return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = s * o, t[1] = n * o, t[2] = r * o, t[3] = i * o, t;
}
function t0(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
}
function s0(t, e, s, n) {
  const r = e[0], i = e[1], o = e[2], a = e[3];
  return t[0] = r + n * (s[0] - r), t[1] = i + n * (s[1] - i), t[2] = o + n * (s[2] - o), t[3] = a + n * (s[3] - a), t;
}
function or(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3];
  return t[0] = s[0] * n + s[4] * r + s[8] * i + s[12] * o, t[1] = s[1] * n + s[5] * r + s[9] * i + s[13] * o, t[2] = s[2] * n + s[6] * r + s[10] * i + s[14] * o, t[3] = s[3] * n + s[7] * r + s[11] * i + s[15] * o, t;
}
function n0(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = s[0], a = s[1], c = s[2], l = s[3], h = l * n + a * i - c * r, u = l * r + c * n - o * i, f = l * i + o * r - a * n, p = -o * n - a * r - c * i;
  return t[0] = h * l + p * -o + u * -c - f * -a, t[1] = u * l + p * -a + f * -o - h * -c, t[2] = f * l + p * -c + h * -a - u * -o, t[3] = e[3], t;
}
(function() {
  const t = JE();
  return function(e, s, n, r, i, o) {
    let a, c;
    for (s || (s = 4), n || (n = 0), r ? c = Math.min(r * s + n, e.length) : c = e.length, a = n; a < c; a += s)
      t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], t[3] = e[a + 3], i(t, t, o), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2], e[a + 3] = t[3];
    return e;
  };
})();
var Ea;
(function(t) {
  t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3";
})(Ea || (Ea = {}));
const r0 = 45 * Math.PI / 180, i0 = 1, mo = 0.1, Ao = 500, o0 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class W extends Kd {
  static get IDENTITY() {
    return c0();
  }
  static get ZERO() {
    return a0();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return Ea;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, s, n, r, i, o, a, c, l, h, u, f, p, m, A, E) {
    return this[0] = e, this[1] = s, this[2] = n, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = h, this[10] = u, this[11] = f, this[12] = p, this[13] = m, this[14] = A, this[15] = E, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, s, n, r, i, o, a, c, l, h, u, f, p, m, A, E) {
    return this[0] = e, this[1] = i, this[2] = l, this[3] = p, this[4] = s, this[5] = o, this[6] = h, this[7] = m, this[8] = n, this[9] = a, this[10] = u, this[11] = A, this[12] = r, this[13] = c, this[14] = f, this[15] = E, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(o0);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return jE(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const { left: s, right: n, bottom: r, top: i, near: o = mo, far: a = Ao } = e;
    return a === 1 / 0 ? l0(this, s, n, r, i, o) : WE(this, s, n, r, i, o, a), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const { eye: s, center: n = [0, 0, 0], up: r = [0, 1, 0] } = e;
    return YE(this, s, n, r), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const { left: s, right: n, bottom: r, top: i, near: o = mo, far: a = Ao } = e;
    return KE(this, s, n, r, i, o, a), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const { fovy: s = r0, aspect: n = i0, focalDistance: r = 1, near: i = mo, far: o = Ao } = e;
    Ch(s);
    const a = s / 2, c = r * Math.tan(a), l = c * n;
    return this.ortho({
      left: -l,
      right: l,
      bottom: -c,
      top: c,
      near: i,
      far: o
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const { fovy: s = 45 * Math.PI / 180, aspect: n = 1, near: r = 0.1, far: i = 500 } = e;
    return Ch(s), GE(this, s, n, r, i), this.check();
  }
  // Accessors
  determinant() {
    return kE(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(e = [-0, -0, -0]) {
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(e = [-0, -0, -0]) {
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, s) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], s = s || [-0, -0, -0];
    const n = this.getScale(s), r = 1 / n[0], i = 1 / n[1], o = 1 / n[2];
    return e[0] = this[0] * r, e[1] = this[1] * i, e[2] = this[2] * o, e[3] = 0, e[4] = this[4] * r, e[5] = this[5] * i, e[6] = this[6] * o, e[7] = 0, e[8] = this[8] * r, e[9] = this[9] * i, e[10] = this[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, s) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], s = s || [-0, -0, -0];
    const n = this.getScale(s), r = 1 / n[0], i = 1 / n[1], o = 1 / n[2];
    return e[0] = this[0] * r, e[1] = this[1] * i, e[2] = this[2] * o, e[3] = this[4] * r, e[4] = this[5] * i, e[5] = this[6] * o, e[6] = this[8] * r, e[7] = this[9] * i, e[8] = this[10] * o, e;
  }
  // Modifiers
  transpose() {
    return LE(this, this), this.check();
  }
  invert() {
    return ba(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return _s(this, e, this), this.check();
  }
  multiplyRight(e) {
    return _s(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return Yd(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return HE(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return Jd(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, s) {
    return VE(this, this, e, s), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return Sc(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return pi(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, s) {
    return e.length === 4 ? (s = or(s || [-0, -0, -0, -0], e, this), Vn(s, 4), s) : this.transformAsPoint(e, s);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, s) {
    const { length: n } = e;
    let r;
    switch (n) {
      case 2:
        r = Vd(s || [-0, -0], e, this);
        break;
      case 3:
        r = Ec(s || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vn(r, e.length), r;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, s) {
    let n;
    switch (e.length) {
      case 2:
        n = Hd(s || [-0, -0], e, this);
        break;
      case 3:
        n = zd(s || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Vn(n, e.length), n;
  }
  /** @deprecated */
  transformPoint(e, s) {
    return this.transformAsPoint(e, s);
  }
  /** @deprecated */
  transformVector(e, s) {
    return this.transformAsPoint(e, s);
  }
  /** @deprecated */
  transformDirection(e, s) {
    return this.transformAsVector(e, s);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, s, n) {
    return this.identity().translate([e, s, n]);
  }
}
let Pr, Or;
function a0() {
  return Pr || (Pr = new W([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Pr)), Pr;
}
function c0() {
  return Or || (Or = new W(), Object.freeze(Or)), Or;
}
function Ch(t) {
  if (t > Math.PI * 2)
    throw Error("expected radians");
}
function l0(t, e, s, n, r, i) {
  const o = 2 * i / (s - e), a = 2 * i / (r - n), c = (s + e) / (s - e), l = (r + n) / (r - n), h = -1, u = -1, f = -2 * i;
  return t[0] = o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = c, t[9] = l, t[10] = h, t[11] = u, t[12] = 0, t[13] = 0, t[14] = f, t[15] = 0, t;
}
function Sh() {
  const t = new tt(4);
  return tt != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
}
function h0(t) {
  return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
}
function Zd(t, e, s) {
  s = s * 0.5;
  const n = Math.sin(s);
  return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = Math.cos(s), t;
}
function Rh(t, e, s) {
  const n = e[0], r = e[1], i = e[2], o = e[3], a = s[0], c = s[1], l = s[2], h = s[3];
  return t[0] = n * h + o * a + r * l - i * c, t[1] = r * h + o * c + i * a - n * l, t[2] = i * h + o * l + n * c - r * a, t[3] = o * h - n * a - r * c - i * l, t;
}
function u0(t, e, s) {
  s *= 0.5;
  const n = e[0], r = e[1], i = e[2], o = e[3], a = Math.sin(s), c = Math.cos(s);
  return t[0] = n * c + o * a, t[1] = r * c + i * a, t[2] = i * c - r * a, t[3] = o * c - n * a, t;
}
function f0(t, e, s) {
  s *= 0.5;
  const n = e[0], r = e[1], i = e[2], o = e[3], a = Math.sin(s), c = Math.cos(s);
  return t[0] = n * c - i * a, t[1] = r * c + o * a, t[2] = i * c + n * a, t[3] = o * c - r * a, t;
}
function d0(t, e, s) {
  s *= 0.5;
  const n = e[0], r = e[1], i = e[2], o = e[3], a = Math.sin(s), c = Math.cos(s);
  return t[0] = n * c + r * a, t[1] = r * c - n * a, t[2] = i * c + o * a, t[3] = o * c - i * a, t;
}
function p0(t, e) {
  const s = e[0], n = e[1], r = e[2];
  return t[0] = s, t[1] = n, t[2] = r, t[3] = Math.sqrt(Math.abs(1 - s * s - n * n - r * r)), t;
}
function ei(t, e, s, n) {
  const r = e[0], i = e[1], o = e[2], a = e[3];
  let c = s[0], l = s[1], h = s[2], u = s[3], f, p, m, A, E;
  return f = r * c + i * l + o * h + a * u, f < 0 && (f = -f, c = -c, l = -l, h = -h, u = -u), 1 - f > Hn ? (p = Math.acos(f), E = Math.sin(p), m = Math.sin((1 - n) * p) / E, A = Math.sin(n * p) / E) : (m = 1 - n, A = n), t[0] = m * r + A * c, t[1] = m * i + A * l, t[2] = m * o + A * h, t[3] = m * a + A * u, t;
}
function _0(t, e) {
  const s = e[0], n = e[1], r = e[2], i = e[3], o = s * s + n * n + r * r + i * i, a = o ? 1 / o : 0;
  return t[0] = -s * a, t[1] = -n * a, t[2] = -r * a, t[3] = i * a, t;
}
function g0(t, e) {
  return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
}
function Qd(t, e) {
  const s = e[0] + e[4] + e[8];
  let n;
  if (s > 0)
    n = Math.sqrt(s + 1), t[3] = 0.5 * n, n = 0.5 / n, t[0] = (e[5] - e[7]) * n, t[1] = (e[6] - e[2]) * n, t[2] = (e[1] - e[3]) * n;
  else {
    let r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    const i = (r + 1) % 3, o = (r + 2) % 3;
    n = Math.sqrt(e[r * 3 + r] - e[i * 3 + i] - e[o * 3 + o] + 1), t[r] = 0.5 * n, n = 0.5 / n, t[3] = (e[i * 3 + o] - e[o * 3 + i]) * n, t[i] = (e[i * 3 + r] + e[r * 3 + i]) * n, t[o] = (e[o * 3 + r] + e[r * 3 + o]) * n;
  }
  return t;
}
const m0 = qE, A0 = qd, T0 = t0, y0 = s0, b0 = ZE, E0 = QE, ep = e0, C0 = (function() {
  const t = Wd(), e = yh(1, 0, 0), s = yh(0, 1, 0);
  return function(n, r, i) {
    const o = bc(r, i);
    return o < -0.999999 ? (Qr(t, e, r), wE(t) < 1e-6 && Qr(t, s, r), yE(t, t), Zd(n, t, Math.PI), n) : o > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (Qr(t, r, i), n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = 1 + o, ep(n, n));
  };
})();
(function() {
  const t = Sh(), e = Sh();
  return function(s, n, r, i, o, a) {
    return ei(t, n, o, a), ei(e, r, i, a), ei(s, t, e, 2 * a * (1 - a)), s;
  };
})();
(function() {
  const t = IE();
  return function(e, s, n, r) {
    return t[0] = n[0], t[3] = n[1], t[6] = n[2], t[1] = r[0], t[4] = r[1], t[7] = r[2], t[2] = -s[0], t[5] = -s[1], t[8] = -s[2], ep(e, Qd(e, t));
  };
})();
const S0 = [0, 0, 0, 1];
class $n extends Ac {
  constructor(e = 0, s = 0, n = 0, r = 1) {
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, s, n, r);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, s, n, r) {
    return this[0] = e, this[1] = s, this[2] = n, this[3] = r, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return Qd(this, e), this.check();
  }
  fromAxisRotation(e, s) {
    return Zd(this, e, s), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return h0(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, s) {
    return this.fromAxisRotation(e, s);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = J(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = J(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = J(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = J(e);
  }
  // Calculates the length of a quat
  len() {
    return b0(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return E0(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return T0(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, s) {
    return C0(this, e, s), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return m0(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return p0(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return g0(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return _0(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, s, n) {
    return n === void 0 ? this.lerp(this, e, s) : (y0(this, e, s, n), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return Rh(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return Rh(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), s = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * s, this[1] = this[1] * s, this[2] = this[2] * s, this[3] = this[3] * s, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return u0(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return f0(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return d0(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return A0(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, s, n) {
    let r, i, o;
    switch (arguments.length) {
      case 1:
        ({
          start: r = S0,
          target: i,
          ratio: o
        } = e);
        break;
      case 2:
        r = this, i = e, o = s;
        break;
      default:
        r = e, i = s, o = n;
    }
    return ei(this, r, i, o), this.check();
  }
  transformVector4(e, s = new Cc()) {
    return n0(s, e, this), Vn(s, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, s) {
    return this.setAxisAngle(e, s);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const R0 = 0.1, w0 = 1e-12, tp = 1e-15, I0 = 1e-20, wh = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`, v0 = {
  lightSources: {}
};
function To(t = {}) {
  const { color: e = [0, 0, 0], intensity: s = 1 } = t;
  return e.map((n) => n * s / 255);
}
function B0({ ambientLight: t, pointLights: e = [], directionalLights: s = [] }) {
  const n = {};
  return t ? n["lighting_uAmbientLight.color"] = To(t) : n["lighting_uAmbientLight.color"] = [0, 0, 0], e.forEach((r, i) => {
    n[`lighting_uPointLight[${i}].color`] = To(r), n[`lighting_uPointLight[${i}].position`] = r.position, n[`lighting_uPointLight[${i}].attenuation`] = r.attenuation || [
      1,
      0,
      0
    ];
  }), n.lighting_uPointLightCount = e.length, s.forEach((r, i) => {
    n[`lighting_uDirectionalLight[${i}].color`] = To(r), n[`lighting_uDirectionalLight[${i}].direction`] = r.direction;
  }), n.lighting_uDirectionalLightCount = s.length, n;
}
function sp(t = v0) {
  if ("lightSources" in t) {
    const { ambientLight: e, pointLights: s, directionalLights: n } = t.lightSources || {};
    return e || s && s.length > 0 || n && n.length > 0 ? Object.assign({}, B0({ ambientLight: e, pointLights: s, directionalLights: n }), {
      lighting_uEnabled: !0
    }) : { lighting_uEnabled: !1 };
  }
  if ("lights" in t) {
    const e = { pointLights: [], directionalLights: [] };
    for (const s of t.lights || [])
      switch (s.type) {
        case "ambient":
          e.ambientLight = s;
          break;
        case "directional":
          e.directionalLights?.push(s);
          break;
        case "point":
          e.pointLights?.push(s);
          break;
      }
    return sp({ lightSources: e });
  }
  return {};
}
const Rc = {
  name: "lights",
  vs: wh,
  fs: wh,
  getUniforms: sp,
  defines: {
    MAX_LIGHTS: 3
  }
}, np = `uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`, M0 = {};
function P0(t) {
  const { ambient: e = 0.35, diffuse: s = 0.6, shininess: n = 32, specularColor: r = [30, 30, 30] } = t;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: s,
    lighting_uShininess: n,
    lighting_uSpecularColor: r.map((i) => i / 255)
  };
}
function rp(t = M0) {
  if (!("material" in t))
    return {};
  const { material: e } = t;
  return e ? P0(e) : { lighting_uEnabled: !1 };
}
const O0 = {
  name: "gouraud-lighting",
  dependencies: [Rc],
  vs: np,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: rp
}, x0 = {
  name: "phong-lighting",
  dependencies: [Rc],
  fs: np,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: rp
}, N0 = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`, F0 = `precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, wc = {
  name: "pbr",
  vs: N0,
  fs: F0,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [Rc]
}, ip = "#define SMOOTH_EDGE_RADIUS 0.5", D0 = `
${ip}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, U0 = `
${ip}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, L0 = { name: "geometry", vs: D0, fs: U0 }, X = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(X, "IDENTITY", {
  get: () => ($.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const mt = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, Ca = {
  common: 0,
  meters: 1,
  pixels: 2
}, Sa = {
  click: { handler: "onClick" },
  panstart: { handler: "onDragStart" },
  panmove: { handler: "onDrag" },
  panend: { handler: "onDragEnd" }
}, k0 = Object.keys(X).map((t) => `const int COORDINATE_SYSTEM_${t} = ${X[t]};`).join(""), V0 = Object.keys(mt).map((t) => `const int PROJECTION_MODE_${t} = ${mt[t]};`).join(""), H0 = Object.keys(Ca).map((t) => `const int UNIT_${t.toUpperCase()} = ${Ca[t]};`).join(""), z0 = `${k0}
${V0}
${H0}
uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project_uPseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project_uCommonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project_uCommonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project_uCommonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project_uWrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project_uModelMatrix * position;
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project_uCoordinateOrigin;
}
}
if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
(project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project_uCoordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
return offset * project_uFocalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project_uScale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project_uScale;
}
`;
function j0(t, e) {
  if (t === e)
    return !0;
  if (Array.isArray(t)) {
    const s = t.length;
    if (!e || e.length !== s)
      return !1;
    for (let n = 0; n < s; n++)
      if (t[n] !== e[n])
        return !1;
    return !0;
  }
  return !1;
}
function ar(t) {
  let e = {}, s;
  return (n) => {
    for (const r in n)
      if (!j0(n[r], e[r])) {
        s = t(n), e = n;
        break;
      }
    return s;
  };
}
const Ih = [0, 0, 0, 0], W0 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], op = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], X0 = [0, 0, 0], ap = [0, 0, 0], G0 = ar(Y0);
function cp(t, e, s = ap) {
  s.length < 3 && (s = [s[0], s[1], 0]);
  let n = s, r, i = !0;
  switch (e === X.LNGLAT_OFFSETS || e === X.METER_OFFSETS ? r = s : r = t.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(t.longitude), Math.fround(t.latitude), 0]
  ) : null, t.projectionMode) {
    case mt.WEB_MERCATOR:
      (e === X.LNGLAT || e === X.CARTESIAN) && (r = [0, 0, 0], i = !1);
      break;
    case mt.WEB_MERCATOR_AUTO_OFFSET:
      e === X.LNGLAT ? n = r : e === X.CARTESIAN && (n = [
        Math.fround(t.center[0]),
        Math.fround(t.center[1]),
        0
      ], r = t.unprojectPosition(n), n[0] -= s[0], n[1] -= s[1], n[2] -= s[2]);
      break;
    case mt.IDENTITY:
      n = t.position.map(Math.fround), n[2] = n[2] || 0;
      break;
    case mt.GLOBE:
      i = !1, r = null;
      break;
    default:
      i = !1;
  }
  return { geospatialOrigin: r, shaderCoordinateOrigin: n, offsetMode: i };
}
function $0(t, e, s) {
  const { viewMatrixUncentered: n, projectionMatrix: r } = t;
  let { viewMatrix: i, viewProjectionMatrix: o } = t, a = Ih, c = Ih, l = t.cameraPosition;
  const { geospatialOrigin: h, shaderCoordinateOrigin: u, offsetMode: f } = cp(t, e, s);
  return f && (c = t.projectPosition(h || u), l = [
    l[0] - c[0],
    l[1] - c[1],
    l[2] - c[2]
  ], c[3] = 1, a = or([], c, o), i = n || i, o = _s([], r, i), o = _s([], o, W0)), {
    viewMatrix: i,
    viewProjectionMatrix: o,
    projectionCenter: a,
    originCommon: c,
    cameraPosCommon: l,
    shaderCoordinateOrigin: u,
    geospatialOrigin: h
  };
}
function K0({
  viewport: t,
  devicePixelRatio: e = 1,
  modelMatrix: s = null,
  // Match Layer.defaultProps
  coordinateSystem: n = X.DEFAULT,
  coordinateOrigin: r = ap,
  autoWrapLongitude: i = !1
}) {
  n === X.DEFAULT && (n = t.isGeospatial ? X.LNGLAT : X.CARTESIAN);
  const o = G0({
    viewport: t,
    devicePixelRatio: e,
    coordinateSystem: n,
    coordinateOrigin: r
  });
  return o.project_uWrapLongitude = i, o.project_uModelMatrix = s || op, o;
}
function Y0({ viewport: t, devicePixelRatio: e, coordinateSystem: s, coordinateOrigin: n }) {
  const { projectionCenter: r, viewProjectionMatrix: i, originCommon: o, cameraPosCommon: a, shaderCoordinateOrigin: c, geospatialOrigin: l } = $0(t, s, n), h = t.getDistanceScales(), u = [
    t.width * e,
    t.height * e
  ], f = or([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, p = {
    // Projection mode values
    project_uCoordinateSystem: s,
    project_uProjectionMode: t.projectionMode,
    project_uCoordinateOrigin: c,
    project_uCommonOrigin: o.slice(0, 3),
    project_uCenter: r,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    project_uPseudoMeters: !!t._pseudoMeters,
    // Screen size
    project_uViewportSize: u,
    project_uDevicePixelRatio: e,
    project_uFocalDistance: f,
    project_uCommonUnitsPerMeter: h.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: h.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: X0,
    project_uScale: t.scale,
    // This is the mercator scale (2 ** zoom)
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: i,
    project_uModelMatrix: op,
    // This is for lighting calculations
    project_uCameraPosition: a
  };
  if (l) {
    const m = t.getDistanceScales(l);
    switch (s) {
      case X.METER_OFFSETS:
        p.project_uCommonUnitsPerWorldUnit = m.unitsPerMeter, p.project_uCommonUnitsPerWorldUnit2 = m.unitsPerMeter2;
        break;
      case X.LNGLAT:
      case X.LNGLAT_OFFSETS:
        t._pseudoMeters || (p.project_uCommonUnitsPerMeter = m.unitsPerMeter), p.project_uCommonUnitsPerWorldUnit = m.unitsPerDegree, p.project_uCommonUnitsPerWorldUnit2 = m.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case X.CARTESIAN:
        p.project_uCommonUnitsPerWorldUnit = [1, 1, m.unitsPerMeter[2]], p.project_uCommonUnitsPerWorldUnit2 = [
          0,
          0,
          m.unitsPerMeter2[2]
        ];
        break;
    }
  }
  return p;
}
const J0 = {};
function q0(t = J0) {
  return "viewport" in t ? K0(t) : {};
}
const Ic = {
  name: "project",
  dependencies: [Xb, L0],
  vs: z0,
  getUniforms: q0
}, Z0 = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, vc = {
  name: "project32",
  dependencies: [Ic],
  vs: Z0
};
function Q0() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function $s(t, e) {
  const s = or([], e, t);
  return qd(s, s, 1 / s[3]), s;
}
function vh(t, e) {
  const s = t % e;
  return s < 0 ? e + s : s;
}
function Ra(t, e, s) {
  return t < e ? e : t > s ? s : t;
}
function eC(t) {
  return Math.log(t) * Math.LOG2E;
}
const Bc = Math.log2 || eC;
function Mt(t, e) {
  if (!t)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const Ye = Math.PI, lp = Ye / 4, je = Ye / 180, wa = 180 / Ye, tn = 512, _i = 4003e4, xr = 85.051129, tC = 1.5;
function sC(t) {
  return Bc(t);
}
function Kn(t) {
  const [e, s] = t;
  Mt(Number.isFinite(e)), Mt(Number.isFinite(s) && s >= -90 && s <= 90, "invalid latitude");
  const n = e * je, r = s * je, i = tn * (n + Ye) / (2 * Ye), o = tn * (Ye + Math.log(Math.tan(lp + r * 0.5))) / (2 * Ye);
  return [i, o];
}
function sn(t) {
  const [e, s] = t, n = e / tn * (2 * Ye) - Ye, r = 2 * (Math.atan(Math.exp(s / tn * (2 * Ye) - Ye)) - lp);
  return [n * wa, r * wa];
}
function nC(t) {
  const { latitude: e } = t;
  Mt(Number.isFinite(e));
  const s = Math.cos(e * je);
  return sC(_i * s) - 9;
}
function ti(t) {
  const e = Math.cos(t * je);
  return tn / _i / e;
}
function Ia(t) {
  const { latitude: e, longitude: s, highPrecision: n = !1 } = t;
  Mt(Number.isFinite(e) && Number.isFinite(s));
  const r = tn, i = Math.cos(e * je), o = r / 360, a = o / i, c = r / _i / i, l = {
    unitsPerMeter: [c, c, c],
    metersPerUnit: [1 / c, 1 / c, 1 / c],
    unitsPerDegree: [o, a, c],
    degreesPerUnit: [1 / o, 1 / a, 1 / c]
  };
  if (n) {
    const h = je * Math.tan(e * je) / i, u = o * h / 2, f = r / _i * h, p = f / a * c;
    l.unitsPerDegree2 = [0, u, f], l.unitsPerMeter2 = [p, 0, p];
  }
  return l;
}
function hp(t, e) {
  const [s, n, r] = t, [i, o, a] = e, { unitsPerMeter: c, unitsPerMeter2: l } = Ia({
    longitude: s,
    latitude: n,
    highPrecision: !0
  }), h = Kn(t);
  h[0] += i * (c[0] + l[0] * o), h[1] += o * (c[1] + l[1] * o);
  const u = sn(h), f = (r || 0) + (a || 0);
  return Number.isFinite(r) || Number.isFinite(a) ? [u[0], u[1], f] : u;
}
function rC(t) {
  const {
    // Viewport props
    height: e,
    pitch: s,
    bearing: n,
    altitude: r,
    // Pre-calculated parameters
    scale: i,
    center: o
  } = t, a = Q0();
  pi(a, a, [0, 0, -r]), Yd(a, a, -s * je), Jd(a, a, n * je);
  const c = i / e;
  return Sc(a, a, [c, c, c]), o && pi(a, a, TE([], o)), a;
}
function iC(t) {
  const { width: e, height: s, altitude: n, pitch: r = 0, offset: i, center: o, scale: a, nearZMultiplier: c = 1, farZMultiplier: l = 1 } = t;
  let { fovy: h = gi(tC) } = t;
  n !== void 0 && (h = gi(n));
  const u = h * je, f = r * je, p = up(h);
  let m = p;
  o && (m += o[2] * a / Math.cos(f) / s);
  const A = u * (0.5 + (i ? i[1] : 0) / s), E = Math.sin(A) * m / Math.sin(Ra(Math.PI / 2 - f - A, 0.01, Math.PI - 0.01)), C = Math.sin(f) * E + m, w = m * 10, I = Math.min(C * l, w);
  return {
    fov: u,
    aspect: e / s,
    focalDistance: p,
    near: c,
    far: I
  };
}
function gi(t) {
  return 2 * Math.atan(0.5 / t) * wa;
}
function up(t) {
  return 0.5 / Math.tan(0.5 * t * je);
}
function fp(t, e) {
  const [s, n, r = 0] = t;
  return Mt(Number.isFinite(s) && Number.isFinite(n) && Number.isFinite(r)), $s(e, [s, n, r, 1]);
}
function Mc(t, e, s = 0) {
  const [n, r, i] = t;
  if (Mt(Number.isFinite(n) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(i))
    return $s(e, [n, r, i, 1]);
  const o = $s(e, [n, r, 0, 1]), a = $s(e, [n, r, 1, 1]), c = o[2], l = a[2], h = c === l ? 0 : ((s || 0) - c) / (l - c);
  return Ld([], o, a, h);
}
function oC(t) {
  const {
    width: e,
    height: s,
    bounds: n,
    minExtent: r = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: i = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: o = [0, 0]
  } = t, [[a, c], [l, h]] = n, u = aC(t.padding), f = Kn([a, Ra(h, -xr, xr)]), p = Kn([l, Ra(c, -xr, xr)]), m = [
    Math.max(Math.abs(p[0] - f[0]), r),
    Math.max(Math.abs(p[1] - f[1]), r)
  ], A = [
    e - u.left - u.right - Math.abs(o[0]) * 2,
    s - u.top - u.bottom - Math.abs(o[1]) * 2
  ];
  Mt(A[0] > 0 && A[1] > 0);
  const E = A[0] / m[0], C = A[1] / m[1], w = (u.right - u.left) / 2 / E, I = (u.top - u.bottom) / 2 / C, B = [(p[0] + f[0]) / 2 + w, (p[1] + f[1]) / 2 + I], x = sn(B), N = Math.min(i, Bc(Math.abs(Math.min(E, C))));
  return Mt(Number.isFinite(N)), {
    longitude: x[0],
    latitude: x[1],
    zoom: N
  };
}
function aC(t = 0) {
  return typeof t == "number" ? {
    top: t,
    bottom: t,
    left: t,
    right: t
  } : (Mt(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t);
}
const Bh = Math.PI / 180;
function cC(t, e = 0) {
  const { width: s, height: n, unproject: r } = t, i = { targetZ: e }, o = r([0, n], i), a = r([s, n], i);
  let c, l;
  const h = t.fovy ? 0.5 * t.fovy * Bh : Math.atan(0.5 / t.altitude), u = (90 - t.pitch) * Bh;
  return h > u - 0.01 ? (c = Mh(t, 0, e), l = Mh(t, s, e)) : (c = r([0, 0], i), l = r([s, 0], i)), [o, a, l, c];
}
function Mh(t, e, s) {
  const { pixelUnprojectionMatrix: n } = t, r = $s(n, [e, 0, 1, 1]), i = $s(n, [e, t.height, 1, 1]), a = (s * t.distanceScales.unitsPerMeter[2] - r[2]) / (i[2] - r[2]), c = Ld([], r, i, a), l = sn(c);
  return l.push(s), l;
}
const Ph = 512;
function lC(t) {
  const { width: e, height: s, pitch: n = 0 } = t;
  let { longitude: r, latitude: i, zoom: o, bearing: a = 0 } = t;
  (r < -180 || r > 180) && (r = vh(r + 180, 360) - 180), (a < -180 || a > 180) && (a = vh(a + 180, 360) - 180);
  const c = Bc(s / Ph);
  if (o <= c)
    o = c, i = 0;
  else {
    const l = s / 2 / Math.pow(2, o), h = sn([0, l])[1];
    if (i < h)
      i = h;
    else {
      const u = sn([0, Ph - l])[1];
      i > u && (i = u);
    }
  }
  return { width: e, height: s, longitude: r, latitude: i, zoom: o, pitch: n, bearing: a };
}
const hC = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, uC = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, fC = ar(mC), dC = ar(AC), pC = [0, 0, 0, 1], _C = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function gC(t, e) {
  const [s, n, r] = t, i = Mc([s, n, r], e);
  return Number.isFinite(r) ? i : [i[0], i[1], 0];
}
function mC({ viewport: t, center: e }) {
  return new W(t.viewProjectionMatrix).invert().transform(e);
}
function AC({ viewport: t, shadowMatrices: e }) {
  const s = [], n = t.pixelUnprojectionMatrix, r = t.isGeospatial ? void 0 : 1, i = [
    [0, 0, r],
    // top left ground
    [t.width, 0, r],
    // top right ground
    [0, t.height, r],
    // bottom left ground
    [t.width, t.height, r],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [t.width, 0, -1],
    // top right near
    [0, t.height, -1],
    // bottom left near
    [t.width, t.height, -1]
    // bottom right near
  ].map((o) => (
    // @ts-expect-error z may be undefined
    gC(o, n)
  ));
  for (const o of e) {
    const a = o.clone().translate(new S(t.center).negate()), c = i.map((h) => a.transform(h)), l = new W().ortho({
      left: Math.min(...c.map((h) => h[0])),
      right: Math.max(...c.map((h) => h[0])),
      bottom: Math.min(...c.map((h) => h[1])),
      top: Math.max(...c.map((h) => h[1])),
      near: Math.min(...c.map((h) => -h[2])),
      far: Math.max(...c.map((h) => -h[2]))
    });
    s.push(l.multiplyRight(o));
  }
  return s;
}
function TC(t, e) {
  const { shadowEnabled: s = !0 } = t;
  if (!s || !t.shadowMatrices || !t.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1,
      shadow_uShadowMap0: t.dummyShadowMap,
      shadow_uShadowMap1: t.dummyShadowMap
    };
  const n = {
    shadow_uDrawShadowMap: !!t.drawToShadowMap,
    shadow_uUseShadowMap: t.shadowMaps ? t.shadowMaps.length > 0 : !1,
    shadow_uColor: t.shadowColor || pC,
    shadow_uLightId: t.shadowLightId || 0,
    shadow_uLightCount: t.shadowMatrices.length
  }, r = fC({
    viewport: t.viewport,
    center: e.project_uCenter
  }), i = [], o = dC({
    shadowMatrices: t.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let a = 0; a < t.shadowMatrices.length; a++) {
    const c = o[a], l = c.clone().translate(new S(t.viewport.center).negate());
    e.project_uCoordinateSystem === X.LNGLAT && e.project_uProjectionMode === mt.WEB_MERCATOR ? (o[a] = l, i[a] = r) : (o[a] = c.clone().multiplyRight(_C), i[a] = l.transform(r));
  }
  for (let a = 0; a < o.length; a++)
    n[`shadow_uViewProjectionMatrices[${a}]`] = o[a], n[`shadow_uProjectCenters[${a}]`] = i[a];
  for (let a = 0; a < 2; a++)
    n[`shadow_uShadowMap${a}`] = t.shadowMaps && t.shadowMaps[a] || t.dummyShadowMap;
  return n;
}
const Oh = {
  name: "shadow",
  dependencies: [Ic],
  vs: hC,
  fs: uC,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  // @ts-expect-error stricter luma gl types
  getUniforms: (t = {}, e = {}) => "viewport" in t && (t.drawToShadowMap || t.shadowMaps && t.shadowMaps.length > 0) ? TC(t, e) : {}
}, Pc = {
  ...Ah,
  defaultUniforms: { ...Ah.defaultUniforms, useFloatColors: !1 },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, yC = [Ic], bC = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function EC() {
  const t = us.getDefaultShaderAssembler();
  for (const e of yC)
    t.addDefaultModule(e);
  for (const e of bC)
    t.addShaderHook(e);
  return t;
}
const CC = [255, 255, 255], SC = 1;
let RC = 0;
class wC {
  constructor(e = {}) {
    this.type = "ambient";
    const { color: s = CC } = e, { intensity: n = SC } = e;
    this.id = e.id || `ambient-${RC++}`, this.color = s, this.intensity = n;
  }
}
const IC = [255, 255, 255], vC = 1, BC = [0, 0, -1];
let MC = 0;
class xh {
  constructor(e = {}) {
    this.type = "directional";
    const { color: s = IC } = e, { intensity: n = vC } = e, { direction: r = BC } = e, { _shadow: i = !1 } = e;
    this.id = e.id || `directional-${MC++}`, this.color = s, this.intensity = n, this.type = "directional", this.direction = new S(r).normalize().toArray(), this.shadow = i;
  }
  getProjectedLight(e) {
    return this;
  }
}
class PC {
  /** Create a new Pass instance */
  constructor(e, s = { id: "pass" }) {
    const { id: n } = s;
    this.id = n, this.device = e, this.props = { ...s };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class Oc extends PC {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [s, n] = this.device.canvasContext.getDrawingBufferSize(), r = e.clearCanvas ?? !0, i = e.clearColor ?? (r ? [0, 0, 0, 0] : !1), o = r ? 1 : !1, a = r ? 0 : !1, c = e.colorMask ?? 15, l = { viewport: [0, 0, s, n] };
    e.colorMask && (l.colorMask = c), e.scissorRect && (l.scissorRect = e.scissorRect);
    const h = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: l,
      clearColor: i,
      clearDepth: o,
      clearStencil: a
    });
    try {
      return this._drawLayers(h, e);
    } finally {
      h.end();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, s) {
    const { target: n, moduleParameters: r, viewports: i, views: o, onViewportActive: a, clearStack: c = !0 } = s;
    s.pass = s.pass || "unknown", c && (this._lastRenderIndex = -1);
    const l = [];
    for (const h of i) {
      const u = o && o[h.id];
      a?.(h);
      const f = this._getDrawLayerParams(h, s), p = h.subViewports || [h];
      for (const m of p) {
        const A = this._drawLayersInViewport(e, {
          target: n,
          moduleParameters: r,
          viewport: m,
          view: u,
          pass: s.pass,
          layers: s.layers
        }, f);
        l.push(A);
      }
    }
    return l;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, { layers: s, pass: n, isPicking: r = !1, layerFilter: i, cullRect: o, effects: a, moduleParameters: c }, l = !1) {
    const h = [], u = dp(this._lastRenderIndex + 1), f = {
      layer: s[0],
      viewport: e,
      isPicking: r,
      renderPass: n,
      cullRect: o
    }, p = {};
    for (let m = 0; m < s.length; m++) {
      const A = s[m], E = this._shouldDrawLayer(A, f, i, p), C = {
        shouldDrawLayer: E
      };
      E && !l && (C.layerRenderIndex = u(A, E), C.moduleParameters = this._getModuleParameters(A, a, n, c), C.layerParameters = {
        ...A.context.deck?.props.parameters,
        ...this.getLayerParameters(A, m, e)
      }), h[m] = C;
    }
    return h;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(e, { layers: s, moduleParameters: n, pass: r, target: i, viewport: o, view: a }, c) {
    const l = OC(this.device, {
      moduleParameters: n,
      target: i,
      viewport: o
    });
    if (a && a.props.clear) {
      const u = a.props.clear === !0 ? { color: !0, depth: !0 } : a.props.clear;
      this.device.withParametersWebGL({
        scissorTest: !0,
        scissor: l
      }, () => this.device.clearWebGL(u));
    }
    const h = {
      totalCount: s.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({ viewport: l });
    for (let u = 0; u < s.length; u++) {
      const f = s[u], { shouldDrawLayer: p, layerRenderIndex: m, moduleParameters: A, layerParameters: E } = c[u];
      if (p && f.props.pickable && h.pickableCount++, f.isComposite)
        h.compositeCount++;
      else if (p) {
        h.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, m), A.viewport = o, f.context.renderPass = e;
        try {
          f._drawLayer({
            renderPass: e,
            moduleParameters: A,
            uniforms: { layerIndex: m },
            parameters: E
          });
        } catch (C) {
          f.raiseError(C, `drawing ${f} to ${r}`);
        }
      }
    }
    return h;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, s) {
    return null;
  }
  getLayerParameters(e, s, n) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, s, n, r) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    s.layer = e;
    let o = e.parent;
    for (; o; ) {
      if (!o.props.visible || !o.filterSubLayer(s))
        return !1;
      s.layer = o, o = o.parent;
    }
    if (n) {
      const a = s.layer.id;
      if (a in r || (r[a] = n(s)), !r[a])
        return !1;
    }
    return e.activateViewport(s.viewport), !0;
  }
  _getModuleParameters(e, s, n, r) {
    const i = this.device.canvasContext.cssToDeviceRatio(), o = Object.assign(Object.create(e.internalState?.propsInTransition || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      picking: {
        isActive: 0
      },
      devicePixelRatio: i
    });
    if (s)
      for (const a of s)
        Object.assign(o, a.getModuleParameters?.(e));
    return Object.assign(o, this.getModuleParameters(e, s), r);
  }
}
function dp(t = 0, e = {}) {
  const s = {}, n = (r, i) => {
    const o = r.props._offset, a = r.id, c = r.parent && r.parent.id;
    let l;
    if (c && !(c in e) && n(r.parent, !1), c in s) {
      const h = s[c] = s[c] || dp(e[c], e);
      l = h(r, i), s[a] = h;
    } else Number.isFinite(o) ? (l = o + (e[c] || 0), s[a] = null) : l = t;
    return i && l >= t && (t = l + 1), e[a] = l, l;
  };
  return n;
}
function OC(t, { moduleParameters: e, target: s, viewport: n }) {
  const r = e && e.devicePixelRatio || // @ts-expect-error TODO - assuming WebGL context
  t.canvasContext.cssToDeviceRatio(), [, i] = t.canvasContext.getDrawingBufferSize(), o = s ? s.height : i, a = n;
  return [
    a.x * r,
    o - (a.y + a.height) * r,
    a.width * r,
    a.height * r
  ];
}
class xC extends Oc {
  constructor(e, s) {
    super(e, s), this.shadowMap = e.createTexture({
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    }), this.depthBuffer = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1,
      // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters
      dataFormat: 6402,
      // gl.DEPTH_COMPONENT
      type: 5125
      // gl.UNSIGNED_INT
    }), this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [this.shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: this.depthBuffer
    });
  }
  render(e) {
    const s = this.fbo, n = this.device.canvasContext.cssToDeviceRatio(), r = e.viewports[0], i = r.width * n, o = r.height * n, a = [1, 1, 1, 1];
    (i !== s.width || o !== s.height) && s.resize({ width: i, height: o }), super.render({ ...e, clearColor: a, target: s, pass: "shadow" });
  }
  getLayerParameters(e, s, n) {
    return { ...e.props.parameters, blend: !1, depthRange: [0, 1], depthTest: !0 };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null), this.shadowMap && (this.shadowMap.destroy(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.destroy(), this.depthBuffer = null);
  }
}
const NC = { color: [255, 255, 255], intensity: 1 }, Nh = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
], FC = [0, 0, 0, 200 / 255];
class pp {
  constructor(e = {}) {
    this.id = "lighting-effect", this.shadowColor = FC, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const { device: s, deck: n } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(s), n._addDefaultShaderModule(Oh), this.dummyShadowMap = s.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const s in e) {
      const n = e[s];
      switch (n.type) {
        case "ambient":
          this.ambientLight = n;
          break;
        case "directional":
          this.directionalLights.push(n);
          break;
        case "point":
          this.pointLights.push(n);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((s) => s.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender({ layers: e, layerFilter: s, viewports: n, onViewportActive: r, views: i }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let o = 0; o < this.shadowPasses.length; o++)
        this.shadowPasses[o].render({
          layers: e,
          layerFilter: s,
          viewports: n,
          onViewportActive: r,
          views: i,
          moduleParameters: {
            shadowLightId: o,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const s = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return s.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((n) => n.getProjectedLight({ layer: e })),
      pointLights: this.pointLights.map((n) => n.getProjectedLight({ layer: e }))
    }, s;
  }
  cleanup(e) {
    for (const s of this.shadowPasses)
      s.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(Oh));
  }
  _calculateMatrices() {
    const e = [];
    for (const s of this.directionalLights) {
      const n = new W().lookAt({
        eye: new S(s.direction).negate()
      });
      e.push(n);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let s = 0; s < this.directionalLights.length; s++) {
      const n = new xC(e);
      this.shadowPasses[s] = n, this.shadowMaps[s] = n.shadowMap;
    }
  }
  _applyDefaultLights() {
    const { ambientLight: e, pointLights: s, directionalLights: n } = this;
    !e && s.length === 0 && n.length === 0 && (this.ambientLight = new wC(NC), this.directionalLights.push(new xh(Nh[0]), new xh(Nh[1])));
  }
}
class DC {
  constructor(e = {}) {
    this._pool = [], this.opts = { overAlloc: 2, poolSize: 100 }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, s, { size: n = 1, type: r, padding: i = 0, copy: o = !1, initialize: a = !1, maxCount: c }) {
    const l = r || e && e.constructor || Float32Array, h = s * n + i;
    if (ArrayBuffer.isView(e)) {
      if (h <= e.length)
        return e;
      if (h * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new l(e.buffer, 0, h);
    }
    let u = 1 / 0;
    c && (u = c * n + i);
    const f = this._allocate(l, h, a, u);
    return e && o ? f.set(e) : a || f.fill(0, 0, 4), this._release(e), f;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, s, n, r) {
    let i = Math.max(Math.ceil(s * this.opts.overAlloc), 1);
    i > r && (i = r);
    const o = this._pool, a = e.BYTES_PER_ELEMENT * i, c = o.findIndex((l) => l.byteLength >= a);
    if (c >= 0) {
      const l = new e(o.splice(c, 1)[0], 0, i);
      return n && l.fill(0), l;
    }
    return new e(i);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const s = this._pool, { buffer: n } = e, { byteLength: r } = n, i = s.findIndex((o) => o.byteLength >= r);
    i < 0 ? s.push(n) : (i > 0 || s.length < this.opts.poolSize) && s.splice(i, 0, n), s.length > this.opts.poolSize && s.shift();
  }
}
const Yn = new DC();
function Nn() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function UC(t) {
  return [t[12], t[13], t[14]];
}
function LC(t) {
  return {
    left: Bs(t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
    right: Bs(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
    bottom: Bs(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
    top: Bs(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
    near: Bs(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
    far: Bs(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
  };
}
const Fh = new S();
function Bs(t, e, s, n) {
  Fh.set(t, e, s);
  const r = Fh.len();
  return { distance: n / r, normal: new S(-t / r, -e / r, -s / r) };
}
function kC(t) {
  return t - Math.fround(t);
}
let En;
function yo(t, e) {
  const { size: s = 1, startIndex: n = 0 } = e, r = e.endIndex !== void 0 ? e.endIndex : t.length, i = (r - n) / s;
  En = Yn.allocate(En, i, {
    type: Float32Array,
    size: s * 2
  });
  let o = n, a = 0;
  for (; o < r; ) {
    for (let c = 0; c < s; c++) {
      const l = t[o++];
      En[a + c] = l, En[a + c + s] = kC(l);
    }
    a += s * 2;
  }
  return En.subarray(0, i * s * 2);
}
function VC(t) {
  let e = null, s = !1;
  for (const n of t)
    n && (e ? (s || (e = [
      [e[0][0], e[0][1]],
      [e[1][0], e[1][1]]
    ], s = !0), e[0][0] = Math.min(e[0][0], n[0][0]), e[0][1] = Math.min(e[0][1], n[0][1]), e[1][0] = Math.max(e[1][0], n[1][0]), e[1][1] = Math.max(e[1][1], n[1][1])) : e = n);
  return e;
}
const HC = Math.PI / 180, zC = Nn(), Dh = [0, 0, 0], jC = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function WC({ width: t, height: e, orthographic: s, fovyRadians: n, focalDistance: r, padding: i, near: o, far: a }) {
  const c = t / e, l = s ? new W().orthographic({ fovy: n, aspect: c, focalDistance: r, near: o, far: a }) : new W().perspective({ fovy: n, aspect: c, near: o, far: a });
  if (i) {
    const { left: h = 0, right: u = 0, top: f = 0, bottom: p = 0 } = i, m = wt((h + t - u) / 2, 0, t) - t / 2, A = wt((f + e - p) / 2, 0, e) - e / 2;
    l[8] -= m * 2 / t, l[9] += A * 2 / e;
  }
  return l;
}
class cr {
  // eslint-disable-next-line complexity
  constructor(e = {}) {
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || jC, this.focalDistance = e.focalDistance || 1, this.position = e.position || Dh, this.modelMatrix = e.modelMatrix || null;
    const { longitude: s, latitude: n } = e;
    this.isGeospatial = Number.isFinite(n) && Number.isFinite(s), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? mt.WEB_MERCATOR : mt.WEB_MERCATOR_AUTO_OFFSET : mt.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof cr ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Qe(e.projectionMatrix, this.projectionMatrix) && Qe(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e, { topLeft: s = !0 } = {}) {
    const n = this.projectPosition(e), r = fp(n, this.pixelProjectionMatrix), [i, o] = r, a = s ? o : this.height - o;
    return e.length === 2 ? [i, a] : [i, a, r[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, { topLeft: s = !0, targetZ: n } = {}) {
    const [r, i, o] = e, a = s ? i : this.height - i, c = n && n * this.distanceScales.unitsPerMeter[2], l = Mc([r, a, o], this.pixelUnprojectionMatrix, c), [h, u, f] = this.unprojectPosition(l);
    return Number.isFinite(o) ? [h, u, f] : Number.isFinite(n) ? [h, u, n] : [h, u];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [s, n] = this.projectFlat(e), r = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [s, n, r];
  }
  unprojectPosition(e) {
    const [s, n] = this.unprojectFlat(e), r = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [s, n, r];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const s = Kn(e);
      return s[1] = wt(s[1], -318, 830), s;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? sn(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(e = {}) {
    const s = { targetZ: e.z || 0 }, n = this.unproject([0, 0], s), r = this.unproject([this.width, 0], s), i = this.unproject([0, this.height], s), o = this.unproject([this.width, this.height], s);
    return [
      Math.min(n[0], r[0], i[0], o[0]),
      Math.min(n[1], r[1], i[1], o[1]),
      Math.max(n[0], r[0], i[0], o[0]),
      Math.max(n[1], r[1], i[1], o[1])
    ];
  }
  getDistanceScales(e) {
    return e ? Ia({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({ x: e, y: s, width: n = 1, height: r = 1 }) {
    return e < this.x + this.width && this.x < e + n && s < this.y + this.height && this.y < s + r;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, LC(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, s) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const s = e.longitude, n = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = nC({ latitude: n }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Ia({ latitude: n, longitude: s }));
    const r = Math.pow(2, this.zoom);
    this.scale = r;
    const { position: i, modelMatrix: o } = e;
    let a = Dh;
    if (i && (a = o ? new W(o).transformAsVector(i, []) : i), this.isGeospatial) {
      const c = this.projectPosition([s, n, 0]);
      this.center = new S(a).scale(this.distanceScales.unitsPerMeter).add(c);
    } else
      this.center = this.projectPosition(a);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: s = zC,
      // Projection matrix
      projectionMatrix: n = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: r = !1,
      fovyRadians: i,
      fovy: o = 75,
      near: a = 0.1,
      // Distance of near clipping plane
      far: c = 1e3,
      // Distance of far clipping plane
      padding: l = null,
      // Center offset in pixels
      focalDistance: h = 1
    } = e;
    this.viewMatrixUncentered = s, this.viewMatrix = new W().multiplyRight(s).translate(new S(this.center).negate()), this.projectionMatrix = n || WC({
      width: this.width,
      height: this.height,
      orthographic: r,
      fovyRadians: i || o * HC,
      focalDistance: h,
      padding: l,
      near: a,
      far: c
    });
    const u = Nn();
    _s(u, u, this.projectionMatrix), _s(u, u, this.viewMatrix), this.viewProjectionMatrix = u, this.viewMatrixInverse = ba([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = UC(this.viewMatrixInverse);
    const f = Nn(), p = Nn();
    Sc(f, f, [this.width / 2, -this.height / 2, 1]), pi(f, f, [1, -1, 0]), _s(p, f, this.viewProjectionMatrix), this.pixelProjectionMatrix = p, this.pixelUnprojectionMatrix = ba(Nn(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || $.warn("Pixel project matrix not invertible")();
  }
}
cr.displayName = "Viewport";
class ms extends cr {
  /* eslint-disable complexity, max-statements */
  constructor(e = {}) {
    const {
      latitude: s = 0,
      longitude: n = 0,
      zoom: r = 0,
      pitch: i = 0,
      bearing: o = 0,
      nearZMultiplier: a = 0.1,
      farZMultiplier: c = 1.01,
      nearZ: l,
      farZ: h,
      orthographic: u = !1,
      projectionMatrix: f,
      repeat: p = !1,
      worldOffset: m = 0,
      position: A,
      padding: E,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: C = !1
    } = e;
    let { width: w, height: I, altitude: B = 1.5 } = e;
    const x = Math.pow(2, r);
    w = w || 1, I = I || 1;
    let N, L = null;
    if (f)
      B = f[5] / 2, N = gi(B);
    else {
      e.fovy ? (N = e.fovy, B = up(N)) : N = gi(B);
      let F;
      if (E) {
        const { top: U = 0, bottom: H = 0 } = E;
        F = [0, wt((U + I - H) / 2, 0, I) - I / 2];
      }
      L = iC({
        width: w,
        height: I,
        scale: x,
        center: A && [0, 0, A[2] * ti(s)],
        offset: F,
        pitch: i,
        fovy: N,
        nearZMultiplier: a,
        farZMultiplier: c
      }), Number.isFinite(l) && (L.near = l), Number.isFinite(h) && (L.far = h);
    }
    let k = rC({
      height: I,
      pitch: i,
      bearing: o,
      scale: x,
      altitude: B
    });
    m && (k = new W().translate([512 * m, 0, 0]).multiplyLeft(k)), super({
      ...e,
      // x, y,
      width: w,
      height: I,
      // view matrix
      viewMatrix: k,
      longitude: n,
      latitude: s,
      zoom: r,
      // projection matrix parameters
      ...L,
      fovy: N,
      focalDistance: B
    }), this.latitude = s, this.longitude = n, this.zoom = r, this.pitch = i, this.bearing = o, this.altitude = B, this.fovy = N, this.orthographic = u, this._subViewports = p ? [] : null, this._pseudoMeters = C, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), s = Math.floor((e[0] + 180) / 360), n = Math.ceil((e[2] - 180) / 360);
      for (let r = s; r <= n; r++) {
        const i = r ? new ms({
          ...this,
          worldOffset: r
        }) : this;
        this._subViewports.push(i);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [s, n] = this.projectFlat(e), r = (e[2] || 0) * ti(e[1]);
    return [s, n, r];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [s, n] = this.unprojectFlat(e), r = (e[2] || 0) / ti(n);
    return [s, n, r];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, s) {
    return hp(e, s);
  }
  panByPosition(e, s) {
    const n = Mc(s, this.pixelUnprojectionMatrix), r = this.projectFlat(e), i = Th([], r, dE([], n)), o = Th([], this.center, i), [a, c] = this.unprojectFlat(o);
    return { longitude: a, latitude: c };
  }
  getBounds(e = {}) {
    const s = cC(this, e.z || 0);
    return [
      Math.min(s[0][0], s[1][0], s[2][0], s[3][0]),
      Math.min(s[0][1], s[1][1], s[2][1], s[3][1]),
      Math.max(s[0][0], s[1][0], s[2][0], s[3][0]),
      Math.max(s[0][1], s[1][1], s[2][1], s[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e, s = {}) {
    const { width: n, height: r } = this, { longitude: i, latitude: o, zoom: a } = oC({ width: n, height: r, bounds: e, ...s });
    return new ms({ width: n, height: r, longitude: i, latitude: o, zoom: a });
  }
}
ms.displayName = "WebMercatorViewport";
const Uh = [0, 0, 0];
function bo(t, e, s = !1) {
  const n = e.projectPosition(t);
  if (s && e instanceof ms) {
    const [r, i, o = 0] = t, a = e.getDistanceScales([r, i]);
    n[2] = o * a.unitsPerMeter[2];
  }
  return n;
}
function XC(t) {
  const { viewport: e, modelMatrix: s, coordinateOrigin: n } = t;
  let { coordinateSystem: r, fromCoordinateSystem: i, fromCoordinateOrigin: o } = t;
  return r === X.DEFAULT && (r = e.isGeospatial ? X.LNGLAT : X.CARTESIAN), i === void 0 && (i = r), o === void 0 && (o = n), {
    viewport: e,
    coordinateSystem: r,
    coordinateOrigin: n,
    modelMatrix: s,
    fromCoordinateSystem: i,
    fromCoordinateOrigin: o
  };
}
function _p(t, { viewport: e, modelMatrix: s, coordinateSystem: n, coordinateOrigin: r, offsetMode: i }) {
  let [o, a, c = 0] = t;
  switch (s && ([o, a, c] = or([], [o, a, c, 1], s)), n) {
    case X.LNGLAT:
      return bo([o, a, c], e, i);
    case X.LNGLAT_OFFSETS:
      return bo([o + r[0], a + r[1], c + (r[2] || 0)], e, i);
    case X.METER_OFFSETS:
      return bo(hp(r, [o, a, c]), e, i);
    case X.CARTESIAN:
    default:
      return e.isGeospatial ? [o + r[0], a + r[1], c + r[2]] : e.projectPosition([o, a, c]);
  }
}
function GC(t, e) {
  const { viewport: s, coordinateSystem: n, coordinateOrigin: r, modelMatrix: i, fromCoordinateSystem: o, fromCoordinateOrigin: a } = XC(e), { autoOffset: c = !0 } = e, { geospatialOrigin: l = Uh, shaderCoordinateOrigin: h = Uh, offsetMode: u = !1 } = c ? cp(s, n, r) : {}, f = _p(t, {
    viewport: s,
    modelMatrix: i,
    coordinateSystem: o,
    coordinateOrigin: a,
    offsetMode: u
  });
  if (u) {
    const p = s.projectPosition(l || h);
    RE(f, f, p);
  }
  return f;
}
let $C = 1, KC = 1;
class gp {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = !1;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(e) {
    const { delay: s = 0, duration: n = Number.POSITIVE_INFINITY, rate: r = 1, repeat: i = 1 } = e, o = $C++, a = {
      time: 0,
      delay: s,
      duration: n,
      rate: r,
      repeat: i
    };
    return this._setChannelTime(a, this.time), this.channels.set(o, a), o;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [s, n] of this.animations)
      n.channel === e && this.detachAnimation(s);
  }
  isFinished(e) {
    const s = this.channels.get(e);
    return s === void 0 ? !1 : this.time >= s.delay + s.duration * s.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const s = this.channels.get(e);
    return s === void 0 ? -1 : s.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const s = this.channels.values();
    for (const r of s)
      this._setChannelTime(r, this.time);
    const n = this.animations.values();
    for (const r of n) {
      const { animation: i, channel: o } = r;
      i.setTime(this.getTime(o));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, s) {
    const n = KC++;
    return this.animations.set(n, {
      animation: e,
      channel: s
    }), e.setTime(this.getTime(s)), n;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, s) {
    const n = s - e.delay, r = e.duration * e.repeat;
    n >= r ? e.time = e.duration * e.rate : (e.time = Math.max(0, n) % e.duration, e.time *= e.rate);
  }
}
let YC = 0;
const JC = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (t) => console.error(t),
  // eslint-disable-line no-console
  stats: Xs.stats.get(`animation-loop-${YC++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class qC {
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = !1;
  _running = !1;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    if (this.props = { ...JC, ...e }, e = this.props, !e.device)
      throw new Error("No device provided");
    const { useDevicePixels: s = !0 } = this.props;
    this.stats = e.stats || new hn({ id: "animation-loop-stats" }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport,
      autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
      useDevicePixels: s
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const s = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(s), s;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    return this.device?.isLost ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = nb(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (rb(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    if (!this.device)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: this.device?.canvasContext?.canvas,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const { width: e, height: s, aspect: n } = this._getSizeAndAspect();
    (e !== this.animationProps.width || s !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), n !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = s, this.animationProps.aspect = n, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = this.device.canvasContext?.canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const s = document.createElement("div");
      s.style.position = "absolute", s.style.left = "10px", s.style.bottom = "10px", s.style.width = "300px", s.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(s);
      const n = this.props.onAddHTML(s);
      n && (s.innerHTML = n);
    }
  }
  _getSizeAndAspect() {
    if (!this.device)
      return { width: 1, height: 1, aspect: 1 };
    const [e, s] = this.device?.canvasContext?.getPixelSize() || [1, 1];
    let n = 1;
    const r = this.device?.canvasContext?.canvas;
    return r && r.clientHeight ? n = r.clientWidth / r.clientHeight : e > 0 && s > 0 && (n = e / s), { width: e, height: s, aspect: n };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    this.props.autoResizeDrawingBuffer && this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
class Lh {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(e) {
    this.id = e.id || Qt("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && q(this.indices.usage === re.INDEX);
  }
  destroy() {
    this.indices?.destroy();
    for (const e of Object.values(this.attributes))
      e.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function ZC(t, e) {
  if (e instanceof Lh)
    return e;
  const s = QC(t, e), { attributes: n, bufferLayout: r } = eS(t, e);
  return new Lh({
    topology: e.topology || "triangle-list",
    bufferLayout: r,
    vertexCount: e.vertexCount,
    indices: s,
    attributes: n
  });
}
function QC(t, e) {
  if (!e.indices)
    return;
  const s = e.indices.value;
  return t.createBuffer({ usage: re.INDEX, data: s });
}
function eS(t, e) {
  const s = [], n = {};
  for (const [i, o] of Object.entries(e.attributes)) {
    let a = i;
    switch (i) {
      case "POSITION":
        a = "positions";
        break;
      case "NORMAL":
        a = "normals";
        break;
      case "TEXCOORD_0":
        a = "texCoords";
        break;
      case "COLOR_0":
        a = "colors";
        break;
    }
    n[a] = t.createBuffer({ data: o.value, id: `${i}-buffer` });
    const { value: c, size: l, normalized: h } = o;
    s.push({ name: a, format: Zy(c, l, h) });
  }
  const r = e._calculateVertexCount(e.attributes, e.indices);
  return { attributes: n, bufferLayout: s, vertexCount: r };
}
class tS {
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  moduleUniformsChanged;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e) {
    const s = Ii(Object.values(e).filter((n) => n.dependencies));
    for (const n of s)
      e[n.name] = n;
    P.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [n, r] of Object.entries(e)) {
      const i = n;
      this.moduleUniforms[i] = r.defaultUniforms || {}, this.moduleBindings[i] = {};
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    for (const s of Object.keys(e)) {
      const n = s, r = e[n], i = this.modules[n];
      if (!i) {
        P.warn(`Module ${s} not found`)();
        continue;
      }
      const o = this.moduleUniforms[n], a = this.moduleBindings[n], c = i.getUniforms?.(r, o) || r, { uniforms: l, bindings: h } = gc(c);
      this.moduleUniforms[n] = { ...o, ...l }, this.moduleBindings[n] = { ...a, ...h };
    }
  }
  /** Merges all bindings for the shader (from the various modules) */
  // getUniformBlocks(): Record<string, Texture | Sampler> {
  //   return this.moduleUniforms;
  // }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindings() {
    const e = {};
    for (const s of Object.values(this.moduleBindings))
      Object.assign(e, s);
    return e;
  }
  getDebugTable() {
    const e = {};
    for (const [s, n] of Object.entries(this.moduleUniforms))
      for (const [r, i] of Object.entries(n))
        e[`${s}.${r}`] = {
          type: this.modules[s].uniformTypes?.[r],
          value: String(i)
        };
    return e;
  }
}
class xc {
  static defaultProps = { ...Qs.defaultProps };
  device;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new xc(e), e._lumaData.defaultPipelineFactory;
  }
  constructor(e) {
    this.device = e;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(e) {
    const s = { ...Qs.defaultProps, ...e }, n = this._hashRenderPipeline(s);
    if (!this._renderPipelineCache[n]) {
      const r = this.device.createRenderPipeline({
        ...s,
        id: s.id ? `${s.id}-cached` : void 0
      });
      r.hash = n, this._renderPipelineCache[n] = { pipeline: r, useCount: 0 };
    }
    return this._renderPipelineCache[n].useCount++, this._renderPipelineCache[n].pipeline;
  }
  createComputePipeline(e) {
    const s = { ...hi.defaultProps, ...e }, n = this._hashComputePipeline(s);
    if (!this._computePipelineCache[n]) {
      const r = this.device.createComputePipeline({
        ...s,
        id: s.id ? `${s.id}-cached` : void 0
      });
      r.hash = n, this._computePipelineCache[n] = { pipeline: r, useCount: 0 };
    }
    return this._computePipelineCache[n].useCount++, this._computePipelineCache[n].pipeline;
  }
  release(e) {
    const s = e.hash, n = e instanceof hi ? this._computePipelineCache : this._renderPipelineCache;
    n[s].useCount--, n[s].useCount === 0 && (n[s].pipeline.destroy(), delete n[s]);
  }
  // PRIVATE
  _hashComputePipeline(e) {
    return `${this._getHash(e.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const s = this._getHash(e.vs.source), n = e.fs ? this._getHash(e.fs.source) : 0, r = "-", i = this._getHash(JSON.stringify(e.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${s}/${n}V${r}BL${i}`;
      default:
        const o = this._getHash(JSON.stringify(e.parameters));
        return `${s}/${n}V${r}T${e.topology}P${o}BL${i}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
}
class Nc {
  static defaultProps = { ...Mi.defaultProps };
  device;
  _cache = {};
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    return e._lumaData.defaultShaderFactory ||= new Nc(e), e._lumaData.defaultShaderFactory;
  }
  /** @internal */
  constructor(e) {
    this.device = e;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    const s = this._hashShader(e);
    let n = this._cache[s];
    if (!n) {
      const r = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[s] = n = { shader: r, useCount: 0 };
    }
    return n.useCount++, n.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    const s = this._hashShader(e), n = this._cache[s];
    n && (n.useCount--, n.useCount === 0 && (delete this._cache[s], n.shader.destroy()));
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
}
function sS(t, e) {
  const s = {}, n = "Values";
  if (t.attributes.length === 0 && !t.varyings?.length)
    return { "No attributes or varyings": { [n]: "N/A" } };
  for (const r of t.attributes)
    if (r) {
      const i = `${r.location} ${r.name}: ${r.type}`;
      s[`in ${i}`] = { [n]: r.stepMode || "vertex" };
    }
  for (const r of t.varyings || []) {
    const i = `${r.location} ${r.name}`;
    s[`out ${i}`] = { [n]: JSON.stringify(r.accessor) };
  }
  return s;
}
let pe = null, Eo = null;
function nS(t, { id: e, minimap: s, opaque: n, top: r = "0", left: i = "0", rgbaScale: o = 1 }) {
  pe || (pe = document.createElement("canvas"), pe.id = e, pe.title = e, pe.style.zIndex = "100", pe.style.position = "absolute", pe.style.top = r, pe.style.left = i, pe.style.border = "blue 1px solid", pe.style.transform = "scaleY(-1)", document.body.appendChild(pe), Eo = pe.getContext("2d")), (pe.width !== t.width || pe.height !== t.height) && (pe.width = t.width / 2, pe.height = t.height / 2, pe.style.width = "400px", pe.style.height = "400px");
  const a = t.device.readPixelsToArrayWebGL(t), c = Eo.createImageData(t.width, t.height), l = 0;
  for (let h = 0; h < a.length; h += 4)
    c.data[l + h + 0] = a[h + 0] * o, c.data[l + h + 1] = a[h + 1] * o, c.data[l + h + 2] = a[h + 2] * o, c.data[l + h + 3] = n ? 255 : a[h + 3] * o;
  Eo.putImageData(c, 0, 0);
}
const Ms = 2, rS = 1e4;
class Yt {
  static defaultProps = {
    ...Qs.defaultProps,
    source: null,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: us.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  source;
  vs;
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
  uniforms = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  shaderInputs;
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  _getModuleUniforms;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = !1;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  constructor(e, s) {
    this.props = { ...Yt.defaultProps, ...s }, s = this.props, this.id = s.id || Qt("model"), this.device = e, Object.assign(this.userData, s.userData);
    const n = Object.fromEntries(this.props.modules?.map((a) => [a.name, a]) || []);
    this.setShaderInputs(s.shaderInputs || new tS(n));
    const r = iS(e), i = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
    if (this.device.type === "webgpu" && this.props.source) {
      this.props.shaderLayout ||= zb(this.props.source);
      const { source: a, getUniforms: c } = this.props.shaderAssembler.assembleShader({
        platformInfo: r,
        ...this.props,
        modules: i
      });
      this.source = a, this._getModuleUniforms = c;
    } else {
      const { vs: a, fs: c, getUniforms: l } = this.props.shaderAssembler.assembleShaderPair({
        platformInfo: r,
        ...this.props,
        modules: i
      });
      this.vs = a, this.fs = c, this._getModuleUniforms = l;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, s.geometry && this.setGeometry(s.geometry), this.pipelineFactory = s.pipelineFactory || xc.getDefaultPipelineFactory(this.device), this.shaderFactory = s.shaderFactory || Nc.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in s && (this.isInstanced = s.isInstanced), s.instanceCount && this.setInstanceCount(s.instanceCount), s.vertexCount && this.setVertexCount(s.vertexCount), s.indexBuffer && this.setIndexBuffer(s.indexBuffer), s.attributes && this.setAttributes(s.attributes), s.constantAttributes && this.setConstantAttributes(s.constantAttributes), s.bindings && this.setBindings(s.bindings), s.uniforms && this.setUniforms(s.uniforms), s.moduleSettings && this.updateModuleSettings(s.moduleSettings), s.transformFeedback && (this.transformFeedback = s.transformFeedback), Object.seal(this);
  }
  destroy() {
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw ||= e;
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    this.predraw();
    let s;
    try {
      this._logDrawCallStart(), this.pipeline = this._updatePipeline(), this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings }), li(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const { indexBuffer: n } = this.vertexArray, r = n ? n.byteLength / (n.indexType === "uint32" ? 4 : 2) : void 0;
      s = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: r,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), s ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", s;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    this._gpuGeometry?.destroy();
    const s = e && ZC(this.device, e);
    s && (this.setTopology(s.topology || "triangle-list"), this.bufferLayout = kh(s.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(s)), this._gpuGeometry = s;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    this.bufferLayout = this._gpuGeometry ? kh(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    ga(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new qy(this.shaderInputs.modules);
    for (const s of Object.keys(this.shaderInputs.modules)) {
      const n = this._uniformStore.getManagedUniformBuffer(this.device, s);
      this.bindings[`${s}Uniforms`] = n;
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindings()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, s) {
    e.indices && P.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    for (const [n, r] of Object.entries(e)) {
      const i = this.bufferLayout.find((c) => Vh(c).includes(n));
      if (!i) {
        P.warn(`Model(${this.id}): Missing layout for buffer "${n}".`)();
        continue;
      }
      const o = Vh(i);
      let a = !1;
      for (const c of o) {
        const l = this._attributeInfos[c];
        l && (this.vertexArray.setBuffer(l.location, r), a = !0);
      }
      !a && !(s?.disableWarnings ?? this.props.disableWarnings) && P.warn(`Model(${this.id}): Ignoring buffer "${r.id}" for unknown attribute "${n}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, s) {
    for (const [n, r] of Object.entries(e)) {
      const i = this._attributeInfos[n];
      i ? this.vertexArray.setConstantWebGL(i.location, r) : (s?.disableWarnings ?? this.props.disableWarnings) || P.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(e) {
    li(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettings(e) {
    const { bindings: s, uniforms: n } = gc(this._getModuleUniforms(e));
    Object.assign(this.bindings, s), Object.assign(this.uniforms, n), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const s of Object.values(this.bindings))
      s instanceof Bi ? e = Math.max(e, s.texture.updateTimestamp) : s instanceof re || s instanceof Ne ? e = Math.max(e, s.updateTimestamp) : s instanceof Pi || (e = Math.max(e, s.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const s = { ...e.attributes };
    for (const [n] of Object.entries(s))
      !this.pipeline.shaderLayout.attributes.find((r) => r.name === n) && n !== "positions" && delete s[n];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, { disableWarnings: !0 }), this.setAttributes(s, { disableWarnings: this.props.disableWarnings }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate ||= e, this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, s = null;
      this.pipeline && (P.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, s = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const n = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debug: this.props.debugShaders
      });
      let r = null;
      this.source ? r = n : this.fs && (r = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debug: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        vs: n,
        fs: r
      }), this._attributeInfos = Sd(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), s && this.shaderFactory.release(s);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = !1;
  _logDrawCallStart() {
    const e = P.level > 3 ? 0 : rS;
    P.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, P.group(Ms, `>>> DRAWING MODEL ${this.id}`, { collapsed: P.level <= 2 })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = sS(this.pipeline.shaderLayout, this.id);
      P.table(Ms, e)();
      const s = this.shaderInputs.getDebugTable();
      for (const [r, i] of Object.entries(this.uniforms))
        s[r] = { value: i };
      P.table(Ms, s)();
      const n = this._getAttributeDebugTable();
      P.table(Ms, this._attributeInfos)(), P.table(Ms, n)(), P.groupEnd(Ms)(), this._logOpen = !1;
    }
  }
  _drawCount = 0;
  _logFramebuffer(e) {
    const s = P.get("framebuffer");
    if (this._drawCount++, !s || this._drawCount++ > 3 && this._drawCount % 60)
      return;
    const n = e.props.framebuffer;
    n && nS(n, { id: n.id, minimap: !0 });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [s, n] of Object.entries(this._attributeInfos))
      e[n.location] = {
        name: s,
        type: n.shaderType,
        values: this._getBufferOrConstantValues(this.vertexArray.attributes[n.location], n.bufferDataType)
      };
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer: s } = this.vertexArray, n = s.indexType === "uint32" ? new Uint32Array(s.debugData) : new Uint16Array(s.debugData);
      e.indices = {
        name: "indices",
        type: s.indexType,
        values: n.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, s) {
    const n = Id(s);
    return (e instanceof re ? new n(e.debugData) : e).toString();
  }
}
function kh(t, e) {
  const s = [...t];
  for (const n of e) {
    const r = s.findIndex((i) => i.name === n.name);
    r < 0 ? s.push(n) : s[r] = n;
  }
  return s;
}
function iS(t) {
  return {
    type: t.type,
    shaderLanguage: t.info.shadingLanguage,
    shaderLanguageVersion: t.info.shadingLanguageVersion,
    gpu: t.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: t.features
  };
}
function Vh(t) {
  return t.attributes ? t.attributes?.map((e) => e.attribute) : [t.name];
}
class Jn {
  device;
  model;
  transformFeedback;
  /** @deprecated Use device feature test. */
  static isSupported(e) {
    return e?.info?.type === "webgl";
  }
  constructor(e, s = Yt.defaultProps) {
    q(Jn.isSupported(e), "BufferTransform not yet implemented on WebGPU"), this.device = e, this.model = new Yt(this.device, {
      id: s.id || "buffer-transform-model",
      fs: s.fs || QT(),
      topology: s.topology || "point-list",
      ...s
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      buffers: s.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    const s = this.device.beginRenderPass(e);
    this.model.draw(s), s.end();
  }
  /** @deprecated */
  update(...e) {
    console.warn("TextureTransform#update() not implemented");
  }
  /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  readAsync(e) {
    const s = this.getBuffer(e);
    if (s instanceof re)
      return s.readAsync();
    const { buffer: n, byteOffset: r = 0, byteLength: i = n.byteLength } = s;
    return n.readAsync(r, i);
  }
}
class Ks {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(e) {
    const { attributes: s = {}, indices: n = null, vertexCount: r = null } = e;
    this.id = e.id || Qt("geometry"), this.topology = e.topology, n && (this.indices = ArrayBuffer.isView(n) ? { value: n, size: 1 } : n), this.attributes = {};
    for (const [i, o] of Object.entries(s)) {
      const a = ArrayBuffer.isView(o) ? { value: o } : o;
      q(ArrayBuffer.isView(a.value), `${this._print(i)}: must be typed array or object with value as typed array`), (i === "POSITION" || i === "positions") && !a.size && (a.size = 3), i === "indices" ? (q(!this.indices), this.indices = a) : this.attributes[i] = a;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = r || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, s) {
    return this;
  }
  _calculateVertexCount(e, s) {
    if (s)
      return s.value.length;
    let n = 1 / 0;
    for (const r of Object.values(e)) {
      const { value: i, size: o, constant: a } = r;
      !a && i && o >= 1 && (n = Math.min(n, i.length / o));
    }
    return q(Number.isFinite(n)), n;
  }
}
class mi {
  id;
  matrix = new W();
  display = !0;
  position = new S();
  rotation = new S();
  scale = new S(1, 1, 1);
  userData = {};
  props = {};
  constructor(e = {}) {
    const { id: s } = e;
    this.id = s || Qt(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return q(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return q(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return q(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e, s = !0) {
    s ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const { position: s, rotation: n, scale: r, update: i = !0 } = e;
    return s && this.setPosition(s), n && this.setRotation(n), r && this.setScale(r), i && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, s = this.rotation, n = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(s), this.matrix.scale(n), this;
  }
  update(e = {}) {
    const { position: s, rotation: n, scale: r } = e;
    return s && this.setPosition(s), n && this.setRotation(n), r && this.setScale(r), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, s) {
    q(e), s = s || this.matrix;
    const n = new W(e).multiplyRight(s), r = n.invert(), i = r.transpose();
    return {
      viewMatrix: e,
      modelMatrix: s,
      objectMatrix: s,
      worldMatrix: n,
      worldInverseMatrix: r,
      worldInverseTransposeMatrix: i
    };
  }
  // TODO - copied code, not yet vetted
  /*
    transform() {
      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        const parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }
  
      const ch = this.children;
      for (let i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }
  
      return this;
    }
    */
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Ys extends mi {
  children;
  constructor(e = {}) {
    e = Array.isArray(e) ? { children: e } : e;
    const { children: s = [] } = e;
    P.assert(s.every((n) => n instanceof mi), "every child must an instance of ScenegraphNode"), super(e), this.children = s;
  }
  getBounds() {
    const e = [
      [1 / 0, 1 / 0, 1 / 0],
      [-1 / 0, -1 / 0, -1 / 0]
    ];
    return this.traverse((s, { worldMatrix: n }) => {
      const r = s.getBounds();
      if (!r)
        return;
      const [i, o] = r, a = new S(i).add(o).divide([2, 2, 2]);
      n.transformAsPoint(a, a);
      const c = new S(o).subtract(i).divide([2, 2, 2]);
      n.transformAsVector(c, c);
      for (let l = 0; l < 8; l++) {
        const h = new S(l & 1 ? -1 : 1, l & 2 ? -1 : 1, l & 4 ? -1 : 1).multiply(c).add(a);
        for (let u = 0; u < 3; u++)
          e[0][u] = Math.min(e[0][u], h[u]), e[1][u] = Math.max(e[1][u], h[u]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  destroy() {
    this.children.forEach((e) => e.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add(...e) {
    for (const s of e)
      Array.isArray(s) ? this.add(...s) : this.children.push(s);
    return this;
  }
  remove(e) {
    const s = this.children, n = s.indexOf(e);
    return n > -1 && s.splice(n, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(e, { worldMatrix: s = new W() } = {}) {
    const n = new W(s).multiplyRight(this.matrix);
    for (const r of this.children)
      r instanceof Ys ? r.traverse(e, { worldMatrix: n }) : e(r, { worldMatrix: n });
  }
}
class va extends mi {
  model;
  bounds = null;
  managedResources;
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(e) {
    super(e), this.model = e.model, this.managedResources = e.managedResources || [], this.bounds = e.bounds || null, this.setProps(e);
  }
  getBounds() {
    return this.bounds;
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((e) => e.destroy()), this.managedResources = [];
  }
  // Expose model methods
  draw(e) {
    return this.model.draw(e);
  }
}
const oS = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class mp extends Oc {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers: e, layerFilter: s, views: n, viewports: r, onViewportActive: i, pickingFBO: o, deviceRect: { x: a, y: c, width: l, height: h }, cullRect: u, effects: f, pass: p = "picking", pickZ: m, moduleParameters: A }) {
    this.pickZ = m;
    const E = this._resetColorEncoder(m), C = [a, c, l, h], w = super.render({
      target: o,
      layers: e,
      layerFilter: s,
      views: n,
      viewports: r,
      onViewportActive: i,
      cullRect: u,
      effects: f?.filter((B) => B.useInPicking),
      pass: p,
      isPicking: !0,
      moduleParameters: A,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: C
    });
    return this._colorEncoderState = null, { decodePickingColor: E && cS.bind(null, E), stats: w };
  }
  shouldDrawLayer(e) {
    const { pickable: s, operation: n } = e.props;
    return s && n.includes("draw") || n.includes("terrain") || n.includes("mask");
  }
  getModuleParameters() {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      // turn off lighting by adding empty light source object
      // lights shader module relies on the `lightSources` to turn on/off lighting
      lightSources: {}
    };
  }
  getLayerParameters(e, s, n) {
    const r = {
      // TODO - When used as a custom layer in older Mapbox versions, context
      // state was dirty. Mapbox fixed that; we should test and remove the workaround.
      // https://github.com/mapbox/mapbox-gl-js/issues/7801
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      ...e.props.parameters
    }, { pickable: i, operation: o } = e.props;
    return !this._colorEncoderState || o.includes("terrain") ? r.blend = !1 : i && o.includes("draw") && (Object.assign(r, oS), r.blend = !0, r.blendColor = aS(this._colorEncoderState, e, n)), r;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function aS(t, e, s) {
  const { byLayer: n, byAlpha: r } = t;
  let i, o = n.get(e);
  return o ? (o.viewports.push(s), i = o.a) : (i = n.size + 1, i <= 255 ? (o = { a: i, layer: e, viewports: [s] }, n.set(e, o), r[i] = o) : ($.warn("Too many pickable layers, only picking the first 255")(), i = 0)), [0, 0, 0, i / 255];
}
function cS(t, e) {
  const s = t.byAlpha[e[3]];
  return s && {
    pickedLayer: s.layer,
    pickedViewports: s.viewports,
    pickedObjectIndex: s.layer.decodePickingColor(e)
  };
}
const Fs = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, Ai = Symbol.for("component"), Xt = Symbol.for("propTypes"), Co = Symbol.for("deprecatedProps"), Js = Symbol.for("asyncPropDefaults"), As = Symbol.for("asyncPropOriginal"), zt = Symbol.for("asyncPropResolved");
function nn(t, e = () => !0) {
  return Array.isArray(t) ? Ap(t, e, []) : e(t) ? [t] : [];
}
function Ap(t, e, s) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Ap(r, e, s) : e(r) && s.push(r);
  }
  return s;
}
function lS({ target: t, source: e, start: s = 0, count: n = 1 }) {
  const r = e.length, i = n * r;
  let o = 0;
  for (let a = s; o < r; o++)
    t[a++] = e[o];
  for (; o < i; )
    o < i - o ? (t.copyWithin(s + o, s, s + o), o *= 2) : (t.copyWithin(s + o, s, s + i - o), o = i);
  return t;
}
class hS {
  constructor(e, s, n) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = n, this.setData(s);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, s) {
    if (e === this._data && !s)
      return;
    this._data = e;
    const n = ++this._loadCount;
    let r = e;
    typeof e == "string" && (r = $t(e)), r instanceof Promise ? (this.isLoaded = !1, this._loader = r.then((i) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = void 0, this._content = i);
    }).catch((i) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = i || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const i of this._subscribers)
      i.onChange(this.getData());
  }
}
class uS {
  constructor(e) {
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: e.device?.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add({ resourceId: e, data: s, forceUpdate: n = !1, persistent: r = !0 }) {
    let i = this._resources[e];
    i ? i.setData(s, n) : (i = new hS(e, s, this._context), this._resources[e] = i), i.persistent = r;
  }
  remove(e) {
    const s = this._resources[e];
    s && (s.delete(), delete this._resources[e]);
  }
  unsubscribe({ consumerId: e }) {
    const s = this._consumers[e];
    if (s) {
      for (const n in s) {
        const r = s[n], i = this._resources[r.resourceId];
        i && i.unsubscribe(r);
      }
      delete this._consumers[e], this.prune();
    }
  }
  subscribe({ resourceId: e, onChange: s, consumerId: n, requestId: r = "default" }) {
    const { _resources: i, protocol: o } = this;
    e.startsWith(o) && (e = e.replace(o, ""), i[e] || this.add({ resourceId: e, data: null, persistent: !1 }));
    const a = i[e];
    if (this._track(n, r, a, s), a)
      return a.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, s, n, r) {
    const i = this._consumers, o = i[e] = i[e] || {};
    let a = o[s];
    const c = a && a.resourceId && this._resources[a.resourceId];
    c && (c.unsubscribe(a), this.prune()), n && (a ? (a.onChange = r, a.resourceId = n.id) : a = {
      onChange: r,
      resourceId: n.id
    }, o[s] = a, n.subscribe(a));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const s = this._resources[e];
      !s.persistent && !s.inUse() && (s.delete(), delete this._resources[e]);
    }
  }
}
const fS = "layerManager.setLayers", dS = "layerManager.activateViewport";
class pS {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, s) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (a) => {
      Te(dS, this, a), a && (this.context.viewport = a);
    };
    const { deck: n, stats: r, viewport: i, timeline: o } = s || {};
    this.layers = [], this.resourceManager = new uS({ device: e, protocol: "deck://" }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e?.gl,
      deck: n,
      shaderAssembler: EC(),
      defaultShaderModules: [],
      renderPass: void 0,
      stats: r || new hn({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: i || new cr({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: o || new gp(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    let s = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const n of this.layers) {
      const r = n.getNeedsRedraw(e);
      s = s || r;
    }
    return s;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds: e } = {}) {
    return e ? this.layers.filter((s) => e.find((n) => s.id.indexOf(n) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, s) {
    Te(fS, this, s, e), this._lastRenderedLayers = e;
    const n = nn(e, Boolean);
    for (const r of n)
      r.context = this.context;
    this._updateLayers(this.layers, n);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const { defaultShaderModules: s } = this.context;
    s.find((n) => n.name === e.name) || (s.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const { defaultShaderModules: s } = this.context, n = s.findIndex((r) => r.name === e.name);
    n >= 0 && (s.splice(n, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, s, n) {
    n.raiseError(s, `${e} of ${n}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, s) {
    const n = {};
    for (const o of e)
      n[o.id] ? $.warn(`Multiple old layers with same id ${o.id}`)() : n[o.id] = o;
    if (this._defaultShaderModulesChanged) {
      for (const o of e)
        o.setNeedsUpdate(), o.setChangeFlags({ extensionsChanged: !0 });
      this._defaultShaderModulesChanged = !1;
    }
    const r = [];
    this._updateSublayersRecursively(s, n, r), this._finalizeOldLayers(n);
    let i = !1;
    for (const o of r)
      if (o.hasUniformTransition()) {
        i = `Uniform transition in ${o}`;
        break;
      }
    this._needsUpdate = i, this.layers = r;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, s, n) {
    for (const r of e) {
      r.context = this.context;
      const i = s[r.id];
      i === null && $.warn(`Multiple new layers with same id ${r.id}`)(), s[r.id] = null;
      let o = null;
      try {
        this._debug && i !== r && r.validateProps(), i ? (this._transferLayerState(i, r), this._updateLayer(r)) : this._initializeLayer(r), n.push(r), o = r.isComposite ? r.getSubLayers() : null;
      } catch (a) {
        this._handleError("matching", a, r);
      }
      o && this._updateSublayersRecursively(o, s, n);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const s in e) {
      const n = e[s];
      n && this._finalizeLayer(n);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Fs.INITIALIZED;
    } catch (s) {
      this._handleError("initialization", s, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, s) {
    s._transferState(e), s.lifecycle = Fs.MATCHED, s !== e && (e.lifecycle = Fs.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (s) {
      this._handleError("update", s, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Fs.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Fs.FINALIZED;
    } catch (s) {
      this._handleError("finalization", s, e);
    }
  }
}
function Je(t, e, s) {
  if (t === e)
    return !0;
  if (!s || !t || !e)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (!Je(t[n], e[n], s - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof t == "object" && typeof e == "object") {
    const n = Object.keys(t), r = Object.keys(e);
    if (n.length !== r.length)
      return !1;
    for (const i of n)
      if (!e.hasOwnProperty(i) || !Je(t[i], e[i], s - 1))
        return !1;
    return !0;
  }
  return !1;
}
class _S {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const s = this.controllers[e];
      s && s.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const s = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), s;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const s = this.controllers[e];
      s && s.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((s) => s.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((s) => {
      e[s.id] = s;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((s) => s.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const s = typeof e == "string" ? this.getView(e) : e, n = s && this.viewState[s.getViewStateId()] || this.viewState;
    return s ? s.filterViewState(n) : n;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, s) {
    const n = this.getViewports(), r = { x: e[0], y: e[1] };
    for (let i = n.length - 1; i >= 0; --i) {
      const o = n[i];
      if (o.containsPixel(r)) {
        const a = e.slice();
        return a[0] -= o.x, a[1] -= o.y, o.unproject(a, s);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, s) {
    (e !== this.width || s !== this.height) && (this.width = e, this.height = s, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = nn(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Je(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : $.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, s) {
    const n = s.type;
    return new n({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (i) => this.getView(e.id)?.makeViewport({
        viewState: i,
        width: this.width,
        height: this.height
      })
    });
  }
  _updateController(e, s, n, r) {
    const i = e.controller;
    if (i && n) {
      const o = {
        ...s,
        ...i,
        id: e.id,
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height
      };
      return (!r || r.constructor !== i.type) && (r = this._createController(e, o)), r && r.setProps(o), r;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views: e } = this, s = this.controllers;
    this._viewports = [], this.controllers = {};
    let n = !1;
    for (let r = e.length; r--; ) {
      const i = e[r], o = this.getViewState(i), a = i.makeViewport({ viewState: o, width: this.width, height: this.height });
      let c = s[i.id];
      const l = !!i.controller;
      l && !c && (n = !0), (n || !l) && c && (c.finalize(), c = null), this.controllers[i.id] = this._updateController(i, o, a, c), a && this._viewports.unshift(a);
    }
    for (const r in s) {
      const i = s[r];
      i && !this.controllers[r] && i.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, s) {
    return e.length !== s.length ? !0 : e.some((n, r) => !e[r].equals(s[r]));
  }
}
const gS = /([0-9]+\.?[0-9]*)(%|px)/;
function Nt(t) {
  switch (typeof t) {
    case "number":
      return {
        position: t,
        relative: !1
      };
    case "string":
      const e = gS.exec(t);
      if (e && e.length >= 3) {
        const s = e[2] === "%", n = parseFloat(e[1]);
        return {
          position: s ? n / 100 : n,
          relative: s
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${t}`);
  }
}
function Ft(t, e) {
  return t.relative ? Math.round(t.position * e) : t.position;
}
class mS {
  constructor(e) {
    const { id: s, x: n = 0, y: r = 0, width: i = "100%", height: o = "100%", padding: a = null } = e;
    this.id = s || this.constructor.displayName || "view", this.props = { ...e, id: this.id }, this._x = Nt(n), this._y = Nt(r), this._width = Nt(i), this._height = Nt(o), this._padding = a && {
      left: Nt(a.left || 0),
      right: Nt(a.right || 0),
      top: Nt(a.top || 0),
      bottom: Nt(a.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.ViewportType === e.ViewportType && Je(this.props, e.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width: e, height: s, viewState: n }) {
    n = this.filterViewState(n);
    const r = this.getDimensions({ width: e, height: s });
    return !r.height || !r.width ? null : new this.ViewportType({ ...n, ...this.props, ...r });
  }
  getViewStateId() {
    const { viewState: e } = this.props;
    return typeof e == "string" ? e : e?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const s = { ...e };
      for (const n in this.props.viewState)
        n !== "id" && (s[n] = this.props.viewState[n]);
      return s;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width: e, height: s }) {
    const n = {
      x: Ft(this._x, e),
      y: Ft(this._y, s),
      width: Ft(this._width, e),
      height: Ft(this._height, s)
    };
    return this._padding && (n.padding = {
      left: Ft(this._padding.left, e),
      top: Ft(this._padding.top, s),
      right: Ft(this._padding.right, e),
      bottom: Ft(this._padding.bottom, s)
    }), n;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? { type: this.ControllerType } : typeof e == "function" ? { type: e } : { type: this.ControllerType, ...e } : null;
  }
}
class xi {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const { _timeline: e, settings: s } = this;
      this._handle = e.addChannel({
        delay: e.getTime(),
        duration: s.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const Hh = () => {
}, Ba = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, AS = (t) => t, TS = Ba.BREAK;
class yS {
  constructor(e) {
    this._onTransitionUpdate = (s) => {
      const { time: n, settings: { interpolator: r, startProps: i, endProps: o, duration: a, easing: c } } = s, l = c(n / a), h = r.interpolateProps(i, o, l);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...h
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new xi(e.timeline), this.onViewStateChange = e.onViewStateChange || Hh, this.onStateChange = e.onStateChange || Hh;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let s = !1;
    const n = this.props;
    if (this.props = e, !n || this._shouldIgnoreViewportChange(n, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let r = n;
      if (this.transition.inProgress) {
        const { interruption: i, endProps: o } = this.transition.settings;
        r = {
          ...n,
          ...i === Ba.SNAP_TO_END ? o : this.propsInTransition || n
        };
      }
      this._triggerTransition(r, e), s = !0;
    } else
      this.transition.cancel();
    return s;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const { transitionDuration: s, transitionInterpolator: n } = e;
    return (s > 0 || s === "auto") && !!n;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, s) {
    return this.transition.inProgress ? this.transition.settings.interruption === Ba.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(s) : this._isTransitionEnabled(s) ? s.transitionInterpolator.arePropsEqual(e, s) : !0;
  }
  _triggerTransition(e, s) {
    const n = this.getControllerState(e), r = this.getControllerState(s).shortestPathFrom(n), i = s.transitionInterpolator, o = i.getDuration ? i.getDuration(e, s) : s.transitionDuration;
    if (o === 0)
      return;
    const a = i.initializeProps(e, r);
    this.propsInTransition = {};
    const c = {
      duration: o,
      easing: s.transitionEasing || AS,
      interpolator: i,
      interruption: s.transitionInterruption || TS,
      startProps: a.start,
      endProps: a.end,
      onStart: s.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(s.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(s.onTransitionEnd)
    };
    this.transition.start(c), this.onStateChange({ inTransition: !0 }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (s) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e?.(s);
    };
  }
}
function ue(t, e) {
  if (!t)
    throw new Error(e || "deck.gl: assertion failed.");
}
class bS {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const { compare: s, extract: n, required: r } = e;
    this._propsToCompare = s, this._propsToExtract = n || s, this._requiredProps = r;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, s) {
    for (const n of this._propsToCompare)
      if (!(n in e) || !(n in s) || !Qe(e[n], s[n]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, s) {
    const n = {}, r = {};
    for (const i of this._propsToExtract)
      (i in e || i in s) && (n[i] = e[i], r[i] = s[i]);
    return this._checkRequiredProps(n), this._checkRequiredProps(r), { start: n, end: r };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, s) {
    return s.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((s) => {
      const n = e[s];
      ue(Number.isFinite(n) || Array.isArray(n), `${s} is required for transition`);
    });
  }
}
const ES = ["longitude", "latitude", "zoom", "bearing", "pitch"], CS = ["longitude", "latitude", "zoom"];
class Tp extends bS {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(e = {}) {
    const s = Array.isArray(e) ? e : e.transitionProps, n = Array.isArray(e) ? {} : e;
    n.transitionProps = Array.isArray(s) ? {
      compare: s,
      required: s
    } : s || {
      compare: ES,
      required: CS
    }, super(n.transitionProps), this.opts = n;
  }
  initializeProps(e, s) {
    const n = super.initializeProps(e, s), { makeViewport: r, around: i } = this.opts;
    if (r && i) {
      const o = r(e), a = r(s), c = o.unproject(i);
      n.start.around = i, Object.assign(n.end, {
        around: a.project(c),
        aroundPosition: c,
        width: s.width,
        height: s.height
      });
    }
    return n;
  }
  interpolateProps(e, s, n) {
    const r = {};
    for (const i of this._propsToExtract)
      r[i] = di(e[i] || 0, s[i] || 0, n);
    if (s.aroundPosition && this.opts.makeViewport) {
      const i = this.opts.makeViewport({ ...s, ...r });
      Object.assign(r, i.panByPosition(
        s.aroundPosition,
        // anchor point in current screen coordinates
        di(e.around, s.around, n)
      ));
    }
    return r;
  }
}
const Dt = {
  transitionDuration: 0
}, SS = 300, Nr = (t) => 1 - (1 - t) * (1 - t), Ps = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, rs = {};
class RS {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new yS({
      ...e,
      getControllerState: (s) => new this.ControllerState(s),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const e in this._events)
      this._events[e] && this.eventManager?.off(e, this.handleEvent);
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const s = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return s ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return s ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return s ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const { x: s, y: n } = this.props, { offsetCenter: r } = e;
    return [r.x - s, r.y - n];
  }
  isPointInBounds(e, s) {
    const { width: n, height: r } = this.props;
    if (s && s.handled)
      return !1;
    const i = e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= r;
    return i && s && s.stopPropagation(), i;
  }
  isFunctionKeyPressed(e) {
    const { srcEvent: s } = e;
    return !!(s.metaKey || s.altKey || s.ctrlKey || s.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const s = setTimeout(() => {
      this._eventStartBlocked === s && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = s;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const { inertia: s } = e;
    this.inertia = Number.isFinite(s) ? s : s === !0 ? SS : 0;
    const { scrollZoom: n = !0, dragPan: r = !0, dragRotate: i = !0, doubleClickZoom: o = !0, touchZoom: a = !0, touchRotate: c = !1, keyboard: l = !0 } = e, h = !!this.onViewStateChange;
    this.toggleEvents(Ps.WHEEL, h && n), this.toggleEvents(Ps.PAN, h), this.toggleEvents(Ps.PINCH, h && (a || c)), this.toggleEvents(Ps.TRIPLE_PAN, h && c), this.toggleEvents(Ps.DOUBLE_TAP, h && o), this.toggleEvents(Ps.KEYBOARD, h && l), this.scrollZoom = n, this.dragPan = r, this.dragRotate = i, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, s) {
    this.eventManager && e.forEach((n) => {
      this._events[n] !== s && (this._events[n] = s, s ? this.eventManager.on(n, this.handleEvent) : this.eventManager.off(n, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e, s = null, n = {}) {
    const r = { ...e.getViewportProps(), ...s }, i = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(n), i) {
      const o = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({ viewState: r, interactionState: this._interactionState, oldViewState: o, viewId: this.props.id });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({ ...e, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const s = this.getCenter(e);
    if (!this.isPointInBounds(s, e))
      return !1;
    let n = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (n = !n);
    const r = this.controllerState[n ? "panStart" : "rotateStart"]({
      pos: s
    });
    return this._panMove = n, this.updateViewport(r, Dt, { isDragging: !0 }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const s = this.getCenter(e), n = this.controllerState.pan({ pos: s });
    return this.updateViewport(n, Dt, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const { inertia: s } = this;
    if (this.dragPan && s && e.velocity) {
      const n = this.getCenter(e), r = [
        n[0] + e.velocityX * s / 2,
        n[1] + e.velocityY * s / 2
      ], i = this.controllerState.pan({ pos: r }).panEnd();
      this.updateViewport(i, {
        ...this._getTransitionProps(),
        transitionDuration: s,
        transitionEasing: Nr
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const n = this.controllerState.panEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const s = this.getCenter(e), n = this.controllerState.rotate({ pos: s });
    return this.updateViewport(n, Dt, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const { inertia: s } = this;
    if (this.dragRotate && s && e.velocity) {
      const n = this.getCenter(e), r = [
        n[0] + e.velocityX * s / 2,
        n[1] + e.velocityY * s / 2
      ], i = this.controllerState.rotate({ pos: r }).rotateEnd();
      this.updateViewport(i, {
        ...this._getTransitionProps(),
        transitionDuration: s,
        transitionEasing: Nr
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const s = this.getCenter(e);
    if (!this.isPointInBounds(s, e))
      return !1;
    e.srcEvent.preventDefault();
    const { speed: n = 0.01, smooth: r = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: i } = e;
    let o = 2 / (1 + Math.exp(-Math.abs(i * n)));
    i < 0 && o !== 0 && (o = 1 / o);
    const a = this.controllerState.zoom({ pos: s, scale: o });
    return this.updateViewport(a, { ...this._getTransitionProps({ around: s }), transitionDuration: r ? 250 : 1 }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const s = this.getCenter(e);
    if (!this.isPointInBounds(s, e))
      return !1;
    const n = this.controllerState.rotateStart({ pos: s });
    return this.updateViewport(n, Dt, { isDragging: !0 }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const s = this.getCenter(e);
    s[0] -= e.deltaX;
    const n = this.controllerState.rotate({ pos: s });
    return this.updateViewport(n, Dt, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: s } = this;
    if (this.touchRotate && s && e.velocityY) {
      const n = this.getCenter(e), r = [n[0], n[1] += e.velocityY * s / 2], i = this.controllerState.rotate({ pos: r });
      this.updateViewport(i, {
        ...this._getTransitionProps(),
        transitionDuration: s,
        transitionEasing: Nr
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(s);
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const s = this.getCenter(e);
    if (!this.isPointInBounds(s, e))
      return !1;
    const n = this.controllerState.zoomStart({ pos: s }).rotateStart({ pos: s });
    return rs._startPinchRotation = e.rotation, rs._lastPinchEvent = e, this.updateViewport(n, Dt, { isDragging: !0 }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let s = this.controllerState;
    if (this.touchZoom) {
      const { scale: n } = e, r = this.getCenter(e);
      s = s.zoom({ pos: r, scale: n });
    }
    if (this.touchRotate) {
      const { rotation: n } = e;
      s = s.rotate({
        deltaAngleX: rs._startPinchRotation - n
      });
    }
    return this.updateViewport(s, Dt, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), rs._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: s } = this, { _lastPinchEvent: n } = rs;
    if (this.touchZoom && s && n && e.scale !== n.scale) {
      const r = this.getCenter(e);
      let i = this.controllerState.rotateEnd();
      const o = Math.log2(e.scale), a = (o - Math.log2(n.scale)) / (e.deltaTime - n.deltaTime), c = Math.pow(2, o + a * s / 2);
      i = i.zoom({ pos: r, scale: c }).zoomEnd(), this.updateViewport(i, {
        ...this._getTransitionProps({ around: r }),
        transitionDuration: s,
        transitionEasing: Nr
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(s);
    } else {
      const r = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return rs._startPinchRotation = null, rs._lastPinchEvent = null, !0;
  }
  // Default handler for the `doubletap` event.
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const s = this.getCenter(e);
    if (!this.isPointInBounds(s, e))
      return !1;
    const n = this.isFunctionKeyPressed(e), r = this.controllerState.zoom({ pos: s, scale: n ? 0.5 : 2 });
    return this.updateViewport(r, this._getTransitionProps({ around: s }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const s = this.isFunctionKeyPressed(e), { zoomSpeed: n, moveSpeed: r, rotateSpeedX: i, rotateSpeedY: o } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: a } = this;
    let c;
    const l = {};
    switch (e.srcEvent.code) {
      case "Minus":
        c = s ? a.zoomOut(n).zoomOut(n) : a.zoomOut(n), l.isZooming = !0;
        break;
      case "Equal":
        c = s ? a.zoomIn(n).zoomIn(n) : a.zoomIn(n), l.isZooming = !0;
        break;
      case "ArrowLeft":
        s ? (c = a.rotateLeft(i), l.isRotating = !0) : (c = a.moveLeft(r), l.isPanning = !0);
        break;
      case "ArrowRight":
        s ? (c = a.rotateRight(i), l.isRotating = !0) : (c = a.moveRight(r), l.isPanning = !0);
        break;
      case "ArrowUp":
        s ? (c = a.rotateUp(o), l.isRotating = !0) : (c = a.moveUp(r), l.isPanning = !0);
        break;
      case "ArrowDown":
        s ? (c = a.rotateDown(o), l.isRotating = !0) : (c = a.moveDown(r), l.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(c, this._getTransitionProps(), l), !0;
  }
  _getTransitionProps(e) {
    const { transition: s } = this;
    return !s || !s.transitionInterpolator ? Dt : e ? {
      ...s,
      transitionInterpolator: new Tp({
        ...e,
        ...s.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : s;
  }
}
class wS {
  constructor(e, s) {
    this._viewportProps = this.applyConstraints(e), this._state = s;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const zh = 5, IS = 1.2;
class vS extends wS {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: s,
      /** The height of the viewport */
      height: n,
      /** The latitude at the center of the viewport */
      latitude: r,
      /** The longitude at the center of the viewport */
      longitude: i,
      /** The tile zoom level of the map. */
      zoom: o,
      /** The bearing of the viewport in degrees */
      bearing: a = 0,
      /** The pitch of the viewport in degrees */
      pitch: c = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: l = 1.5,
      /** Viewport position */
      position: h = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: u = 20,
      minZoom: f = 0,
      maxPitch: p = 60,
      minPitch: m = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: A,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: E,
      /* Pointer position when rotation started */
      startRotatePos: C,
      /** Bearing when current perspective rotate operation started */
      startBearing: w,
      /** Pitch when current perspective rotate operation started */
      startPitch: I,
      /** Zoom when current zoom operation started */
      startZoom: B,
      /** Normalize viewport props to fit map height into viewport */
      normalize: x = !0
    } = e;
    ue(Number.isFinite(i)), ue(Number.isFinite(r)), ue(Number.isFinite(o)), super({
      width: s,
      height: n,
      latitude: r,
      longitude: i,
      zoom: o,
      bearing: a,
      pitch: c,
      altitude: l,
      maxZoom: u,
      minZoom: f,
      maxPitch: p,
      minPitch: m,
      normalize: x,
      position: h
    }, {
      startPanLngLat: A,
      startZoomLngLat: E,
      startRotatePos: C,
      startBearing: w,
      startPitch: I,
      startZoom: B
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: e }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(e)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos: e, startPos: s }) {
    const n = this.getState().startPanLngLat || this._unproject(s);
    if (!n)
      return this;
    const i = this.makeViewport(this.getViewportProps()).panByPosition(n, e);
    return this._getUpdatedState(i);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos: e }) {
    return this._getUpdatedState({
      startRotatePos: e,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos: e, deltaAngleX: s = 0, deltaAngleY: n = 0 }) {
    const { startRotatePos: r, startBearing: i, startPitch: o } = this.getState();
    if (!r || i === void 0 || o === void 0)
      return this;
    let a;
    return e ? a = this._getNewRotation(e, r, o, i) : a = {
      bearing: i + s,
      pitch: o + n
    }, this._getUpdatedState(a);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos: e }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(e),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: e, startPos: s, scale: n }) {
    let { startZoom: r, startZoomLngLat: i } = this.getState();
    if (i || (r = this.getViewportProps().zoom, i = this._unproject(s) || this._unproject(e)), !i)
      return this;
    const { maxZoom: o, minZoom: a } = this.getViewportProps();
    let c = r + Math.log2(n);
    c = wt(c, a, o);
    const l = this.makeViewport({ ...this.getViewportProps(), zoom: c });
    return this._getUpdatedState({
      zoom: c,
      ...l.panByPosition(i, e)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(e = 2) {
    return this._zoomFromCenter(e);
  }
  zoomOut(e = 2) {
    return this._zoomFromCenter(1 / e);
  }
  moveLeft(e = 100) {
    return this._panFromCenter([e, 0]);
  }
  moveRight(e = 100) {
    return this._panFromCenter([-e, 0]);
  }
  moveUp(e = 100) {
    return this._panFromCenter([0, e]);
  }
  moveDown(e = 100) {
    return this._panFromCenter([0, -e]);
  }
  rotateLeft(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const s = e.getViewportProps(), n = { ...this.getViewportProps() }, { bearing: r, longitude: i } = n;
    return Math.abs(r - s.bearing) > 180 && (n.bearing = r < 0 ? r + 360 : r - 360), Math.abs(i - s.longitude) > 180 && (n.longitude = i < 0 ? i + 360 : i - 360), n;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const { maxZoom: s, minZoom: n, zoom: r } = e;
    e.zoom = wt(r, n, s);
    const { maxPitch: i, minPitch: o, pitch: a } = e;
    e.pitch = wt(a, o, i);
    const { normalize: c = !0 } = e;
    return c && Object.assign(e, lC(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const { width: s, height: n } = this.getViewportProps();
    return this.zoom({
      pos: [s / 2, n / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const { width: s, height: n } = this.getViewportProps();
    return this.pan({
      startPos: [s / 2, n / 2],
      pos: [s / 2 + e[0], n / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const s = this.makeViewport(this.getViewportProps());
    return e && s.unproject(e);
  }
  _getNewRotation(e, s, n, r) {
    const i = e[0] - s[0], o = e[1] - s[1], a = e[1], c = s[1], { width: l, height: h } = this.getViewportProps(), u = i / l;
    let f = 0;
    o > 0 ? Math.abs(h - c) > zh && (f = o / (c - h) * IS) : o < 0 && c > zh && (f = 1 - a / c), f = wt(f, -1, 1);
    const { minPitch: p, maxPitch: m } = this.getViewportProps(), A = r + 180 * u;
    let E = n;
    return f > 0 ? E = n + f * (m - n) : f < 0 && (E = n - f * (p - n)), {
      pitch: E,
      bearing: A
    };
  }
}
class BS extends RS {
  constructor() {
    super(...arguments), this.ControllerState = vS, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new Tp({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const s = this.props;
    super.setProps(e), (!s || s.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class Fc extends mS {
  constructor(e = {}) {
    super(e);
  }
  get ViewportType() {
    return ms;
  }
  get ControllerType() {
    return BS;
  }
}
Fc.displayName = "MapView";
const MS = new pp();
function PS(t, e) {
  const s = t.order ?? 1 / 0, n = e.order ?? 1 / 0;
  return s - n;
}
class OS {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const s = this._defaultEffects;
    if (!s.find((n) => n.id === e.id)) {
      const n = s.findIndex((r) => PS(r, e) > 0);
      n < 0 ? s.push(e) : s.splice(n, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Je(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const s = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), s;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const s = {};
    for (const r of this.effects)
      s[r.id] = r;
    const n = [];
    for (const r of e) {
      const i = s[r.id];
      let o = r;
      i && i !== r ? i.setProps ? (i.setProps(r.props), o = i) : i.cleanup(this._context) : i || r.setup(this._context), n.push(o), delete s[r.id];
    }
    for (const r in s)
      s[r].cleanup(this._context);
    this.effects = n, this._resolvedEffects = n.concat(this._defaultEffects), e.some((r) => r instanceof pp) || this._resolvedEffects.push(MS), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class xS extends Oc {
  shouldDrawLayer(e) {
    const { operation: s } = e.props;
    return s.includes("draw") || s.includes("terrain");
  }
}
const NS = "deckRenderer.renderLayers";
class FS {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new xS(e), this.pickLayersPass = new mp(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const s = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, n = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    n.effects && this._preRender(n.effects, n);
    const r = this.lastPostProcessEffect ? this.renderBuffers[0] : n.target;
    this.lastPostProcessEffect && (n.clearColor = [0, 0, 0, 0], n.clearCanvas = !0);
    const i = s.render({ ...n, target: r });
    n.effects && this._postRender(n.effects, n), this.renderCount++, Te(NS, this, i, e);
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const s = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), s;
  }
  finalize() {
    const { renderBuffers: e } = this;
    for (const s of e)
      s.delete();
    e.length = 0;
  }
  _preRender(e, s) {
    this.lastPostProcessEffect = null, s.preRenderStats = s.preRenderStats || {};
    for (const n of e)
      s.preRenderStats[n.id] = n.preRender(s), n.postRender && (this.lastPostProcessEffect = n.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const { renderBuffers: e } = this, s = this.device.canvasContext.getDrawingBufferSize();
    e.length === 0 && [0, 1].map((n) => {
      const r = this.device.createTexture({
        sampler: { minFilter: "linear", magFilter: "linear" }
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${n}`,
        colorAttachments: [r]
      }));
    });
    for (const n of e)
      n.resize(s);
  }
  _postRender(e, s) {
    const { renderBuffers: n } = this, r = {
      ...s,
      inputBuffer: n[0],
      swapBuffer: n[1]
    };
    for (const i of e)
      if (i.postRender) {
        r.target = i.id === this.lastPostProcessEffect ? s.target : void 0;
        const o = i.postRender(r);
        r.inputBuffer = o, r.swapBuffer = o === n[0] ? n[1] : n[0];
      }
  }
}
const DS = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function US({ pickedColors: t, decodePickingColor: e, deviceX: s, deviceY: n, deviceRadius: r, deviceRect: i }) {
  const { x: o, y: a, width: c, height: l } = i;
  let h = r * r, u = -1, f = 0;
  for (let p = 0; p < l; p++) {
    const m = p + a - n, A = m * m;
    if (A > h)
      f += 4 * c;
    else
      for (let E = 0; E < c; E++) {
        if (t[f + 3] - 1 >= 0) {
          const w = E + o - s, I = w * w + A;
          I <= h && (h = I, u = f);
        }
        f += 4;
      }
  }
  if (u >= 0) {
    const p = t.slice(u, u + 4), m = e(p);
    if (m) {
      const A = Math.floor(u / 4 / c), E = u / 4 - A * c;
      return {
        ...m,
        pickedColor: p,
        pickedX: o + E,
        pickedY: a + A
      };
    }
    $.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return DS;
}
function LS({ pickedColors: t, decodePickingColor: e }) {
  const s = /* @__PURE__ */ new Map();
  if (t) {
    for (let n = 0; n < t.length; n += 4)
      if (t[n + 3] - 1 >= 0) {
        const i = t.slice(n, n + 4), o = i.join(",");
        if (!s.has(o)) {
          const a = e(i);
          a ? s.set(o, {
            ...a,
            color: i
          }) : $.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(s.values());
}
function yp({ pickInfo: t, viewports: e, pixelRatio: s, x: n, y: r, z: i }) {
  let o = e[0];
  e.length > 1 && (o = VS(t?.pickedViewports || e, { x: n, y: r }));
  let a;
  if (o) {
    const c = [n - o.x, r - o.y];
    i !== void 0 && (c[2] = i), a = o.unproject(c);
  }
  return {
    color: null,
    layer: null,
    viewport: o,
    index: -1,
    picked: !1,
    x: n,
    y: r,
    pixel: [n, r],
    coordinate: a,
    devicePixel: t && "pickedX" in t ? [t.pickedX, t.pickedY] : void 0,
    pixelRatio: s
  };
}
function kS(t) {
  const { pickInfo: e, lastPickedInfo: s, mode: n, layers: r } = t, { pickedColor: i, pickedLayer: o, pickedObjectIndex: a } = e, c = o ? [o] : [];
  if (n === "hover") {
    const u = s.index, f = s.layerId, p = o ? o.props.id : null;
    if (p !== f || a !== u) {
      if (p !== f) {
        const m = r.find((A) => A.props.id === f);
        m && c.unshift(m);
      }
      s.layerId = p, s.index = a, s.info = null;
    }
  }
  const l = yp(t), h = /* @__PURE__ */ new Map();
  return h.set(null, l), c.forEach((u) => {
    let f = { ...l };
    u === o && (f.color = i, f.index = a, f.picked = !0), f = bp({ layer: u, info: f, mode: n });
    const p = f.layer;
    u === o && n === "hover" && (s.info = f), h.set(p.id, f), n === "hover" && p.updateAutoHighlight(f);
  }), h;
}
function bp({ layer: t, info: e, mode: s }) {
  for (; t && e; ) {
    const n = e.layer || null;
    e.sourceLayer = n, e.layer = t, e = t.getPickingInfo({ info: e, mode: s, sourceLayer: n }), t = t.parent;
  }
  return e;
}
function VS(t, e) {
  for (let s = t.length - 1; s >= 0; s--) {
    const n = t[s];
    if (n.containsPixel(e))
      return n;
  }
  return t[0];
}
class HS {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new mp(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: e, y: s, layers: n, viewports: r }, i = this.lastPickedInfo.info) {
    const o = i && i.layer && i.layer.id, a = i && i.viewport && i.viewport.id, c = o ? n.find((f) => f.id === o) : null, l = a && r.find((f) => f.id === a) || r[0], h = l && l.unproject([e - l.x, s - l.y]);
    return { ...i, ...{
      x: e,
      y: s,
      viewport: l,
      coordinate: h,
      layer: c
    } };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const s = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = s;
    }
    const { canvas: e } = this.device.getCanvasContext();
    this.pickingFBO?.resize({ width: e.width, height: e.height }), this.depthFBO?.resize({ width: e.width, height: e.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const s = e.filter((n) => this.pickLayersPass.shouldDrawLayer(n) && !n.isComposite);
    return s.length ? s : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers: e, views: s, viewports: n, x: r, y: i, radius: o = 0, depth: a = 1, mode: c = "query", unproject3D: l, onViewportActive: h, effects: u }) {
    const f = this.device.canvasContext.cssToDeviceRatio(), p = this._getPickable(e);
    if (!p || n.length === 0)
      return {
        result: [],
        emptyInfo: yp({ viewports: n, x: r, y: i, pixelRatio: f })
      };
    this._resizeBuffer();
    const m = this.device.canvasContext.cssToDevicePixels([r, i], !0), A = [
      m.x + Math.floor(m.width / 2),
      m.y + Math.floor(m.height / 2)
    ], E = Math.round(o * f), { width: C, height: w } = this.pickingFBO, I = this._getPickingRect({
      deviceX: A[0],
      deviceY: A[1],
      deviceRadius: E,
      deviceWidth: C,
      deviceHeight: w
    }), B = {
      x: r - o,
      y: i - o,
      width: o * 2 + 1,
      height: o * 2 + 1
    };
    let x;
    const N = [], L = /* @__PURE__ */ new Set();
    for (let k = 0; k < a; k++) {
      let F;
      if (I) {
        const H = this._drawAndSample({
          layers: p,
          views: s,
          viewports: n,
          onViewportActive: h,
          deviceRect: I,
          cullRect: B,
          effects: u,
          pass: `picking:${c}`
        });
        F = US({
          ...H,
          deviceX: A[0],
          deviceY: A[1],
          deviceRadius: E,
          deviceRect: I
        });
      } else
        F = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let U;
      if (F.pickedLayer && l && this.depthFBO) {
        const { pickedColors: H } = this._drawAndSample({
          layers: [F.pickedLayer],
          views: s,
          viewports: n,
          onViewportActive: h,
          deviceRect: {
            x: F.pickedX,
            y: F.pickedY,
            width: 1,
            height: 1
          },
          cullRect: B,
          effects: u,
          pass: `picking:${c}:z`
        }, !0);
        H[3] && (U = H[0]);
      }
      F.pickedLayer && k + 1 < a && (L.add(F.pickedLayer), F.pickedLayer.disablePickingIndex(F.pickedObjectIndex)), x = kS({
        pickInfo: F,
        lastPickedInfo: this.lastPickedInfo,
        mode: c,
        layers: p,
        viewports: n,
        x: r,
        y: i,
        z: U,
        pixelRatio: f
      });
      for (const H of x.values())
        H.layer && N.push(H);
      if (!F.pickedColor)
        break;
    }
    for (const k of L)
      k.restorePickingColors();
    return { result: N, emptyInfo: x.get(null) };
  }
  /** Pick all objects within the given bounding box */
  _pickVisibleObjects({ layers: e, views: s, viewports: n, x: r, y: i, width: o = 1, height: a = 1, mode: c = "query", maxObjects: l = null, onViewportActive: h, effects: u }) {
    const f = this._getPickable(e);
    if (!f || n.length === 0)
      return [];
    this._resizeBuffer();
    const p = this.device.canvasContext.cssToDeviceRatio(), m = this.device.canvasContext.cssToDevicePixels([r, i], !0), A = m.x, E = m.y + m.height, C = this.device.canvasContext.cssToDevicePixels([r + o, i + a], !0), w = C.x + C.width, I = C.y, B = {
      x: A,
      y: I,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: w - A,
      height: E - I
    }, x = this._drawAndSample({
      layers: f,
      views: s,
      viewports: n,
      onViewportActive: h,
      deviceRect: B,
      cullRect: { x: r, y: i, width: o, height: a },
      effects: u,
      pass: `picking:${c}`
    }), N = LS(x), L = /* @__PURE__ */ new Map(), k = [], F = Number.isFinite(l);
    for (let U = 0; U < N.length && !(F && k.length >= l); U++) {
      const H = N[U];
      let Y = {
        color: H.pickedColor,
        layer: null,
        index: H.pickedObjectIndex,
        picked: !0,
        x: r,
        y: i,
        pixelRatio: p
      };
      Y = bp({ layer: H.pickedLayer, info: Y, mode: c });
      const te = Y.layer.id;
      L.has(te) || L.set(te, /* @__PURE__ */ new Set());
      const z = L.get(te), me = Y.object ?? Y.index;
      z.has(me) || (z.add(me), k.push(Y));
    }
    return k;
  }
  _drawAndSample({ layers: e, views: s, viewports: n, onViewportActive: r, deviceRect: i, cullRect: o, effects: a, pass: c }, l = !1) {
    const h = l ? this.depthFBO : this.pickingFBO, u = {
      layers: e,
      layerFilter: this.layerFilter,
      views: s,
      viewports: n,
      onViewportActive: r,
      pickingFBO: h,
      deviceRect: i,
      cullRect: o,
      effects: a,
      pass: c,
      pickZ: l,
      preRenderStats: {}
    };
    for (const w of a)
      w.useInPicking && (u.preRenderStats[w.id] = w.preRender(u));
    const { decodePickingColor: f } = this.pickLayersPass.render(u), { x: p, y: m, width: A, height: E } = i, C = new (l ? Float32Array : Uint8Array)(A * E * 4);
    return this.device.readPixelsToArrayWebGL(h, {
      sourceX: p,
      sourceY: m,
      sourceWidth: A,
      sourceHeight: E,
      target: C
    }), { pickedColors: C, decodePickingColor: f };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX: e, deviceY: s, deviceRadius: n, deviceWidth: r, deviceHeight: i }) {
    const o = Math.max(0, e - n), a = Math.max(0, s - n), c = Math.min(r, e + n + 1) - o, l = Math.min(i, s + n + 1) - a;
    return c <= 0 || l <= 0 ? null : { x: o, y: a, width: c, height: l };
  }
}
const zS = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
}, jS = "top-left", jh = "__root";
class WS {
  constructor({ deck: e, parentElement: s }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = s;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    e.widgets && !Je(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
  }
  finalize() {
    for (const e of this.getWidgets())
      this._remove(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((s) => s.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(e) {
    const s = {};
    for (const n of this.resolvedWidgets)
      s[n.id] = n;
    this.resolvedWidgets.length = 0;
    for (const n of this.defaultWidgets)
      s[n.id] = null, this.resolvedWidgets.push(n);
    for (let n of e) {
      const r = s[n.id];
      r ? /* Widget placement changed */ r.viewId !== n.viewId || r.placement !== n.placement ? (this._remove(r), this._add(n)) : n !== r && (r.setProps(n.props), n = r) : this._add(n), s[n.id] = null, this.resolvedWidgets.push(n);
    }
    for (const n in s) {
      const r = s[n];
      r && this._remove(r);
    }
    this.widgets = e;
  }
  _add(e) {
    const { viewId: s = null, placement: n = jS } = e, r = e.onAdd({ deck: this.deck, viewId: s });
    r && this._getContainer(s, n).append(r), e._element = r;
  }
  _remove(e) {
    e.onRemove(), e._element && e._element.remove(), e._element = void 0;
  }
  /* global document */
  _getContainer(e, s) {
    const n = e || jh;
    let r = this.containers[n];
    r || (r = document.createElement("div"), r.style.pointerEvents = "none", r.style.position = "absolute", r.style.overflow = "hidden", this.parentElement?.append(r), this.containers[n] = r);
    let i = r.querySelector(`.${s}`);
    return i || (i = document.createElement("div"), i.className = s, i.style.position = "absolute", i.style.zIndex = "2", Object.assign(i.style, zS[s]), r.append(i)), i;
  }
  _updateContainers() {
    const e = this.deck.width, s = this.deck.height;
    for (const n in this.containers) {
      const r = this.lastViewports[n] || null, i = n === jh || r, o = this.containers[n];
      i ? (o.style.display = "block", o.style.left = `${r ? r.x : 0}px`, o.style.top = `${r ? r.y : 0}px`, o.style.width = `${r ? r.width : e}px`, o.style.height = `${r ? r.height : s}px`) : o.style.display = "none";
    }
  }
  onRedraw({ viewports: e, layers: s }) {
    const n = e.reduce((i, o) => (i[o.id] = o, i), {}), { lastViewports: r } = this;
    for (const i of this.getWidgets()) {
      const { viewId: o } = i;
      if (o) {
        const a = n[o];
        a && (i.onViewportChange && !a.equals(r[o]) && i.onViewportChange(a), i.onRedraw?.({ viewports: [a], layers: s }));
      } else {
        if (i.onViewportChange)
          for (const a of e)
            a.equals(r[a.id]) || i.onViewportChange(a);
        i.onRedraw?.({ viewports: e, layers: s });
      }
    }
    this.lastViewports = n, this._updateContainers();
  }
  onHover(e, s) {
    for (const n of this.getWidgets()) {
      const { viewId: r } = n;
      (!r || r === e.viewport?.id) && n.onHover?.(e, s);
    }
  }
  onEvent(e, s) {
    const n = Sa[s.type];
    if (n)
      for (const r of this.getWidgets()) {
        const { viewId: i } = r;
        (!i || i === e.viewport?.id) && r[n.handler]?.(e, s);
      }
  }
}
const XS = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class GS {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd({ deck: e }) {
    const s = document.createElement("div");
    return s.className = "deck-tooltip", Object.assign(s.style, XS), this.deck = e, this.element = s, s;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(e) {
    this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const { deck: s } = this, n = s && s.props.getTooltip;
    if (!n)
      return;
    const r = n(e);
    this.lastViewport = e.viewport, this.setTooltip(r, e.x, e.y);
  }
  setTooltip(e, s, n) {
    const r = this.element;
    if (r) {
      if (typeof e == "string")
        r.innerText = e;
      else if (e)
        e.text && (r.innerText = e.text), e.html && (r.innerHTML = e.html), e.className && (r.className = e.className);
      else {
        this.isVisible = !1, r.style.display = "none";
        return;
      }
      this.isVisible = !0, r.style.display = "block", r.style.transform = `translate(${s}px, ${n}px)`, e && typeof e == "object" && "style" in e && Object.assign(r.style, e.style);
    }
  }
}
var Ls;
(function(t) {
  t[t.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", t[t.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", t[t.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_COLOR = 768] = "SRC_COLOR", t[t.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.DST_ALPHA = 772] = "DST_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", t[t.DST_COLOR = 774] = "DST_COLOR", t[t.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", t[t.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", t[t.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", t[t.BLEND_EQUATION = 32777] = "BLEND_EQUATION", t[t.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", t[t.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", t[t.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", t[t.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", t[t.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", t[t.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", t[t.BLEND_COLOR = 32773] = "BLEND_COLOR", t[t.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", t[t.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", t[t.LINE_WIDTH = 2849] = "LINE_WIDTH", t[t.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", t[t.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", t[t.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", t[t.FRONT_FACE = 2886] = "FRONT_FACE", t[t.DEPTH_RANGE = 2928] = "DEPTH_RANGE", t[t.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", t[t.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", t[t.DEPTH_FUNC = 2932] = "DEPTH_FUNC", t[t.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", t[t.STENCIL_FUNC = 2962] = "STENCIL_FUNC", t[t.STENCIL_FAIL = 2964] = "STENCIL_FAIL", t[t.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", t[t.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", t[t.STENCIL_REF = 2967] = "STENCIL_REF", t[t.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", t[t.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", t[t.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", t[t.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", t[t.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", t[t.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", t[t.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", t[t.VIEWPORT = 2978] = "VIEWPORT", t[t.SCISSOR_BOX = 3088] = "SCISSOR_BOX", t[t.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", t[t.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", t[t.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", t[t.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", t[t.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", t[t.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", t[t.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", t[t.RED_BITS = 3410] = "RED_BITS", t[t.GREEN_BITS = 3411] = "GREEN_BITS", t[t.BLUE_BITS = 3412] = "BLUE_BITS", t[t.ALPHA_BITS = 3413] = "ALPHA_BITS", t[t.DEPTH_BITS = 3414] = "DEPTH_BITS", t[t.STENCIL_BITS = 3415] = "STENCIL_BITS", t[t.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", t[t.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", t[t.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", t[t.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", t[t.SAMPLES = 32937] = "SAMPLES", t[t.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", t[t.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", t[t.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", t[t.VENDOR = 7936] = "VENDOR", t[t.RENDERER = 7937] = "RENDERER", t[t.VERSION = 7938] = "VERSION", t[t.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", t[t.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", t[t.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", t[t.STATIC_DRAW = 35044] = "STATIC_DRAW", t[t.STREAM_DRAW = 35040] = "STREAM_DRAW", t[t.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.BUFFER_SIZE = 34660] = "BUFFER_SIZE", t[t.BUFFER_USAGE = 34661] = "BUFFER_USAGE", t[t.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", t[t.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", t[t.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", t[t.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", t[t.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", t[t.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", t[t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", t[t.CULL_FACE = 2884] = "CULL_FACE", t[t.FRONT = 1028] = "FRONT", t[t.BACK = 1029] = "BACK", t[t.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", t[t.BLEND = 3042] = "BLEND", t[t.DEPTH_TEST = 2929] = "DEPTH_TEST", t[t.DITHER = 3024] = "DITHER", t[t.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", t[t.SCISSOR_TEST = 3089] = "SCISSOR_TEST", t[t.STENCIL_TEST = 2960] = "STENCIL_TEST", t[t.NO_ERROR = 0] = "NO_ERROR", t[t.INVALID_ENUM = 1280] = "INVALID_ENUM", t[t.INVALID_VALUE = 1281] = "INVALID_VALUE", t[t.INVALID_OPERATION = 1282] = "INVALID_OPERATION", t[t.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", t[t.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", t[t.CW = 2304] = "CW", t[t.CCW = 2305] = "CCW", t[t.DONT_CARE = 4352] = "DONT_CARE", t[t.FASTEST = 4353] = "FASTEST", t[t.NICEST = 4354] = "NICEST", t[t.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", t[t.BYTE = 5120] = "BYTE", t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.SHORT = 5122] = "SHORT", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.INT = 5124] = "INT", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.FLOAT = 5126] = "FLOAT", t[t.DOUBLE = 5130] = "DOUBLE", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.ALPHA = 6406] = "ALPHA", t[t.RGB = 6407] = "RGB", t[t.RGBA = 6408] = "RGBA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", t[t.VERTEX_SHADER = 35633] = "VERTEX_SHADER", t[t.COMPILE_STATUS = 35713] = "COMPILE_STATUS", t[t.DELETE_STATUS = 35712] = "DELETE_STATUS", t[t.LINK_STATUS = 35714] = "LINK_STATUS", t[t.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", t[t.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", t[t.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", t[t.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", t[t.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", t[t.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", t[t.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", t[t.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", t[t.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", t[t.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", t[t.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", t[t.SHADER_TYPE = 35663] = "SHADER_TYPE", t[t.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", t[t.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", t[t.NEVER = 512] = "NEVER", t[t.LESS = 513] = "LESS", t[t.EQUAL = 514] = "EQUAL", t[t.LEQUAL = 515] = "LEQUAL", t[t.GREATER = 516] = "GREATER", t[t.NOTEQUAL = 517] = "NOTEQUAL", t[t.GEQUAL = 518] = "GEQUAL", t[t.ALWAYS = 519] = "ALWAYS", t[t.KEEP = 7680] = "KEEP", t[t.REPLACE = 7681] = "REPLACE", t[t.INCR = 7682] = "INCR", t[t.DECR = 7683] = "DECR", t[t.INVERT = 5386] = "INVERT", t[t.INCR_WRAP = 34055] = "INCR_WRAP", t[t.DECR_WRAP = 34056] = "DECR_WRAP", t[t.NEAREST = 9728] = "NEAREST", t[t.LINEAR = 9729] = "LINEAR", t[t.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", t[t.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", t[t.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", t[t.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE = 5890] = "TEXTURE", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t[t.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", t[t.TEXTURE0 = 33984] = "TEXTURE0", t[t.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", t[t.REPEAT = 10497] = "REPEAT", t[t.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t[t.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", t[t.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", t[t.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", t[t.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", t[t.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", t[t.INT_VEC2 = 35667] = "INT_VEC2", t[t.INT_VEC3 = 35668] = "INT_VEC3", t[t.INT_VEC4 = 35669] = "INT_VEC4", t[t.BOOL = 35670] = "BOOL", t[t.BOOL_VEC2 = 35671] = "BOOL_VEC2", t[t.BOOL_VEC3 = 35672] = "BOOL_VEC3", t[t.BOOL_VEC4 = 35673] = "BOOL_VEC4", t[t.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", t[t.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", t[t.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", t[t.SAMPLER_2D = 35678] = "SAMPLER_2D", t[t.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", t[t.LOW_FLOAT = 36336] = "LOW_FLOAT", t[t.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", t[t.HIGH_FLOAT = 36338] = "HIGH_FLOAT", t[t.LOW_INT = 36339] = "LOW_INT", t[t.MEDIUM_INT = 36340] = "MEDIUM_INT", t[t.HIGH_INT = 36341] = "HIGH_INT", t[t.FRAMEBUFFER = 36160] = "FRAMEBUFFER", t[t.RENDERBUFFER = 36161] = "RENDERBUFFER", t[t.RGBA4 = 32854] = "RGBA4", t[t.RGB5_A1 = 32855] = "RGB5_A1", t[t.RGB565 = 36194] = "RGB565", t[t.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", t[t.STENCIL_INDEX = 6401] = "STENCIL_INDEX", t[t.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t[t.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", t[t.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", t[t.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", t[t.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", t[t.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", t[t.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", t[t.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", t[t.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", t[t.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", t[t.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", t[t.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", t[t.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", t[t.NONE = 0] = "NONE", t[t.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", t[t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", t[t.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", t[t.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", t[t.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", t[t.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", t[t.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", t[t.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", t[t.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", t[t.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", t[t.READ_BUFFER = 3074] = "READ_BUFFER", t[t.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", t[t.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", t[t.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", t[t.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", t[t.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", t[t.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", t[t.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", t[t.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", t[t.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", t[t.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", t[t.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", t[t.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", t[t.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", t[t.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", t[t.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", t[t.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", t[t.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", t[t.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", t[t.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", t[t.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", t[t.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", t[t.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", t[t.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", t[t.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", t[t.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", t[t.RED = 6403] = "RED", t[t.RGB8 = 32849] = "RGB8", t[t.RGBA8 = 32856] = "RGBA8", t[t.RGB10_A2 = 32857] = "RGB10_A2", t[t.TEXTURE_3D = 32879] = "TEXTURE_3D", t[t.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", t[t.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", t[t.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", t[t.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", t[t.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", t[t.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", t[t.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", t[t.SRGB = 35904] = "SRGB", t[t.SRGB8 = 35905] = "SRGB8", t[t.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", t[t.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", t[t.RGBA32F = 34836] = "RGBA32F", t[t.RGB32F = 34837] = "RGB32F", t[t.RGBA16F = 34842] = "RGBA16F", t[t.RGB16F = 34843] = "RGB16F", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", t[t.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", t[t.RGB9_E5 = 35901] = "RGB9_E5", t[t.RGBA32UI = 36208] = "RGBA32UI", t[t.RGB32UI = 36209] = "RGB32UI", t[t.RGBA16UI = 36214] = "RGBA16UI", t[t.RGB16UI = 36215] = "RGB16UI", t[t.RGBA8UI = 36220] = "RGBA8UI", t[t.RGB8UI = 36221] = "RGB8UI", t[t.RGBA32I = 36226] = "RGBA32I", t[t.RGB32I = 36227] = "RGB32I", t[t.RGBA16I = 36232] = "RGBA16I", t[t.RGB16I = 36233] = "RGB16I", t[t.RGBA8I = 36238] = "RGBA8I", t[t.RGB8I = 36239] = "RGB8I", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.R8 = 33321] = "R8", t[t.RG8 = 33323] = "RG8", t[t.R16F = 33325] = "R16F", t[t.R32F = 33326] = "R32F", t[t.RG16F = 33327] = "RG16F", t[t.RG32F = 33328] = "RG32F", t[t.R8I = 33329] = "R8I", t[t.R8UI = 33330] = "R8UI", t[t.R16I = 33331] = "R16I", t[t.R16UI = 33332] = "R16UI", t[t.R32I = 33333] = "R32I", t[t.R32UI = 33334] = "R32UI", t[t.RG8I = 33335] = "RG8I", t[t.RG8UI = 33336] = "RG8UI", t[t.RG16I = 33337] = "RG16I", t[t.RG16UI = 33338] = "RG16UI", t[t.RG32I = 33339] = "RG32I", t[t.RG32UI = 33340] = "RG32UI", t[t.R8_SNORM = 36756] = "R8_SNORM", t[t.RG8_SNORM = 36757] = "RG8_SNORM", t[t.RGB8_SNORM = 36758] = "RGB8_SNORM", t[t.RGBA8_SNORM = 36759] = "RGBA8_SNORM", t[t.RGB10_A2UI = 36975] = "RGB10_A2UI", t[t.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", t[t.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.HALF_FLOAT = 5131] = "HALF_FLOAT", t[t.RG = 33319] = "RG", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", t[t.CURRENT_QUERY = 34917] = "CURRENT_QUERY", t[t.QUERY_RESULT = 34918] = "QUERY_RESULT", t[t.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", t[t.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", t[t.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", t[t.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", t[t.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", t[t.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", t[t.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", t[t.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", t[t.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", t[t.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", t[t.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", t[t.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", t[t.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", t[t.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", t[t.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", t[t.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", t[t.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", t[t.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", t[t.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", t[t.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", t[t.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", t[t.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", t[t.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", t[t.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", t[t.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", t[t.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", t[t.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", t[t.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", t[t.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", t[t.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", t[t.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", t[t.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", t[t.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", t[t.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", t[t.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", t[t.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", t[t.SAMPLER_3D = 35679] = "SAMPLER_3D", t[t.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", t[t.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", t[t.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", t[t.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", t[t.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", t[t.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", t[t.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", t[t.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", t[t.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", t[t.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", t[t.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", t[t.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", t[t.MAX_SAMPLES = 36183] = "MAX_SAMPLES", t[t.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", t[t.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", t[t.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", t[t.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", t[t.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", t[t.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", t[t.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", t[t.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", t[t.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", t[t.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", t[t.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", t[t.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", t[t.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", t[t.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", t[t.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", t[t.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", t[t.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", t[t.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", t[t.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", t[t.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", t[t.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", t[t.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", t[t.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", t[t.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", t[t.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", t[t.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", t[t.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", t[t.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", t[t.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", t[t.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", t[t.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", t[t.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", t[t.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", t[t.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", t[t.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", t[t.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", t[t.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", t[t.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", t[t.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", t[t.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", t[t.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", t[t.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t[t.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", t[t.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", t[t.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", t[t.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", t[t.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", t[t.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", t[t.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", t[t.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", t[t.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", t[t.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", t[t.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", t[t.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", t[t.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", t[t.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", t[t.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", t[t.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", t[t.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", t[t.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", t[t.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", t[t.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", t[t.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", t[t.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", t[t.OBJECT_TYPE = 37138] = "OBJECT_TYPE", t[t.SYNC_CONDITION = 37139] = "SYNC_CONDITION", t[t.SYNC_STATUS = 37140] = "SYNC_STATUS", t[t.SYNC_FLAGS = 37141] = "SYNC_FLAGS", t[t.SYNC_FENCE = 37142] = "SYNC_FENCE", t[t.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", t[t.UNSIGNALED = 37144] = "UNSIGNALED", t[t.SIGNALED = 37145] = "SIGNALED", t[t.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", t[t.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", t[t.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", t[t.WAIT_FAILED = 37149] = "WAIT_FAILED", t[t.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", t[t.COLOR = 6144] = "COLOR", t[t.DEPTH = 6145] = "DEPTH", t[t.STENCIL = 6146] = "STENCIL", t[t.MIN = 32775] = "MIN", t[t.MAX = 32776] = "MAX", t[t.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", t[t.STREAM_READ = 35041] = "STREAM_READ", t[t.STREAM_COPY = 35042] = "STREAM_COPY", t[t.STATIC_READ = 35045] = "STATIC_READ", t[t.STATIC_COPY = 35046] = "STATIC_COPY", t[t.DYNAMIC_READ = 35049] = "DYNAMIC_READ", t[t.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", t[t.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", t[t.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", t[t.INVALID_INDEX = 4294967295] = "INVALID_INDEX", t[t.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", t[t.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", t[t.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", t[t.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", t[t.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", t[t.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", t[t.R16_EXT = 33322] = "R16_EXT", t[t.RG16_EXT = 33324] = "RG16_EXT", t[t.RGB16_EXT = 32852] = "RGB16_EXT", t[t.RGBA16_EXT = 32859] = "RGBA16_EXT", t[t.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", t[t.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", t[t.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", t[t.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", t[t.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", t[t.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", t[t.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", t[t.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", t[t.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", t[t.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", t[t.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", t[t.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", t[t.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", t[t.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", t[t.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", t[t.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", t[t.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", t[t.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", t[t.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", t[t.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", t[t.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", t[t.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", t[t.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", t[t.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", t[t.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", t[t.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", t[t.LINE_WEBGL = 6913] = "LINE_WEBGL", t[t.FILL_WEBGL = 6914] = "FILL_WEBGL", t[t.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", t[t.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", t[t.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", t[t.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", t[t.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", t[t.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", t[t.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", t[t.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", t[t.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", t[t.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", t[t.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", t[t.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", t[t.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", t[t.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", t[t.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", t[t.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", t[t.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", t[t.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", t[t.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", t[t.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", t[t.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", t[t.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", t[t.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", t[t.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(Ls || (Ls = {}));
const Dc = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, le = (t, e, s) => e ? t.enable(s) : t.disable(s), Wh = (t, e, s) => t.hint(s, e), Me = (t, e, s) => t.pixelStorei(s, e), Xh = (t, e, s) => {
  const n = s === 36006 ? 36009 : 36008;
  return t.bindFramebuffer(n, e);
}, Cn = (t, e, s) => {
  const r = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[s];
  t.bindBuffer(r, e);
};
function So(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
}
const $S = {
  3042: le,
  32773: (t, e) => t.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (t, e) => t.clearColor(...e),
  3107: (t, e) => t.colorMask(...e),
  2884: le,
  2885: (t, e) => t.cullFace(e),
  2929: le,
  2931: (t, e) => t.clearDepth(e),
  2932: (t, e) => t.depthFunc(e),
  2928: (t, e) => t.depthRange(...e),
  2930: (t, e) => t.depthMask(e),
  3024: le,
  35723: Wh,
  35725: (t, e) => t.useProgram(e),
  36007: (t, e) => t.bindRenderbuffer(36161, e),
  36389: (t, e) => t.bindTransformFeedback?.(36386, e),
  34229: (t, e) => t.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: Xh,
  36010: Xh,
  // Buffers
  34964: Cn,
  36662: Cn,
  36663: Cn,
  35053: Cn,
  35055: Cn,
  2886: (t, e) => t.frontFace(e),
  33170: Wh,
  2849: (t, e) => t.lineWidth(e),
  32823: le,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: le,
  32926: le,
  32928: le,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: le,
  3088: (t, e) => t.scissor(...e),
  2960: le,
  2961: (t, e) => t.clearStencil(e),
  2968: (t, e) => t.stencilMaskSeparate(1028, e),
  36005: (t, e) => t.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (t, e) => t.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: le,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: le,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: le,
  12289: le,
  12290: le,
  12291: le,
  12292: le,
  12293: le,
  12294: le,
  12295: le,
  // PIXEL PACK/UNPACK MODES
  3333: Me,
  3317: Me,
  37440: Me,
  37441: Me,
  37443: Me,
  3330: Me,
  3332: Me,
  3331: Me,
  3314: Me,
  32878: Me,
  3316: Me,
  3315: Me,
  32877: Me,
  // Function-style setters
  framebuffer: (t, e) => {
    const s = e && "handle" in e ? e.handle : e;
    return t.bindFramebuffer(36160, s);
  },
  blend: (t, e) => e ? t.enable(3042) : t.disable(3042),
  blendColor: (t, e) => t.blendColor(...e),
  blendEquation: (t, e) => {
    const s = typeof e == "number" ? [e, e] : e;
    t.blendEquationSeparate(...s);
  },
  blendFunc: (t, e) => {
    const s = e?.length === 2 ? [...e, ...e] : e;
    t.blendFuncSeparate(...s);
  },
  clearColor: (t, e) => t.clearColor(...e),
  clearDepth: (t, e) => t.clearDepth(e),
  clearStencil: (t, e) => t.clearStencil(e),
  colorMask: (t, e) => t.colorMask(...e),
  cull: (t, e) => e ? t.enable(2884) : t.disable(2884),
  cullFace: (t, e) => t.cullFace(e),
  depthTest: (t, e) => e ? t.enable(2929) : t.disable(2929),
  depthFunc: (t, e) => t.depthFunc(e),
  depthMask: (t, e) => t.depthMask(e),
  depthRange: (t, e) => t.depthRange(...e),
  dither: (t, e) => e ? t.enable(3024) : t.disable(3024),
  derivativeHint: (t, e) => {
    t.hint(35723, e);
  },
  frontFace: (t, e) => t.frontFace(e),
  mipmapHint: (t, e) => t.hint(33170, e),
  lineWidth: (t, e) => t.lineWidth(e),
  polygonOffsetFill: (t, e) => e ? t.enable(32823) : t.disable(32823),
  polygonOffset: (t, e) => t.polygonOffset(...e),
  sampleCoverage: (t, e) => t.sampleCoverage(...e),
  scissorTest: (t, e) => e ? t.enable(3089) : t.disable(3089),
  scissor: (t, e) => t.scissor(...e),
  stencilTest: (t, e) => e ? t.enable(2960) : t.disable(2960),
  stencilMask: (t, e) => {
    e = So(e) ? e : [e, e];
    const [s, n] = e;
    t.stencilMaskSeparate(1028, s), t.stencilMaskSeparate(1029, n);
  },
  stencilFunc: (t, e) => {
    e = So(e) && e.length === 3 ? [...e, ...e] : e;
    const [s, n, r, i, o, a] = e;
    t.stencilFuncSeparate(1028, s, n, r), t.stencilFuncSeparate(1029, i, o, a);
  },
  stencilOp: (t, e) => {
    e = So(e) && e.length === 3 ? [...e, ...e] : e;
    const [s, n, r, i, o, a] = e;
    t.stencilOpSeparate(1028, s, n, r), t.stencilOpSeparate(1029, i, o, a);
  },
  viewport: (t, e) => t.viewport(...e)
};
function oe(t, e, s) {
  return e[t] !== void 0 ? e[t] : s[t];
}
const KS = {
  blendEquation: (t, e, s) => t.blendEquationSeparate(oe(32777, e, s), oe(34877, e, s)),
  blendFunc: (t, e, s) => t.blendFuncSeparate(oe(32969, e, s), oe(32968, e, s), oe(32971, e, s), oe(32970, e, s)),
  polygonOffset: (t, e, s) => t.polygonOffset(oe(32824, e, s), oe(10752, e, s)),
  sampleCoverage: (t, e, s) => t.sampleCoverage(oe(32938, e, s), oe(32939, e, s)),
  stencilFuncFront: (t, e, s) => t.stencilFuncSeparate(1028, oe(2962, e, s), oe(2967, e, s), oe(2963, e, s)),
  stencilFuncBack: (t, e, s) => t.stencilFuncSeparate(1029, oe(34816, e, s), oe(36003, e, s), oe(36004, e, s)),
  stencilOpFront: (t, e, s) => t.stencilOpSeparate(1028, oe(2964, e, s), oe(2965, e, s), oe(2966, e, s)),
  stencilOpBack: (t, e, s) => t.stencilOpSeparate(1029, oe(34817, e, s), oe(34818, e, s), oe(34819, e, s))
}, Gh = {
  // GENERIC SETTERS
  enable: (t, e) => t({
    [e]: !0
  }),
  disable: (t, e) => t({
    [e]: !1
  }),
  pixelStorei: (t, e, s) => t({
    [e]: s
  }),
  hint: (t, e, s) => t({
    [e]: s
  }),
  // SPECIFIC SETTERS
  useProgram: (t, e) => t({
    35725: e
  }),
  bindRenderbuffer: (t, e, s) => t({
    36007: s
  }),
  bindTransformFeedback: (t, e, s) => t({
    36389: s
  }),
  bindVertexArray: (t, e) => t({
    34229: e
  }),
  bindFramebuffer: (t, e, s) => {
    switch (e) {
      case 36160:
        return t({
          36006: s,
          36010: s
        });
      case 36009:
        return t({ 36006: s });
      case 36008:
        return t({ 36010: s });
      default:
        return null;
    }
  },
  bindBuffer: (t, e, s) => {
    const n = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return n ? t({ [n]: s }) : { valueChanged: !0 };
  },
  blendColor: (t, e, s, n, r) => t({
    32773: new Float32Array([e, s, n, r])
  }),
  blendEquation: (t, e) => t({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (t, e, s) => t({
    32777: e,
    34877: s
  }),
  blendFunc: (t, e, s) => t({
    32969: e,
    32968: s,
    32971: e,
    32970: s
  }),
  blendFuncSeparate: (t, e, s, n, r) => t({
    32969: e,
    32968: s,
    32971: n,
    32970: r
  }),
  clearColor: (t, e, s, n, r) => t({
    3106: new Float32Array([e, s, n, r])
  }),
  clearDepth: (t, e) => t({
    2931: e
  }),
  clearStencil: (t, e) => t({
    2961: e
  }),
  colorMask: (t, e, s, n, r) => t({
    3107: [e, s, n, r]
  }),
  cullFace: (t, e) => t({
    2885: e
  }),
  depthFunc: (t, e) => t({
    2932: e
  }),
  depthRange: (t, e, s) => t({
    2928: new Float32Array([e, s])
  }),
  depthMask: (t, e) => t({
    2930: e
  }),
  frontFace: (t, e) => t({
    2886: e
  }),
  lineWidth: (t, e) => t({
    2849: e
  }),
  polygonOffset: (t, e, s) => t({
    32824: e,
    10752: s
  }),
  sampleCoverage: (t, e, s) => t({
    32938: e,
    32939: s
  }),
  scissor: (t, e, s, n, r) => t({
    3088: new Int32Array([e, s, n, r])
  }),
  stencilMask: (t, e) => t({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (t, e, s) => t({
    [e === 1028 ? 2968 : 36005]: s
  }),
  stencilFunc: (t, e, s, n) => t({
    2962: e,
    2967: s,
    2963: n,
    34816: e,
    36003: s,
    36004: n
  }),
  stencilFuncSeparate: (t, e, s, n, r) => t({
    [e === 1028 ? 2962 : 34816]: s,
    [e === 1028 ? 2967 : 36003]: n,
    [e === 1028 ? 2963 : 36004]: r
  }),
  stencilOp: (t, e, s, n) => t({
    2964: e,
    2965: s,
    2966: n,
    34817: e,
    34818: s,
    34819: n
  }),
  stencilOpSeparate: (t, e, s, n, r) => t({
    [e === 1028 ? 2964 : 34817]: s,
    [e === 1028 ? 2965 : 34818]: n,
    [e === 1028 ? 2966 : 34819]: r
  }),
  viewport: (t, e, s, n, r) => t({
    2978: [e, s, n, r]
  })
}, lt = (t, e) => t.isEnabled(e), $h = {
  3042: lt,
  2884: lt,
  2929: lt,
  3024: lt,
  32823: lt,
  32926: lt,
  32928: lt,
  3089: lt,
  2960: lt,
  35977: lt
}, YS = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function un(t, e) {
  if (qS(e))
    return;
  const s = {};
  for (const r in e) {
    const i = Number(r), o = $S[r];
    o && (typeof o == "string" ? s[o] = !0 : o(t, e[r], i));
  }
  const n = t.state && t.state.cache;
  if (n)
    for (const r in s) {
      const i = KS[r];
      i(t, e, n);
    }
}
function Ep(t, e = Dc) {
  if (typeof e == "number") {
    const r = e, i = $h[r];
    return i ? i(t, r) : t.getParameter(r);
  }
  const s = Array.isArray(e) ? e : Object.keys(e), n = {};
  for (const r of s) {
    const i = $h[r];
    n[r] = i ? i(t, Number(r)) : t.getParameter(Number(r));
  }
  return n;
}
function JS(t) {
  un(t, Dc);
}
function qS(t) {
  for (const e in t)
    return !1;
  return !0;
}
function ZS(t, e) {
  if (t === e)
    return !0;
  const s = Array.isArray(t) || ArrayBuffer.isView(t), n = Array.isArray(e) || ArrayBuffer.isView(e);
  if (s && n && t.length === e.length) {
    for (let r = 0; r < t.length; ++r)
      if (t[r] !== e[r])
        return !1;
    return !0;
  }
  return !1;
}
class QS {
  gl;
  program = null;
  stateStack = [];
  enable = !0;
  cache;
  log;
  constructor(e, {
    copyState: s = !1,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log: n = () => {
    }
    // Logging function, called when gl parameter change calls are actually issued
  } = {}) {
    this.gl = e, this.cache = s ? Ep(e) : Object.assign({}, Dc), this.log = n, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(e = {}) {
    this.stateStack.push({});
  }
  pop() {
    q(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    un(this.gl, e), this.stateStack.pop();
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let s = !1, n;
    const r = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const i in e) {
      q(i !== void 0);
      const o = e[i], a = this.cache[i];
      ZS(o, a) || (s = !0, n = a, r && !(i in r) && (r[i] = a), this.cache[i] = o);
    }
    return { valueChanged: s, oldValue: n };
  }
}
function Ts(t) {
  return t.state;
}
function Cp(t, e) {
  const { enable: s = !0, copyState: n } = e;
  if (q(n !== void 0), !t.state) {
    t.state = new QS(t, { copyState: n }), tR(t);
    for (const i in Gh) {
      const o = Gh[i];
      eR(t, i, o);
    }
    Kh(t, "getParameter"), Kh(t, "isEnabled");
  }
  const r = Ts(t);
  return r.enable = s, t;
}
function Ni(t) {
  let e = Ts(t);
  e || (Cp(t, { copyState: !1 }), e = Ts(t)), e.push();
}
function qn(t) {
  const e = Ts(t);
  q(e), e.pop();
}
function Kh(t, e) {
  const s = t[e].bind(t);
  t[e] = function(r) {
    if (r === void 0 || YS.has(r))
      return s(r);
    const i = Ts(t);
    return r in i.cache || (i.cache[r] = s(r)), i.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      i.cache[r]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      s(r)
    );
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function eR(t, e, s) {
  if (!t[e])
    return;
  const n = t[e].bind(t);
  t[e] = function(...i) {
    const o = Ts(t), { valueChanged: a, oldValue: c } = s(o._updateCache, ...i);
    return a && n(...i), c;
  }, Object.defineProperty(t[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function tR(t) {
  const e = t.useProgram.bind(t);
  t.useProgram = function(n) {
    const r = Ts(t);
    r.program !== n && (e(n), r.program = n);
  };
}
const sR = {
  powerPreference: "high-performance",
  // After all, most apps are using WebGL for performance reasons
  // eslint-disable-next-line no-console
  onContextLost: () => console.error("WebGL context lost"),
  // eslint-disable-next-line no-console
  onContextRestored: () => console.info("WebGL context restored")
};
function nR(t, e) {
  e = { ...sR, ...e };
  let s = null;
  const n = (i) => s = i.statusMessage || s;
  t.addEventListener("webglcontextcreationerror", n, !1);
  let r = null;
  if (r ||= t.getContext("webgl2", e), t.removeEventListener("webglcontextcreationerror", n, !1), !r)
    throw new Error(`Failed to create WebGL context: ${s || "Unknown error"}`);
  if (e.onContextLost) {
    const { onContextLost: i } = e;
    t.addEventListener("webglcontextlost", (o) => i(o), !1);
  }
  if (e.onContextRestored) {
    const { onContextRestored: i } = e;
    t.addEventListener("webglcontextrestored", (o) => i(o), !1);
  }
  return r;
}
function Jt(t, e, s) {
  return s[e] === void 0 && (s[e] = t.getExtension(e) || null), s[e];
}
function rR(t, e) {
  const s = t.getParameter(7936), n = t.getParameter(7937);
  Jt(t, "WEBGL_debug_renderer_info", e);
  const r = e.WEBGL_debug_renderer_info, i = t.getParameter(r ? r.UNMASKED_VENDOR_WEBGL : 7936), o = t.getParameter(r ? r.UNMASKED_RENDERER_WEBGL : 7937), a = i || s, c = o || n, l = t.getParameter(7938), h = Sp(a, c), u = iR(a, c), f = oR(a, c);
  return {
    type: "webgl",
    gpu: h,
    gpuType: f,
    gpuBackend: u,
    vendor: a,
    renderer: c,
    version: l,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function Sp(t, e) {
  return /NVIDIA/i.exec(t) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(t) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(t) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(t) || /AMD/i.exec(e) || /ATI/i.exec(t) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(t) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function iR(t, e) {
  return /Metal/i.exec(t) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(t) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function oR(t, e) {
  if (/SwiftShader/i.exec(t) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (Sp(t, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function Rp(t) {
  switch (t) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(t));
}
const Ae = "texture-compression-bc", Q = "texture-compression-astc", ht = "texture-compression-etc2", aR = "texture-compression-etc1-webgl", Fr = "texture-compression-pvrtc-webgl", Ro = "texture-compression-atc-webgl", Sn = "float32-renderable-webgl", wo = "float16-renderable-webgl", cR = "rgb9e5ufloat_renderable-webgl", Io = "snorm8-renderable-webgl", Rn = "norm16-renderable-webgl", vo = "snorm16-renderable-webgl", Dr = "float32-filterable", Yh = "float16-filterable-webgl", Fn = "WEBGL_compressed_texture_s3tc", Dn = "WEBGL_compressed_texture_s3tc_srgb", ks = "EXT_texture_compression_rgtc", Vs = "EXT_texture_compression_bptc", lR = "WEBGL_compressed_texture_etc", hR = "WEBGL_compressed_texture_astc", uR = "WEBGL_compressed_texture_etc1", fR = "WEBGL_compressed_texture_pvrtc", dR = "WEBGL_compressed_texture_atc", Jh = "EXT_texture_norm16", qh = "EXT_render_snorm", pR = "EXT_color_buffer_float", Uc = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [qh],
  "norm16-renderable-webgl": [Jh],
  "snorm16-renderable-webgl": [Jh, qh],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [Fn, Dn, ks, Vs],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [ks],
  "texture-compression-bc7-webgl": [Vs],
  "texture-compression-etc2": [lR],
  "texture-compression-astc": [hR],
  "texture-compression-etc1-webgl": [uR],
  "texture-compression-pvrtc-webgl": [fR],
  "texture-compression-atc-webgl": [dR]
};
function _R(t) {
  return t in Uc;
}
function gR(t, e, s) {
  return (Uc[e] || []).every((r) => Jt(t, r, s));
}
const Fi = {
  // Unsized formats that leave the precision up to the driver. TODO - Fix bpp constants
  "rgb8unorm-unsized": {
    gl: 6407,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6407,
    types: [5121, 33635]
  },
  "rgba8unorm-unsized": {
    gl: 6408,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
  // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 8-bit formats
  r8unorm: { gl: 33321, b: 1, c: 1, rb: !0 },
  r8snorm: { gl: 36756, b: 1, c: 1, render: Io },
  r8uint: { gl: 33330, b: 1, c: 1, rb: !0 },
  r8sint: { gl: 33329, b: 1, c: 1, rb: !0 },
  // 16-bit formats
  rg8unorm: { gl: 33323, b: 2, c: 2, rb: !0 },
  rg8snorm: { gl: 36757, b: 2, c: 2, render: Io },
  rg8uint: { gl: 33336, b: 2, c: 2, rb: !0 },
  rg8sint: { gl: 33335, b: 2, c: 2, rb: !0 },
  r16uint: { gl: 33332, b: 2, c: 1, rb: !0 },
  r16sint: { gl: 33331, b: 2, c: 1, rb: !0 },
  r16float: { gl: 33325, b: 2, c: 1, render: wo, filter: "float16-filterable-webgl", rb: !0 },
  "r16unorm-webgl": { gl: 33322, b: 2, c: 1, f: Rn, rb: !0 },
  "r16snorm-webgl": { gl: 36760, b: 2, c: 1, f: vo },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb565unorm-webgl": { gl: 36194, b: 2, c: 4, wgpu: !1, rb: !0 },
  "rgb5a1unorm-webgl": { gl: 32855, b: 2, c: 4, wgpu: !1, rb: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849, b: 3, c: 3, wgpu: !1 },
  "rgb8snorm-webgl": { gl: 36758, b: 3, c: 3, wgpu: !1 },
  // 32-bit formats  
  rgba8unorm: { gl: 32856, b: 4, c: 2, bpp: 4 },
  "rgba8unorm-srgb": { gl: 35907, b: 4, c: 4, bpp: 4 },
  rgba8snorm: { gl: 36759, b: 4, c: 4, render: Io },
  rgba8uint: { gl: 36220, b: 4, c: 4, bpp: 4 },
  rgba8sint: { gl: 36238, b: 4, c: 4, bpp: 4 },
  // reverse colors, webgpu only
  bgra8unorm: { b: 4, c: 4 },
  "bgra8unorm-srgb": { b: 4, c: 4 },
  rg16uint: { gl: 33338, b: 4, c: 1, bpp: 4 },
  rg16sint: { gl: 33337, b: 4, c: 2, bpp: 4 },
  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  rg16float: { gl: 33327, bpp: 4, b: 4, c: 2, render: wo, filter: Yh, rb: !0 },
  "rg16unorm-webgl": { gl: 33324, b: 2, c: 2, render: Rn },
  "rg16snorm-webgl": { gl: 36761, b: 2, c: 2, render: vo },
  r32uint: { gl: 33334, b: 4, c: 1, bpp: 4, rb: !0 },
  r32sint: { gl: 33333, b: 4, c: 1, bpp: 4, rb: !0 },
  r32float: { gl: 33326, bpp: 4, b: 4, c: 1, render: Sn, filter: Dr },
  // Packed 32-bit formats
  rgb9e5ufloat: { gl: 35901, b: 4, c: 3, p: 1, render: cR },
  // , filter: true},
  rg11b10ufloat: { gl: 35898, b: 4, c: 3, p: 1, render: Sn, rb: !0 },
  rgb10a2unorm: { gl: 32857, b: 4, c: 4, p: 1, rb: !0 },
  "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975, p: 1, wgpu: !1, bpp: 4, rb: !0 },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852, b: 2, c: 3, f: Rn },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762, b: 2, c: 3, f: Rn },
  // rgb not renderable
  // 64-bit formats
  rg32uint: { gl: 33340, b: 8, c: 2, rb: !0 },
  rg32sint: { gl: 33339, b: 8, c: 2, rb: !0 },
  rg32float: { gl: 33328, b: 8, c: 2, render: Sn, filter: Dr, rb: !0 },
  rgba16uint: { gl: 36214, b: 8, c: 4, rb: !0 },
  rgba16sint: { gl: 36232, b: 8, c: 4, rb: !0 },
  rgba16float: { gl: 34842, b: 8, c: 4, render: wo, filter: Yh },
  "rgba16unorm-webgl": { gl: 32859, b: 2, c: 4, render: Rn, rb: !0 },
  "rgba16snorm-webgl": { gl: 36763, b: 2, c: 4, render: vo },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    render: Sn,
    filter: Dr,
    gl2ext: pR,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: { gl: 36208, b: 16, c: 4, rb: !0 },
  rgba32sint: { gl: 36226, b: 16, c: 4, rb: !0 },
  rgba32float: { gl: 34836, b: 16, c: 4, render: Sn, filter: Dr, rb: !0 },
  // Depth and stencil formats
  stencil8: { gl: 36168, b: 1, c: 1, attachment: 36128, rb: !0 },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    b: 2,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    b: 3,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    b: 4,
    c: 1,
    attachment: 36096,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": {
    gl: 35056,
    b: 4,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [34042],
    rb: !0
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    b: 5,
    c: 2,
    p: 1,
    attachment: 33306,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: Fn, f: Ae },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: Dn, f: Ae },
  "bc1-rgba-unorm": { gl: 33777, x: Fn, f: Ae },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: Dn, f: Ae },
  "bc2-rgba-unorm": { gl: 33778, x: Fn, f: Ae },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: Dn, f: Ae },
  "bc3-rgba-unorm": { gl: 33779, x: Fn, f: Ae },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: Dn, f: Ae },
  "bc4-r-unorm": { gl: 36283, x: ks, f: Ae },
  "bc4-r-snorm": { gl: 36284, x: ks, f: Ae },
  "bc5-rg-unorm": { gl: 36285, x: ks, f: Ae },
  "bc5-rg-snorm": { gl: 36286, x: ks, f: Ae },
  "bc6h-rgb-ufloat": { gl: 36495, x: Vs, f: Ae },
  "bc6h-rgb-float": { gl: 36494, x: Vs, f: Ae },
  "bc7-rgba-unorm": { gl: 36492, x: Vs, f: Ae },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: Vs, f: Ae },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492, f: ht },
  "etc2-rgb8unorm-srgb": { gl: 37494, f: ht },
  "etc2-rgb8a1unorm": { gl: 37496, f: ht },
  "etc2-rgb8a1unorm-srgb": { gl: 37497, f: ht },
  "etc2-rgba8unorm": { gl: 37493, f: ht },
  "etc2-rgba8unorm-srgb": { gl: 37495, f: ht },
  "eac-r11unorm": { gl: 37488, f: ht },
  "eac-r11snorm": { gl: 37489, f: ht },
  "eac-rg11unorm": { gl: 37490, f: ht },
  "eac-rg11snorm": { gl: 37491, f: ht },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808, f: Q },
  "astc-4x4-unorm-srgb": { gl: 37840, f: Q },
  "astc-5x4-unorm": { gl: 37809, f: Q },
  "astc-5x4-unorm-srgb": { gl: 37841, f: Q },
  "astc-5x5-unorm": { gl: 37810, f: Q },
  "astc-5x5-unorm-srgb": { gl: 37842, f: Q },
  "astc-6x5-unorm": { gl: 37811, f: Q },
  "astc-6x5-unorm-srgb": { gl: 37843, f: Q },
  "astc-6x6-unorm": { gl: 37812, f: Q },
  "astc-6x6-unorm-srgb": { gl: 37844, f: Q },
  "astc-8x5-unorm": { gl: 37813, f: Q },
  "astc-8x5-unorm-srgb": { gl: 37845, f: Q },
  "astc-8x6-unorm": { gl: 37814, f: Q },
  "astc-8x6-unorm-srgb": { gl: 37846, f: Q },
  "astc-8x8-unorm": { gl: 37815, f: Q },
  "astc-8x8-unorm-srgb": { gl: 37847, f: Q },
  "astc-10x5-unorm": { gl: 37819, f: Q },
  "astc-10x5-unorm-srgb": { gl: 37851, f: Q },
  "astc-10x6-unorm": { gl: 37817, f: Q },
  "astc-10x6-unorm-srgb": { gl: 37849, f: Q },
  "astc-10x8-unorm": { gl: 37818, f: Q },
  "astc-10x8-unorm-srgb": { gl: 37850, f: Q },
  "astc-10x10-unorm": { gl: 37819, f: Q },
  "astc-10x10-unorm-srgb": { gl: 37851, f: Q },
  "astc-12x10-unorm": { gl: 37820, f: Q },
  "astc-12x10-unorm-srgb": { gl: 37852, f: Q },
  "astc-12x12-unorm": { gl: 37821, f: Q },
  "astc-12x12-unorm-srgb": { gl: 37853, f: Q },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840, f: Fr },
  "pvrtc-rgba4unorm-webgl": { gl: 35842, f: Fr },
  "pvrtc-rbg2unorm-webgl": { gl: 35841, f: Fr },
  "pvrtc-rgba2unorm-webgl": { gl: 35843, f: Fr },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196, f: aR },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986, f: Ro },
  "atc-rgba-unorm-webgl": { gl: 35986, f: Ro },
  "atc-rgbai-unorm-webgl": { gl: 34798, f: Ro }
}, mR = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, AR = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function Lc(t, e, s) {
  const n = Fi[e];
  if (!n || n.gl === void 0)
    return !1;
  const r = n.x || n.gl2ext;
  return r ? !!Jt(t, r, s) : !0;
}
function wp(t) {
  const s = Fi[t]?.gl;
  if (s === void 0)
    throw new Error(`Unsupported texture format ${t}`);
  return s;
}
function TR(t, e, s) {
  if (!Lc(t, e, s) || e.startsWith("depth") || e.startsWith("stencil"))
    return !1;
  try {
    if (Td(e).signed)
      return !1;
  } catch {
    return !1;
  }
  return e.endsWith("32float") ? !!Jt(t, "OES_texture_float_linear, extensions", s) : e.endsWith("16float") ? !!Jt(t, "OES_texture_half_float_linear, extensions", s) : !0;
}
function yR(t, e, s) {
  return !(!Lc(t, e, s) || typeof e == "number");
}
function Ti(t) {
  const e = Fi[t], s = wp(t), n = Td(t);
  return {
    format: s,
    dataFormat: e?.dataFormat || ER(n.format, n.integer, n.normalized, s),
    // depth formats don't have a type
    type: n.dataType ? Rp(n.dataType) : e?.types?.[0] || 5121,
    // @ts-expect-error
    compressed: n.compressed
  };
}
function bR(t) {
  const e = Fi[t];
  if (!e?.attachment)
    throw new Error(`${t} is not a depth stencil format`);
  return e.attachment;
}
function Zh(t) {
  const e = Ti(t), s = mR[e.dataFormat] || 4, n = AR[e.type] || 1;
  return s * n;
}
function ER(t, e, s, n) {
  if (n === 6408 || n === 6407)
    return n;
  switch (t) {
    case "r":
      return e && !s ? 36244 : 6403;
    case "rg":
      return e && !s ? 33320 : 33319;
    case "rgb":
      return e && !s ? 36248 : 6407;
    case "rgba":
      return e && !s ? 36249 : 6408;
    default:
      return 6408;
  }
}
const Qh = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth24unorm-stencil8' // GPUTextureFormat 'depth24unorm-stencil8'
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class CR extends _y {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(e, s, n) {
    super([], n), this.gl = e, this.extensions = s, Jt(e, "EXT_color_buffer_float", s);
  }
  *[Symbol.iterator]() {
    const e = this.getFeatures();
    for (const s of e)
      this.has(s) && (yield s);
    return [];
  }
  has(e) {
    return this.disabledFeatures[e] ? !1 : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), _R(e) && gR(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
  }
  // FOR DEVICE
  initializeFeatures() {
    const e = this.getFeatures().filter((s) => s !== "polygon-mode-webgl");
    for (const s of e)
      this.has(s);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(Qh), ...Object.keys(Uc)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(e) {
    const s = Qh[e];
    return typeof s == "string" ? !!Jt(this.gl, s, this.extensions) : !!s;
  }
}
class SR extends py {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(e) {
    super(), this.gl = e;
  }
  getParameter(e) {
    return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e];
  }
}
function jt(t, e, s) {
  if (RR(e))
    return s(t);
  const { nocatch: n = !0 } = e;
  Ni(t), un(t, e);
  let r;
  if (n)
    r = s(t), qn(t);
  else
    try {
      r = s(t);
    } finally {
      qn(t);
    }
  return r;
}
function RR(t) {
  for (const e in t)
    return !1;
  return !0;
}
function wR(t, e, s, n) {
  if (li(e))
    return n(t);
  const r = t;
  Ni(r.gl);
  try {
    return IR(t, e), un(r.gl, s), n(t);
  } finally {
    qn(r.gl);
  }
}
function IR(t, e) {
  const s = t, { gl: n } = s;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        n.disable(2884);
        break;
      case "front":
        n.enable(2884), n.cullFace(1028);
        break;
      case "back":
        n.enable(2884), n.cullFace(1029);
        break;
    }
  if (e.frontFace && n.frontFace(gs("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && t.features.has("depth-clip-control") && n.enable(34383), e.depthBias !== void 0 && (n.enable(32823), n.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && t.features.has("provoking-vertex-webgl")) {
    const i = s.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, o = gs("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    i?.provokingVertexWEBGL(o);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && t.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const i = s.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, o = gs("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      i?.polygonModeWEBGL(1028, o), i?.polygonModeWEBGL(1029, o);
    }
    e.polygonOffsetLine && n.enable(10754);
  }
  if (t.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && n.enable(12288), e.clipDistance1 && n.enable(12289), e.clipDistance2 && n.enable(12290), e.clipDistance3 && n.enable(12291), e.clipDistance4 && n.enable(12292), e.clipDistance5 && n.enable(12293), e.clipDistance6 && n.enable(12294), e.clipDistance7 && n.enable(12295)), e.depthWriteEnabled !== void 0 && n.depthMask(BR("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? n.enable(2929) : n.disable(2929), n.depthFunc(Ma("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const r = e.stencilWriteMask;
    n.stencilMaskSeparate(1028, r), n.stencilMaskSeparate(1029, r);
  }
  if (e.stencilReadMask && P.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const r = e.stencilReadMask || 4294967295, i = Ma("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? n.enable(2960) : n.disable(2960), n.stencilFuncSeparate(1028, i, 0, r), n.stencilFuncSeparate(1029, i, 0, r);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const r = Bo("stencilPassOperation", e.stencilPassOperation), i = Bo("stencilFailOperation", e.stencilFailOperation), o = Bo("stencilDepthFailOperation", e.stencilDepthFailOperation);
    n.stencilOpSeparate(1028, i, o, r), n.stencilOpSeparate(1029, i, o, r);
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    n.enable(3042);
    const r = eu("blendColorOperation", e.blendColorOperation || "add"), i = eu("blendAlphaOperation", e.blendAlphaOperation || "add");
    n.blendEquationSeparate(r, i);
    const o = Ur("blendColorSrcFactor", e.blendColorSrcFactor || "one"), a = Ur("blendColorDstFactor", e.blendColorDstFactor || "zero"), c = Ur("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), l = Ur("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    n.blendFuncSeparate(o, a, c, l);
  }
}
function Ma(t, e) {
  return gs(t, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function Bo(t, e) {
  return gs(t, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function eu(t, e) {
  return gs(t, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function Ur(t, e) {
  return gs(t, e, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function vR(t, e) {
  return `Illegal parameter ${e} for ${t}`;
}
function gs(t, e, s) {
  if (!(e in s))
    throw new Error(vR(t, e));
  return s[e];
}
function BR(t, e) {
  return e;
}
function Ip(t) {
  const e = {};
  return t.addressModeU && (e[10242] = Mo(t.addressModeU)), t.addressModeV && (e[10243] = Mo(t.addressModeV)), t.addressModeW && (e[32882] = Mo(t.addressModeW)), t.magFilter && (e[10240] = vp(t.magFilter)), (t.minFilter || t.mipmapFilter) && (e[10241] = MR(t.minFilter || "linear", t.mipmapFilter)), t.lodMinClamp !== void 0 && (e[33082] = t.lodMinClamp), t.lodMaxClamp !== void 0 && (e[33083] = t.lodMaxClamp), t.type === "comparison-sampler" && (e[34892] = 34894), t.compare && (e[34893] = Ma("compare", t.compare)), t.maxAnisotropy && (e[34046] = t.maxAnisotropy), e;
}
function Mo(t) {
  switch (t) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function vp(t) {
  switch (t) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function MR(t, e) {
  if (!e)
    return vp(t);
  switch (t) {
    case "nearest":
      return e === "nearest" ? 9984 : 9986;
    case "linear":
      return e === "nearest" ? 9985 : 9987;
  }
}
class Gt extends re {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength;
  /** Number of bytes used */
  bytesUsed;
  constructor(e, s = {}) {
    super(e, s), this.device = e, this.gl = this.device.gl;
    const n = typeof s == "object" ? s.handle : void 0;
    this.handle = n || this.gl.createBuffer(), e.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glTarget = PR(this.props.usage), this.glUsage = OR(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, s.data ? this._initWithData(s.data, s.byteOffset, s.byteLength) : this._initWithByteLength(s.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(e, s = 0, n = e.byteLength + s) {
    const r = this.glTarget;
    this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, n, this.glUsage), this.gl.bufferSubData(r, s, e), this.gl.bindBuffer(r, null), this.bytesUsed = n, this.byteLength = n, this._setDebugData(e, s, n), this.trackAllocatedMemory(n);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(e) {
    q(e >= 0);
    let s = e;
    e === 0 && (s = new Float32Array(0));
    const n = this.glTarget;
    return this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, s, this.glUsage), this.gl.bindBuffer(n, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(e, s = 0) {
    this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, s, e), this.gl.bindBuffer(36663, null), this._setDebugData(e, s, e.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(e = 0, s) {
    return this.readSyncWebGL(e, s);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(e = 0, s) {
    s = s ?? this.byteLength - e;
    const n = new Uint8Array(s), r = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, n, r, s), this.gl.bindBuffer(36662, null), this._setDebugData(n, e, s), n;
  }
}
function PR(t) {
  return t & re.INDEX ? 34963 : t & re.VERTEX ? 34962 : t & re.UNIFORM ? 35345 : 34962;
}
function OR(t) {
  return t & re.INDEX || t & re.VERTEX ? 35044 : t & re.UNIFORM ? 35048 : 35044;
}
class Pa extends Pi {
  device;
  handle;
  parameters;
  constructor(e, s) {
    super(e, s), this.device = e, this.parameters = Ip(s), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(e) {
    for (const [s, n] of Object.entries(e)) {
      const r = Number(s);
      switch (r) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, r, n);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, r, n);
          break;
      }
    }
  }
}
class Hs extends Bi {
  device;
  gl;
  handle;
  texture;
  constructor(e, s) {
    super(e, { ...Ne.defaultProps, ...s }), this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = s.texture;
  }
}
const xR = {
  // deprecated
  parameters: {},
  pixelStore: {},
  pixels: null,
  border: 0,
  dataFormat: void 0,
  textureUnit: void 0,
  target: void 0
};
class qe extends Ne {
  // TODO - remove?
  static FACES = [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
  ];
  MAX_ATTRIBUTES;
  device;
  gl;
  handle;
  // (TODO - currently unused in WebGL, but WebGL 2 does support sampler objects) */
  sampler = void 0;
  view = void 0;
  // data;
  glFormat = void 0;
  type = void 0;
  dataFormat = void 0;
  mipmaps = void 0;
  /**
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * they get special information. When you first bind a texture as a
   * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   * */
  target;
  textureUnit = void 0;
  /**
   * Program.draw() checks the loaded flag of all textures to avoid
   * Textures that are still loading from promises
   * Set to true as soon as texture has been initialized with valid data
   */
  loaded = !1;
  _video;
  constructor(e, s) {
    super(e, { ...xR, format: "rgba8unorm", ...s }), this.device = e, this.gl = this.device.gl, this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glFormat = 6408, this.target = NR(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, { data: sb(this.props.data) }), this.initialize(this.props), Object.seal(this);
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
  createView(e) {
    return new Hs(this.device, { ...e, texture: this });
  }
  // eslint-disable-next-line max-statements
  initialize(e = {}) {
    if (this.props.dimension === "cube")
      return this.initializeCube(e);
    let s = e.data;
    if (s instanceof Promise)
      return s.then((E) => this.initialize(Object.assign({}, e, {
        pixels: E,
        data: E
      }))), this;
    const n = typeof HTMLVideoElement < "u" && s instanceof HTMLVideoElement;
    if (n && s.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, s.addEventListener("loadeddata", () => this.initialize(e)), this;
    const { parameters: r = {} } = e, { pixels: i = null, pixelStore: o = {}, textureUnit: a = void 0, mipmaps: c = !0 } = e;
    s || (s = i);
    let { width: l, height: h, dataFormat: u, type: f, compressed: p = !1 } = e;
    const { depth: m = 0 } = e, A = wp(e.format);
    return { width: l, height: h, compressed: p, dataFormat: u, type: f } = this._deduceParameters({
      format: e.format,
      type: f,
      dataFormat: u,
      compressed: p,
      data: s,
      width: l,
      height: h
    }), this.width = l, this.height = h, this.glFormat = A, this.type = f, this.dataFormat = u, this.textureUnit = a, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = c, this.setImageData({
      data: s,
      width: l,
      height: h,
      depth: m,
      format: e.format,
      type: f,
      dataFormat: u,
      // @ts-expect-error
      parameters: o,
      compressed: p
    }), this.setSampler(e.sampler), this._setSamplerParameters(r), this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 }), c && this.device.isTextureFormatFilterable(e.format) && this.generateMipmap(), n && (this._video = {
      video: s,
      parameters: r,
      // @ts-expect-error
      lastTime: s.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? s.currentTime : -1
    }), this;
  }
  initializeCube(e) {
    const { mipmaps: s = !0, parameters: n = {} } = e;
    return this.setCubeMapImageData(e).then(() => {
      this.loaded = !0, s && this.generateMipmap(e), this.setSampler(e.sampler), this._setSamplerParameters(n);
    }), this;
  }
  setSampler(e = {}) {
    let s;
    e instanceof Pa ? (this.sampler = e, s = e.props) : (this.sampler = new Pa(this.device, e), s = e);
    const n = Ip(s);
    return this._setSamplerParameters(n), this;
  }
  /**
   * If size has changed, reinitializes with current format
   * @note note clears image and mipmaps
   */
  resize(e) {
    const { height: s, width: n, mipmaps: r = !1 } = e;
    return n !== this.width || s !== this.height ? this.initialize({
      width: n,
      height: s,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      mipmaps: r
    }) : this;
  }
  /** Update external texture (video frame) */
  update() {
    if (this._video) {
      const { video: e, parameters: s, lastTime: n } = this._video;
      if (n === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: e,
        parameters: s
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
    }
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(e = {}) {
    return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), jt(this.gl, e, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this;
  }
  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param  width -
   * @param  height -
   * @param  mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  // eslint-disable-next-line max-statements, complexity
  setImageData(e) {
    if (this.props.dimension === "3d" || this.props.dimension === "2d-array")
      return this.setImageData3D(e);
    this.trackDeallocatedMemory("Texture");
    const { target: s = this.target, pixels: n = null, level: r = 0, glFormat: i = this.glFormat, offset: o = 0, parameters: a = {} } = e;
    let { data: c = null, type: l = this.type, width: h = this.width, height: u = this.height, dataFormat: f = this.dataFormat, compressed: p = !1 } = e;
    c || (c = n), { type: l, dataFormat: f, compressed: p, width: h, height: u } = this._deduceParameters({
      format: this.props.format,
      type: l,
      dataFormat: f,
      compressed: p,
      data: c,
      width: h,
      height: u
    });
    const { gl: m } = this;
    m.bindTexture(this.target, this.handle);
    let A = null;
    if ({ data: c, dataType: A } = this._getDataType({ data: c, compressed: p }), jt(this.gl, a, () => {
      switch (A) {
        case "null":
          m.texImage2D(s, r, i, h, u, 0, f, l, c);
          break;
        case "typed-array":
          m.texImage2D(
            s,
            r,
            i,
            h,
            u,
            0,
            // border (must be 0)
            f,
            l,
            c,
            o
          );
          break;
        case "buffer":
          this.device.gl.bindBuffer(35052, c.handle || c), this.device.gl.texImage2D(s, r, i, h, u, 0, f, l, o), this.device.gl.bindBuffer(35052, null);
          break;
        case "browser-object":
          m.texImage2D(s, r, i, h, u, 0, f, l, c);
          break;
        case "compressed":
          for (const [E, C] of c.entries())
            m.compressedTexImage2D(s, E, C.format, C.width, C.height, 0, C.data);
          break;
        default:
          q(!1, "Unknown image data type");
      }
    }), c && c.byteLength)
      this.trackAllocatedMemory(c.byteLength, "Texture");
    else {
      const E = Zh(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * E, "Texture");
    }
    return this.loaded = !0, this;
  }
  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   * Redefines an area of an existing texture
   */
  setSubImageData({ target: e = this.target, pixels: s = null, data: n = null, x: r = 0, y: i = 0, width: o = this.width, height: a = this.height, level: c = 0, glFormat: l = this.glFormat, type: h = this.type, dataFormat: u = this.dataFormat, compressed: f = !1, offset: p = 0, parameters: m = {} }) {
    if ({ type: h, dataFormat: u, compressed: f, width: o, height: a } = this._deduceParameters({
      format: this.props.format,
      type: h,
      dataFormat: u,
      compressed: f,
      data: n,
      width: o,
      height: a
    }), q(this.depth === 1, "texSubImage not supported for 3D textures"), n || (n = s), n && n.data) {
      const A = n;
      n = A.data, o = A.shape[0], a = A.shape[1];
    }
    n instanceof Gt && (n = n.handle), this.gl.bindTexture(this.target, this.handle), jt(this.gl, m, () => {
      f ? this.gl.compressedTexSubImage2D(e, c, r, i, o, a, l, n) : n === null ? this.gl.texSubImage2D(e, c, r, i, o, a, u, h, null) : ArrayBuffer.isView(n) ? this.gl.texSubImage2D(e, c, r, i, o, a, u, h, n, p) : typeof WebGLBuffer < "u" && n instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, n), this.device.gl.texSubImage2D(e, c, r, i, o, a, u, h, p), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(e, c, r, i, o, a, u, h, n);
    }), this.gl.bindTexture(this.target, null);
  }
  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(e = {}) {
    return P.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(e = this.textureUnit) {
    const { gl: s } = this;
    return e !== void 0 && (this.textureUnit = e, s.activeTexture(33984 + e)), s.bindTexture(this.target, this.handle), e;
  }
  unbind(e = this.textureUnit) {
    const { gl: s } = this;
    return e !== void 0 && (this.textureUnit = e, s.activeTexture(33984 + e)), s.bindTexture(this.target, null), e;
  }
  // PRIVATE METHODS
  _getDataType({ data: e, compressed: s = !1 }) {
    return s ? { data: e, dataType: "compressed" } : e === null ? { data: e, dataType: "null" } : ArrayBuffer.isView(e) ? { data: e, dataType: "typed-array" } : e instanceof Gt ? { data: e.handle, dataType: "buffer" } : typeof WebGLBuffer < "u" && e instanceof WebGLBuffer ? { data: e, dataType: "buffer" } : { data: e, dataType: "browser-object" };
  }
  // HELPER METHODS
  _deduceParameters(e) {
    const { format: s, data: n } = e;
    let { width: r, height: i, dataFormat: o, type: a, compressed: c } = e;
    const l = Ti(s);
    return o = o || l.dataFormat, a = a || l.type, c = c || l.compressed, { width: r, height: i } = this._deduceImageSize(n, r, i), { dataFormat: o, type: a, compressed: c, width: r, height: i, format: s, data: n };
  }
  // eslint-disable-next-line complexity
  _deduceImageSize(e, s, n) {
    let r;
    return typeof ImageData < "u" && e instanceof ImageData ? r = { width: e.width, height: e.height } : typeof HTMLImageElement < "u" && e instanceof HTMLImageElement ? r = { width: e.naturalWidth, height: e.naturalHeight } : typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement ? r = { width: e.width, height: e.height } : typeof ImageBitmap < "u" && e instanceof ImageBitmap ? r = { width: e.width, height: e.height } : typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? r = { width: e.videoWidth, height: e.videoHeight } : e ? r = { width: s, height: n } : r = { width: s >= 0 ? s : 1, height: n >= 0 ? n : 1 }, q(r, "Could not deduced texture size"), q(s === void 0 || r.width === s, "Deduced texture width does not match supplied width"), q(n === void 0 || r.height === n, "Deduced texture height does not match supplied height"), r;
  }
  // CUBE MAP METHODS
  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData(e) {
    const { gl: s } = this, { width: n, height: r, pixels: i, data: o, format: a = 6408, type: c = 5121 } = e, l = i || o, h = await Promise.all(qe.FACES.map((u) => {
      const f = l[u];
      return Promise.all(Array.isArray(f) ? f : [f]);
    }));
    this.bind(), qe.FACES.forEach((u, f) => {
      h[f].length > 1 && this.props.mipmaps !== !1 && P.warn(`${this.id} has mipmap and multiple LODs.`)(), h[f].forEach((p, m) => {
        n && r ? s.texImage2D(u, m, a, n, r, 0, a, c, p) : s.texImage2D(u, m, a, a, c, p);
      });
    }), this.unbind();
  }
  /** @todo update this method to accept LODs */
  setImageDataForFace(e) {
    const {
      face: s,
      width: n,
      height: r,
      pixels: i,
      data: o,
      format: a = 6408,
      type: c = 5121
      // generateMipmap = false // TODO
    } = e, { gl: l } = this, h = i || o;
    return this.bind(), h instanceof Promise ? h.then((u) => this.setImageDataForFace(Object.assign({}, e, {
      face: s,
      data: u,
      pixels: u
    }))) : this.width || this.height ? l.texImage2D(s, 0, a, n, r, 0, a, c, h) : l.texImage2D(s, 0, a, a, c, h), this;
  }
  /** Image 3D copies from Typed Array or WebGLBuffer */
  setImageData3D(e) {
    const {
      level: s = 0,
      dataFormat: n,
      format: r,
      type: i,
      // = GL.UNSIGNED_BYTE,
      width: o,
      height: a,
      depth: c = 1,
      offset: l = 0,
      data: h,
      parameters: u = {}
    } = e;
    this.trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle);
    const f = Ti(r);
    if (jt(this.gl, u, () => {
      ArrayBuffer.isView(h) && this.gl.texImage3D(
        this.target,
        s,
        f.format,
        o,
        a,
        c,
        0,
        f.dataFormat,
        f.type,
        // dataType: getWebGL,
        h
      ), h instanceof Gt && (this.gl.bindBuffer(35052, h.handle), this.gl.texImage3D(this.target, s, n, o, a, c, 0, r, i, l));
    }), h && h.byteLength)
      this.trackAllocatedMemory(h.byteLength, "Texture");
    else {
      const p = Zh(this.props.format);
      this.trackAllocatedMemory(this.width * this.height * this.depth * p, "Texture");
    }
    return this.loaded = !0, this;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(e) {
    if (!li(e)) {
      FR(e), this.gl.bindTexture(this.target, this.handle);
      for (const [s, n] of Object.entries(e)) {
        const r = Number(s), i = n;
        switch (r) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.target, r, i);
            break;
          default:
            this.gl.texParameteri(this.target, r, i);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
    }
  }
}
function NR(t) {
  switch (t.dimension) {
    // supported in WebGL
    case "2d":
      return 3553;
    case "cube":
      return 34067;
    // supported in WebGL2
    case "2d-array":
      return 35866;
    case "3d":
      return 32879;
    // not supported in any WebGL version
    case "1d":
    case "cube-array":
    default:
      throw new Error(t.dimension);
  }
}
function FR(t) {
  P.log(1, "texture sampler parameters", t)();
}
class zn extends Oi {
  device;
  gl;
  handle;
  get texture() {
    return this.colorAttachments[0];
  }
  constructor(e, s) {
    super(e, s);
    const n = s.handle === null;
    if (this.device = e, this.gl = e.gl, this.handle = this.props.handle || n ? this.props.handle : this.gl.createFramebuffer(), !n) {
      e.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props }), this.autoCreateAttachmentTextures();
      const r = this.gl.bindFramebuffer(36160, this.handle);
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        const o = this.colorAttachments[i], a = 36064 + i;
        o && this._attachOne(a, o);
      }
      if (this.depthStencilAttachment && this._attachOne(bR(this.depthStencilAttachment.props.format), this.depthStencilAttachment), s.check !== !1) {
        const i = this.gl.checkFramebufferStatus(36160);
        if (i !== 36053)
          throw new Error(`Framebuffer ${UR(i)}`);
      }
      this.gl.bindFramebuffer(36160, r);
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  createDepthStencilTexture(e) {
    return new qe(this.device, {
      id: `${this.id}-depth-stencil`,
      format: e,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Attachment resize is expected to be a noop if size is same
   */
  resizeAttachments(e, s) {
    if (this.handle === null)
      return this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    e === void 0 && (e = this.gl.drawingBufferWidth), s === void 0 && (s = this.gl.drawingBufferHeight);
    for (const n of this.colorAttachments)
      n.texture.resize({ width: e, height: s });
    return this.depthStencilAttachment && this.depthStencilAttachment.texture.resize({ width: e, height: s }), this;
  }
  /** Attach one attachment */
  _attachOne(e, s) {
    if (Array.isArray(s)) {
      const [n, r = 0, i = 0] = s;
      return this._attachTexture(e, n, r, i), n;
    }
    if (s instanceof qe)
      return this._attachTexture(e, s, 0, 0), s;
    if (s instanceof Hs) {
      const n = s;
      return this._attachTexture(e, n.texture, n.props.baseMipLevel, n.props.baseArrayLayer), s.texture;
    }
    throw new Error("attach");
  }
  // TODO - we do not seem to need render buffers in WebGL 2
  // protected _attachWEBGLRenderbuffer(attachment: GL, renderbuffer: WEBGLRenderbuffer): void {
  //   this.gl.framebufferRenderbuffer(
  //     GL.FRAMEBUFFER,
  //     attachment,
  //     GL.RENDERBUFFER,
  //     renderbuffer.handle
  //   );
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTexture(e, s, n, r) {
    const { gl: i } = this.device;
    switch (i.bindTexture(s.target, s.handle), s.target) {
      case 35866:
      case 32879:
        i.framebufferTextureLayer(36160, e, s.target, r, n);
        break;
      case 34067:
        const o = DR(n);
        i.framebufferTexture2D(36160, e, o, s.handle, r);
        break;
      case 3553:
        i.framebufferTexture2D(36160, e, 3553, s.handle, r);
        break;
      default:
        q(!1, "Illegal texture type");
    }
    i.bindTexture(s.target, null);
  }
}
function DR(t) {
  return t < 34069 ? t + 34069 : t;
}
function UR(t) {
  switch (t) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${t}`;
  }
}
class LR extends yd {
  device;
  presentationSize;
  _framebuffer = null;
  constructor(e, s) {
    super(s), this.device = e, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new zn(this.device, { handle: null }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const e = this.getPixelSize();
    (e[0] !== this.presentationSize[0] || e[1] !== this.presentationSize[1]) && (this.presentationSize = e, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(e) {
    if (this.device.gl && this.canvas) {
      const s = this.getDevicePixelRatio(e?.useDevicePixels);
      this.setDevicePixelRatio(s, e);
      return;
    }
  }
  commit() {
  }
}
const kR = {
  spector: P.get("spector") || P.get("spectorjs")
}, VR = "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js", HR = 1;
let Re = null, tu = !1;
async function zR(t) {
  if (!globalThis.SPECTOR)
    try {
      await vd(VR);
    } catch (e) {
      P.warn(String(e));
    }
}
function jR(t) {
  if (t = { ...kR, ...t }, !t?.spector || (!Re && globalThis.SPECTOR && (P.probe(HR, "SPECTOR found and initialized")(), Re = new globalThis.SPECTOR.Spector(), globalThis.luma && (globalThis.luma.spector = Re)), !Re))
    return null;
  if (tu || (tu = !0, Re.spyCanvases(), Re?.onCaptureStarted.add((e) => P.info("Spector capture started:", e)()), Re?.onCapture.add((e) => {
    P.info("Spector capture complete:", e)(), Re?.getResultUI(), Re?.resultView.display(), Re?.resultView.addCapture(e);
  })), t?.canvas) {
    if (typeof t.spector == "string" && t.spector !== t.canvas.id)
      return Re;
    Re?.startCapture(t?.canvas, 500), new Promise((e) => setTimeout(e, 2e3)).then((e) => {
      P.info("Spector capture stopped after 2 seconds")(), Re?.stopCapture();
    });
  }
  return Re;
}
const WR = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function Bp(t) {
  return t.luma = t.luma || {}, t.luma;
}
async function XR() {
  Zt() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await vd(WR));
}
function GR(t, e = {}) {
  return t ? e.debug ? KR(t, e) : $R(t) : null;
}
function $R(t) {
  const e = Bp(t);
  return e.realContext ? e.realContext : t;
}
function KR(t, e) {
  if (!globalThis.WebGLDebugUtils)
    return P.warn("webgl-debug not loaded")(), t;
  const s = Bp(t);
  if (s.debugContext)
    return s.debugContext;
  globalThis.WebGLDebugUtils.init({ ...Ls, ...t });
  const n = globalThis.WebGLDebugUtils.makeDebugContext(t, YR.bind(null, e), JR.bind(null, e));
  for (const o in Ls)
    !(o in n) && typeof Ls[o] == "number" && (n[o] = Ls[o]);
  class r {
  }
  Object.setPrototypeOf(n, Object.getPrototypeOf(t)), Object.setPrototypeOf(r, n);
  const i = Object.create(r);
  return s.realContext = t, s.debugContext = i, i.debug = !0, i;
}
function Po(t, e) {
  e = Array.from(e).map((n) => n === void 0 ? "undefined" : n);
  let s = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, e);
  return s = `${s.slice(0, 100)}${s.length > 100 ? "..." : ""}`, `gl.${t}(${s})`;
}
function YR(t, e, s, n) {
  n = Array.from(n).map((a) => a === void 0 ? "undefined" : a);
  const r = globalThis.WebGLDebugUtils.glEnumToString(e), i = globalThis.WebGLDebugUtils.glFunctionArgsToString(s, n), o = `${r} in gl.${s}(${i})`;
  P.error(o)();
  debugger;
  if (t.throwOnError)
    throw new Error(o);
}
function JR(t, e, s) {
  let n = "";
  if (P.level >= 1 && (n = Po(e, s), P.log(1, n)()), t.break && t.break.length > 0 && (n = n || Po(e, s), t.break.every((i) => n.indexOf(i) !== -1)))
    debugger;
  for (const r of s)
    if (r === void 0) {
      if (n = n || Po(e, s), t.throwOnError)
        throw new Error(`Undefined argument: ${n}`);
      P.error(`Undefined argument: ${n}`)();
      debugger;
    }
}
function qR(t) {
  const e = t.split(/\r?\n/), s = [];
  for (const n of e) {
    if (n.length <= 1)
      continue;
    const r = n.split(":");
    if (r.length === 2) {
      const [u, f] = r;
      s.push({
        message: f.trim(),
        type: su(u),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [i, o, a, ...c] = r;
    let l = parseInt(a, 10);
    isNaN(l) && (l = 0);
    let h = parseInt(o, 10);
    isNaN(h) && (h = 0), s.push({
      message: c.join(":").trim(),
      type: su(i),
      lineNum: l,
      linePos: h
      // TODO
    });
  }
  return s;
}
function su(t) {
  const e = ["warning", "error", "info"], s = t.toLowerCase();
  return e.includes(s) ? s : "info";
}
class ZR extends Mi {
  device;
  handle;
  constructor(e, s) {
    switch (super(e, s), this.device = e, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const e = this.device.gl.getShaderInfoLog(this.handle);
    return qR(e);
  }
  getTranslatedSource() {
    return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle);
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(e) {
    e = ((r) => r.startsWith("#version ") ? r : `#version 100
${r}`)(e);
    const { gl: n } = this.device;
    if (n.shaderSource(this.handle, e), n.compileShader(this.handle), P.level === 0) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    P.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), P.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const e = async (r) => await new Promise((i) => setTimeout(i, r));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: n } = this.device;
    for (; ; ) {
      if (n.getShaderParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
const QR = 256, ew = 1024, tw = 16384, Oo = 6144, sw = [1, 2, 4, 8];
class nw extends hc {
  device;
  /** Parameters that should be applied before each draw call */
  glParameters;
  constructor(e, s) {
    super(e, s), this.device = e, Ni(this.device.gl), this.setParameters(this.props.parameters), this.clear();
  }
  end() {
    qn(this.device.gl);
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(e = {}) {
    const s = { ...this.glParameters };
    this.props.framebuffer && (s.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (s.depthMask = !this.props.depthReadOnly), s.stencilMask = this.props.stencilReadOnly ? 0 : 1, s[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (s.viewport = e.viewport.slice(0, 4), s.depthRange = [e.viewport[4], e.viewport[5]]) : s.viewport = e.viewport), e.scissorRect && (s.scissorTest = !0, s.scissor = e.scissorRect), e.blendConstant && (s.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), e[2967] = e.stencilReference), e.colorMask && (s.colorMask = sw.map((n) => !!(n & e.colorMask))), this.glParameters = s, un(this.device.gl, s);
  }
  beginOcclusionQuery(e) {
    this.props.occlusionQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    this.props.occlusionQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const e = { ...this.glParameters };
    let s = 0;
    this.props.clearColor !== !1 && (s |= tw, e.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (s |= QR, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (s |= ew, e.clearStencil = this.props.clearStencil), s !== 0 && jt(this.device.gl, e, () => {
      this.device.gl.clear(s);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(e = 0, s = [0, 0, 0, 0]) {
    jt(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (s.constructor) {
        case Int32Array:
          this.device.gl.clearBufferiv(Oo, e, s);
          break;
        case Uint32Array:
          this.device.gl.clearBufferuiv(Oo, e, s);
          break;
        case Float32Array:
        default:
          this.device.gl.clearBufferfv(Oo, e, s);
          break;
      }
    });
  }
}
const rw = "Failed to deduce GL constant from typed array";
function iw(t) {
  switch (ArrayBuffer.isView(t) ? t.constructor : t) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(rw);
  }
}
function Oa(t, e) {
  const { clamped: s = !0 } = e || {};
  switch (t) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return s ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
const ow = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, aw = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class jn {
  offset;
  stride;
  type;
  size;
  divisor;
  normalized;
  integer;
  buffer;
  index;
  static getBytesPerElement(e) {
    return Oa(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return q(e.size), Oa(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...e) {
    return new jn(ow, ...e);
  }
  constructor(...e) {
    e.forEach((s) => this._assign(s)), Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  // ACCESSORS
  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return jn.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return jn.getBytesPerVertex(this);
  }
  // PRIVATE
  // eslint-disable-next-line complexity, max-statements
  _assign(e = {}) {
    return e = eb("Accessor", e, aw), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalize !== void 0 && (this.normalized = e.normalize), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this;
  }
}
function cw(t) {
  return lw.includes(t);
}
const lw = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
], Mp = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function Pp(t) {
  const e = Mp[t];
  if (!e)
    throw new Error("uniform");
  const [s, n, , r] = e;
  return { format: r, components: n, glType: s };
}
function hw(t) {
  const e = Mp[t];
  if (!e)
    throw new Error("attribute");
  const [, s, , n, r] = e;
  return { attributeType: n, vertexFormat: r, components: s };
}
function uw(t, e) {
  const s = {
    attributes: [],
    bindings: []
  };
  s.attributes = fw(t, e);
  const n = _w(t, e);
  for (const a of n) {
    const c = a.uniforms.map((l) => ({
      name: l.name,
      format: l.format,
      byteOffset: l.byteOffset,
      byteStride: l.byteStride,
      arrayLength: l.arrayLength
    }));
    s.bindings.push({
      type: "uniform",
      name: a.name,
      location: a.location,
      visibility: (a.vertex ? 1 : 0) & (a.fragment ? 2 : 0),
      minBindingSize: a.byteLength,
      uniforms: c
    });
  }
  const r = pw(t, e);
  let i = 0;
  for (const a of r)
    if (cw(a.type)) {
      const { viewDimension: c, sampleType: l } = mw(a.type);
      s.bindings.push({
        type: "texture",
        name: a.name,
        location: i,
        viewDimension: c,
        sampleType: l
      }), a.textureUnit = i, i += 1;
    }
  r.length && (s.uniforms = r);
  const o = dw(t, e);
  return o?.length && (s.varyings = o), s;
}
function fw(t, e) {
  const s = [], n = t.getProgramParameter(e, 35721);
  for (let r = 0; r < n; r++) {
    const i = t.getActiveAttrib(e, r);
    if (!i)
      throw new Error("activeInfo");
    const {
      name: o,
      type: a
      /* , size*/
    } = i, c = t.getAttribLocation(e, o);
    if (c >= 0) {
      const { attributeType: l } = hw(a), h = /instance/i.test(o) ? "instance" : "vertex";
      s.push({
        name: o,
        location: c,
        stepMode: h,
        type: l
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return s.sort((r, i) => r.location - i.location), s;
}
function dw(t, e) {
  const s = [], n = t.getProgramParameter(e, 35971);
  for (let r = 0; r < n; r++) {
    const i = t.getTransformFeedbackVarying(e, r);
    if (!i)
      throw new Error("activeInfo");
    const { name: o, type: a, size: c } = i, { glType: l, components: h } = Pp(a), u = new jn({ type: l, size: c * h }), f = { location: r, name: o, accessor: u };
    s.push(f);
  }
  return s.sort((r, i) => r.location - i.location), s;
}
function pw(t, e) {
  const s = [], n = t.getProgramParameter(e, 35718);
  for (let r = 0; r < n; r++) {
    const i = t.getActiveUniform(e, r);
    if (!i)
      throw new Error("activeInfo");
    const { name: o, size: a, type: c } = i, { name: l, isArray: h } = Aw(o);
    let u = t.getUniformLocation(e, l);
    const f = {
      // WebGL locations are uniquely typed but just numbers
      location: u,
      name: l,
      size: a,
      type: c,
      isArray: h
    };
    if (s.push(f), f.size > 1)
      for (let p = 0; p < f.size; p++) {
        const m = `${l}[${p}]`;
        u = t.getUniformLocation(e, m);
        const A = {
          ...f,
          name: m,
          location: u
        };
        s.push(A);
      }
  }
  return s;
}
function _w(t, e) {
  const s = (i, o) => t.getActiveUniformBlockParameter(e, i, o), n = [], r = t.getProgramParameter(e, 35382);
  for (let i = 0; i < r; i++) {
    const o = {
      name: t.getActiveUniformBlockName(e, i) || "",
      location: s(i, 35391),
      byteLength: s(i, 35392),
      vertex: s(i, 35396),
      fragment: s(i, 35398),
      uniformCount: s(i, 35394),
      uniforms: []
    }, a = s(i, 35395) || [], c = t.getActiveUniforms(e, a, 35383), l = t.getActiveUniforms(e, a, 35384), h = t.getActiveUniforms(e, a, 35387), u = t.getActiveUniforms(e, a, 35388);
    for (let f = 0; f < o.uniformCount; ++f) {
      const p = t.getActiveUniform(e, a[f]);
      if (!p)
        throw new Error("activeInfo");
      o.uniforms.push({
        name: p.name,
        format: Pp(c[f]).format,
        type: c[f],
        arrayLength: l[f],
        byteOffset: h[f],
        byteStride: u[f]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    n.push(o);
  }
  return n.sort((i, o) => i.location - o.location), n;
}
const gw = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function mw(t) {
  const e = gw[t];
  if (!e)
    throw new Error("sampler");
  const [s, n] = e;
  return { viewDimension: s, sampleType: n };
}
function Aw(t) {
  if (t[t.length - 1] !== "]")
    return {
      name: t,
      length: 1,
      isArray: !1
    };
  const s = /([^[]*)(\[[0-9]+\])?/.exec(t);
  if (!s || s.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${t}`);
  return {
    name: s[1],
    length: s[2] ? 1 : 0,
    isArray: !!s[2]
  };
}
function Tw(t, e, s, n) {
  const r = t;
  let i = n;
  i === !0 && (i = 1), i === !1 && (i = 0);
  const o = typeof i == "number" ? [i] : i;
  switch (s) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof n != "number")
        throw new Error("samplers must be set to integers");
      return t.uniform1i(e, n);
    case 5126:
      return t.uniform1fv(e, o);
    case 35664:
      return t.uniform2fv(e, o);
    case 35665:
      return t.uniform3fv(e, o);
    case 35666:
      return t.uniform4fv(e, o);
    case 5124:
      return t.uniform1iv(e, o);
    case 35667:
      return t.uniform2iv(e, o);
    case 35668:
      return t.uniform3iv(e, o);
    case 35669:
      return t.uniform4iv(e, o);
    case 35670:
      return t.uniform1iv(e, o);
    case 35671:
      return t.uniform2iv(e, o);
    case 35672:
      return t.uniform3iv(e, o);
    case 35673:
      return t.uniform4iv(e, o);
    // WEBGL2 - unsigned integers
    case 5125:
      return r.uniform1uiv(e, o, 1);
    case 36294:
      return r.uniform2uiv(e, o, 2);
    case 36295:
      return r.uniform3uiv(e, o, 3);
    case 36296:
      return r.uniform4uiv(e, o, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return t.uniformMatrix2fv(e, !1, o);
    case 35675:
      return t.uniformMatrix3fv(e, !1, o);
    case 35676:
      return t.uniformMatrix4fv(e, !1, o);
    // WebGL2 - rectangular matrices
    case 35685:
      return r.uniformMatrix2x3fv(e, !1, o);
    case 35686:
      return r.uniformMatrix2x4fv(e, !1, o);
    case 35687:
      return r.uniformMatrix3x2fv(e, !1, o);
    case 35688:
      return r.uniformMatrix3x4fv(e, !1, o);
    case 35689:
      return r.uniformMatrix4x2fv(e, !1, o);
    case 35690:
      return r.uniformMatrix4x3fv(e, !1, o);
  }
  throw new Error("Illegal uniform");
}
function yw(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "line-loop-webgl":
      return 2;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    case "triangle-fan-webgl":
      return 6;
    default:
      throw new Error(t);
  }
}
function bw(t) {
  switch (t) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "line-loop-webgl":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    case "triangle-fan-webgl":
      return 4;
    default:
      throw new Error(t);
  }
}
const nu = 4;
class Ew extends Qs {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  constructor(e, s) {
    super(e, s), this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, { id: this.props.id }), this.vs = s.vs, this.fs = s.fs;
    const { varyings: n, bufferMode: r = 35981 } = s;
    switch (n && n.length > 0 && (this.varyings = n, this.device.gl.transformFeedbackVaryings(this.handle, n, r)), this._linkShaders(), P.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = uw(this.device.gl, this.handle), P.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = Hy(this.introspectedLayout, s.shaderLayout), this.props.topology) {
      case "triangle-fan-webgl":
      case "line-loop-webgl":
        P.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
    }
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(e, s) {
    for (const [n, r] of Object.entries(e)) {
      const i = this.shaderLayout.bindings.find((o) => o.name === n) || this.shaderLayout.bindings.find((o) => o.name === `${n}Uniforms`);
      if (!i) {
        const o = this.shaderLayout.bindings.map((a) => `"${a.name}"`).join(", ");
        s?.disableWarnings || P.warn(`Unknown binding "${n}" in render pipeline "${this.id}", expected one of ${o}`)();
        continue;
      }
      switch (r || P.warn(`Unsetting binding "${n}" in render pipeline "${this.id}"`)(), i.type) {
        case "uniform":
          if (!(r instanceof Gt) && !(r.buffer instanceof Gt))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(r instanceof Hs || r instanceof qe || r instanceof zn))
            throw new Error("texture value");
          break;
        case "sampler":
          P.warn(`Ignoring sampler ${n}`)();
          break;
        default:
          throw new Error(i.type);
      }
      this.bindings[n] = r;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(e) {
    const {
      renderPass: s,
      parameters: n = this.props.parameters,
      topology: r = this.props.topology,
      vertexArray: i,
      vertexCount: o,
      // indexCount,
      instanceCount: a,
      isInstanced: c = !1,
      firstVertex: l = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: h
    } = e, u = yw(r), f = !!i.indexBuffer, p = i.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success")
      return P.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable() || o === 0)
      return P.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    if (o === 0)
      return P.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
    this.device.gl.useProgram(this.handle), i.bindBeforeRender(s), h && h.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const m = s;
    return wR(this.device, n, m.glParameters, () => {
      f && c ? this.device.gl.drawElementsInstanced(
        u,
        o || 0,
        // indexCount?
        p,
        l,
        a || 0
      ) : f ? this.device.gl.drawElements(u, o || 0, p, l) : c ? this.device.gl.drawArraysInstanced(u, l, o || 0, a || 0) : this.device.gl.drawArrays(u, l, o || 0), h && h.end();
    }), i.unbindAfterRender(s), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(e) {
    const { bindings: s } = gc(e);
    Object.keys(s).forEach((n) => {
      P.warn(`Unsupported value "${JSON.stringify(s[n])}" used in setUniforms() for key ${n}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, e);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl: e } = this.device;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), P.time(nu, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), P.timeEnd(nu, `linkProgram for ${this.id}`)(), P.level, !this.device.features.has("compilation-status-async-webgl")) {
      const n = this._getLinkStatus();
      this._reportLinkStatus(n);
      return;
    }
    P.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), P.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const s = this._getLinkStatus();
    this._reportLinkStatus(s);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  _reportLinkStatus(e) {
    switch (e) {
      case "success":
        return;
      default:
        throw this.vs.compilationStatus === "error" ? (this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`)) : this.fs?.compilationStatus === "error" ? (this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`)) : new Error(`Error during ${e}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl: e } = this.device;
    return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const e = async (r) => await new Promise((i) => setTimeout(i, r));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: n } = this.device;
    for (; ; ) {
      if (n.getProgramParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let e = !0;
    for (const [, s] of Object.entries(this.bindings))
      s instanceof qe && (s.update(), e = e && s.loaded);
    return e;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const { gl: e } = this.device;
    e.useProgram(this.handle);
    let s = 0, n = 0;
    for (const r of this.shaderLayout.bindings) {
      const i = this.bindings[r.name] || this.bindings[r.name.replace(/Uniforms$/, "")];
      if (!i)
        throw new Error(`No value for binding ${r.name} in ${this.id}`);
      switch (r.type) {
        case "uniform":
          const { name: o } = r, a = e.getUniformBlockIndex(this.handle, o);
          if (a === 4294967295)
            throw new Error(`Invalid uniform block name ${o}`);
          e.uniformBlockBinding(this.handle, n, a), i instanceof Gt ? e.bindBufferBase(35345, n, i.handle) : e.bindBufferRange(
            35345,
            n,
            // @ts-expect-error
            i.buffer.handle,
            // @ts-expect-error
            i.offset || 0,
            // @ts-expect-error
            i.size || i.buffer.byteLength - i.offset
          ), n += 1;
          break;
        case "texture":
          if (!(i instanceof Hs || i instanceof qe || i instanceof zn))
            throw new Error("texture");
          let c;
          if (i instanceof Hs)
            c = i.texture;
          else if (i instanceof qe)
            c = i;
          else if (i instanceof zn && i.colorAttachments[0] instanceof Hs)
            P.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), c = i.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          e.activeTexture(33984 + s), e.bindTexture(c.target, c.handle), s += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${r.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const e of this.shaderLayout.uniforms || []) {
      const { name: s, location: n, type: r, textureUnit: i } = e, o = this.uniforms[s] ?? i;
      o !== void 0 && Tw(this.device.gl, n, r, o);
    }
  }
}
class Cw extends fc {
  device;
  commands = [];
  constructor(e) {
    super(e, {}), this.device = e;
  }
  submitCommands(e = this.commands) {
    for (const s of e)
      switch (s.name) {
        case "copy-buffer-to-buffer":
          Sw(this.device, s.options);
          break;
        case "copy-buffer-to-texture":
          Rw(this.device, s.options);
          break;
        case "copy-texture-to-buffer":
          ww(this.device, s.options);
          break;
        case "copy-texture-to-texture":
          Iw(this.device, s.options);
          break;
      }
  }
}
function Sw(t, e) {
  const s = e.source, n = e.destination;
  t.gl.bindBuffer(36662, s.handle), t.gl.bindBuffer(36663, n.handle), t.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), t.gl.bindBuffer(36662, null), t.gl.bindBuffer(36663, null);
}
function Rw(t, e) {
  throw new Error("Not implemented");
}
function ww(t, e) {
  const {
    /** Texture to copy to/from. */
    source: s,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: r = "all",
    /** Width to copy */
    width: i = e.source.width,
    /** Height to copy */
    height: o = e.source.height,
    depthOrArrayLayers: a = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: c = [0, 0],
    /** Destination buffer */
    destination: l,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: h = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: u,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: f
  } = e;
  if (r !== "all")
    throw new Error("not supported");
  if (n !== 0 || a !== 0 || u || f)
    throw new Error("not implemented");
  const { framebuffer: p, destroyFramebuffer: m } = Op(s);
  let A;
  try {
    const E = l, C = i || p.width, w = o || p.height, I = Ti(p.texture.props.format), B = I.dataFormat, x = I.type;
    t.gl.bindBuffer(35051, E.handle), A = t.gl.bindFramebuffer(36160, p.handle), t.gl.readPixels(c[0], c[1], C, w, B, x, h);
  } finally {
    t.gl.bindBuffer(35051, null), A !== void 0 && t.gl.bindFramebuffer(36160, A), m && p.destroy();
  }
}
function Iw(t, e) {
  const {
    /** Texture to copy to/from. */
    source: s,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: r = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: i = [0, 0],
    /** Texture to copy to/from. */
    destination: o
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: a = e.destination.width,
    height: c = e.destination.height
    // depthOrArrayLayers = 0
  } = e;
  const { framebuffer: l, destroyFramebuffer: h } = Op(s), [u, f] = r, [p, m, A] = i, E = t.gl.bindFramebuffer(36160, l.handle);
  let C = null, w;
  if (o instanceof qe)
    C = o, a = Number.isFinite(a) ? a : C.width, c = Number.isFinite(c) ? c : C.height, C.bind(0), w = C.target;
  else
    throw new Error("invalid destination");
  switch (w) {
    case 3553:
    case 34067:
      t.gl.copyTexSubImage2D(w, n, p, m, u, f, a, c);
      break;
    case 35866:
    case 32879:
      t.gl.copyTexSubImage3D(w, n, p, m, A, u, f, a, c);
      break;
  }
  C && C.unbind(), t.gl.bindFramebuffer(36160, E), h && l.destroy();
}
function Op(t) {
  if (t instanceof Ne) {
    const { width: e, height: s, id: n } = t;
    return { framebuffer: t.device.createFramebuffer({
      id: `framebuffer-for-${n}`,
      width: e,
      height: s,
      colorAttachments: [t]
    }), destroyFramebuffer: !0 };
  }
  return { framebuffer: t, destroyFramebuffer: !1 };
}
class vw extends uc {
  device;
  commandBuffer;
  constructor(e, s) {
    super(e, s), this.device = e, this.commandBuffer = new Cw(e);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options: e });
  }
  copyBufferToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options: e });
  }
  copyTextureToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options: e });
  }
  copyTextureToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options: e });
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  resolveQuerySet(e, s, n) {
  }
}
class kc extends dc {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(e) {
    return Ug() === "Chrome";
  }
  // Create a VertexArray
  constructor(e, s) {
    super(e, s), this.device = e, this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(e) {
    const s = e;
    if (s && s.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, s ? s.handle : null), this.indexBuffer = s, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(e, s) {
    const n = s;
    if (n.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const { size: r, type: i, stride: o, offset: a, normalized: c, integer: l, divisor: h } = this._getAccessor(e);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, n.handle), l ? this.device.gl.vertexAttribIPointer(e, r, i, o, a) : this.device.gl.vertexAttribPointer(e, r, i, c, o, a), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, h || 0), this.attributes[e] = n, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(e, s) {
    this._enable(e, !1), this.attributes[e] = s;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let e = 0; e < this.maxVertexAttributes; ++e) {
      const s = this.attributes[e];
      ArrayBuffer.isView(s) && this.device.setConstantAttributeWebGL(e, s);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(e) {
    const s = this.attributeInfos[e];
    if (!s)
      throw new Error(`Unknown attribute location ${e}`);
    const n = Rp(s.bufferDataType);
    return {
      size: s.bufferComponents,
      type: n,
      stride: s.byteStride,
      offset: s.byteOffset,
      normalized: s.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: s.integer,
      divisor: s.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(e, s = !0) {
    const r = kc.isConstantAttributeZeroSupported(this.device) || e !== 0;
    (s || r) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), s ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(e, s) {
    const n = Bw(s), r = n.byteLength * e, i = n.length * e;
    if (this.buffer && r !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${r} !== ${this.buffer.byteLength}.`);
    let o = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({ byteLength: r }), o = o || !Mw(n, this.bufferValue), o) {
      const a = Xy(s.constructor, i);
      Gy({ target: a, source: n, start: 0, count: i }), this.buffer.write(a), this.bufferValue = s;
    }
    return this.buffer;
  }
}
function Bw(t) {
  return Array.isArray(t) ? new Float32Array(t) : t;
}
function Mw(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let s = 0; s < t.length; ++s)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
class Pw extends pc {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = !0;
  _bound = !1;
  constructor(e, s) {
    super(e, s), this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, s.buffers && this.setBuffers(s.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(e = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(bw(e));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(e) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const s in e)
        this.setBuffer(s, e[s]);
    });
  }
  setBuffer(e, s) {
    const n = this._getVaryingIndex(e), { buffer: r, byteLength: i, byteOffset: o } = this._getBufferRange(s);
    if (n < 0) {
      this.unusedBuffers[e] = r, P.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
      return;
    }
    this.buffers[n] = { buffer: r, byteLength: i, byteOffset: o }, this.bindOnUse || this._bindBuffer(n, r, o, i);
  }
  getBuffer(e) {
    if (ru(e))
      return this.buffers[e] || null;
    const s = this._getVaryingIndex(e);
    return s >= 0 ? this.buffers[s] : null;
  }
  bind(e = this.handle) {
    if (typeof e != "function")
      return this.gl.bindTransformFeedback(36386, e), this;
    let s;
    return this._bound ? s = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, s = e(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), s;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(e) {
    if (e instanceof Gt)
      return { buffer: e, byteOffset: 0, byteLength: e.byteLength };
    const { buffer: s, byteOffset: n = 0, byteLength: r = e.buffer.byteLength } = e;
    return { buffer: s, byteOffset: n, byteLength: r };
  }
  _getVaryingIndex(e) {
    if (ru(e))
      return Number(e);
    for (const s of this.layout.varyings)
      if (e === s.name)
        return s.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const e in this.buffers) {
      const { buffer: s, byteLength: n, byteOffset: r } = this._getBufferRange(this.buffers[e]);
      this._bindBuffer(Number(e), s, r, n);
    }
  }
  _unbindBuffers() {
    for (const e in this.buffers)
      this.gl.bindBufferBase(35982, Number(e), null);
  }
  _bindBuffer(e, s, n = 0, r) {
    const i = s && s.handle;
    !i || r === void 0 ? this.gl.bindBufferBase(35982, e, i) : this.gl.bindBufferRange(35982, e, i, n, r);
  }
}
function ru(t) {
  return typeof t == "number" ? Number.isInteger(t) : /^\d+$/.test(t);
}
class Ow extends _c {
  device;
  handle;
  target = null;
  _queryPending = !1;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(e, s) {
    if (super(e, s), this.device = e, s.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(e) {
    return this._begin(e?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(e) {
    this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.device.gl.getQueryParameter(this.handle, 34919);
    return e && (this._queryPending = !1), e;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(e = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let s = 0;
    return this._pollingPromise = new Promise((n, r) => {
      const i = () => {
        this.isResultAvailable() ? (n(this.getResult()), this._pollingPromise = null) : s++ > e ? (r("Timed out"), this._pollingPromise = null) : requestAnimationFrame(i);
      };
      requestAnimationFrame(i);
    }), this._pollingPromise;
  }
}
function xp(t) {
  switch (t) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return q(!1), 0;
  }
}
function xw(t) {
  switch (t) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return q(!1), 0;
  }
}
function Nw(t, e) {
  const {
    sourceX: s = 0,
    sourceY: n = 0,
    sourceFormat: r = 6408,
    sourceAttachment: i = 36064
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: o = null,
    // following parameters are auto deduced if not provided
    sourceWidth: a,
    sourceHeight: c,
    sourceType: l
  } = e || {};
  const { framebuffer: h, deleteFramebuffer: u } = Np(t);
  q(h);
  const { gl: f, handle: p } = h;
  a = a || h.width, c = c || h.height;
  const m = i - 36064;
  l = l || h.colorAttachments[m]?.texture?.type || 5121, o = Uw(o, l, r, a, c), l = l || iw(o);
  const A = f.bindFramebuffer(36160, p);
  return f.readPixels(s, n, a, c, r, l, o), f.bindFramebuffer(36160, A || null), u && h.destroy(), o;
}
function Fw(t, e) {
  const { target: s, sourceX: n = 0, sourceY: r = 0, sourceFormat: i = 6408, targetByteOffset: o = 0 } = e || {};
  let { sourceWidth: a, sourceHeight: c, sourceType: l } = e || {};
  const { framebuffer: h, deleteFramebuffer: u } = Np(t);
  q(h), a = a || h.width, c = c || h.height;
  const f = h;
  l = l || 5121;
  let p = s;
  if (!p) {
    const A = xp(i), E = xw(l), C = o + a * c * A * E;
    p = f.device.createBuffer({ byteLength: C });
  }
  const m = t.device.createCommandEncoder();
  return m.copyTextureToBuffer({
    source: t,
    width: a,
    height: c,
    origin: [n, r],
    destination: p,
    byteOffset: o
  }), m.destroy(), u && h.destroy(), p;
}
function Np(t) {
  return t instanceof Oi ? { framebuffer: t, deleteFramebuffer: !1 } : { framebuffer: Dw(t), deleteFramebuffer: !0 };
}
function Dw(t, e) {
  const { device: s, width: n, height: r, id: i } = t;
  return s.createFramebuffer({
    ...e,
    id: `framebuffer-for-${i}`,
    width: n,
    height: r,
    colorAttachments: [t]
  });
}
function Uw(t, e, s, n, r) {
  if (t)
    return t;
  e = e || 5121;
  const i = Oa(e, { clamped: !1 }), o = xp(s);
  return new i(n * r * o);
}
const Lw = 256, kw = 1024, Vw = 16384, Hw = "clear: bad arguments";
function zw(t, e) {
  const { framebuffer: s = null, color: n = null, depth: r = null, stencil: i = null } = e || {}, o = {};
  s && (o.framebuffer = s);
  let a = 0;
  n && (a |= Vw, n !== !0 && (o.clearColor = n)), r && (a |= Lw, r !== !0 && (o.clearDepth = r)), i && (a |= kw, r !== !0 && (o.clearStencil = r)), q(a !== 0, Hw);
  const c = t.gl;
  jt(c, o, () => {
    c.clear(a);
  });
}
const wn = 1;
class Wt extends Zs {
  //
  // Public `Device` API
  //
  /** type of this device */
  static type = "webgl";
  /** type of this device */
  type = "webgl";
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  lost;
  _resolveContextLost;
  //
  // Static methods, expected to be present by `luma.createDevice()`
  //
  /** Check if WebGL 2 is available */
  static isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /**
   * Get a device instance from a GL context
   * Creates and instruments the device if not already created
   * @param gl
   * @returns
   */
  static attach(e) {
    if (e instanceof Wt)
      return e;
    if (e?.device instanceof Zs)
      return e.device;
    if (!jw(e))
      throw new Error("Invalid WebGL2RenderingContext");
    return new Wt({ gl: e });
  }
  static async create(e = {}) {
    P.groupCollapsed(wn, "WebGLDevice created")();
    const s = [];
    e.debug && s.push(XR()), e.spector && s.push(zR()), typeof e.canvas == "string" && s.push(yd.pageLoaded);
    const n = await Promise.allSettled(s);
    for (const o of n)
      o.status === "rejected" && P.error(`Failed to initialize debug libraries ${o.reason}`)();
    if (P.probe(wn + 1, "DOM is loaded")(), e.gl?.device)
      return P.warn("reattaching existing device")(), Wt.attach(e.gl);
    const r = new Wt(e), i = `Created ${r.type}${r.debug ? " debug" : ""} context: ${r.info.vendor}, ${r.info.renderer} for canvas: ${r.canvasContext.id}`;
    return P.probe(wn, i)(), P.table(wn, r.info)(), P.groupEnd(wn)(), r;
  }
  //
  // Public API
  //
  constructor(e) {
    super({ ...e, id: e.id || Qt("webgl-device") });
    const s = e.gl?.device;
    if (s)
      throw new Error(`WebGL context already attached to device ${s.id}`);
    const n = e.gl?.canvas || e.canvas;
    this.canvasContext = new LR(this, { ...e, canvas: n }), this.lost = new Promise((a) => {
      this._resolveContextLost = a;
    });
    let r = e.gl || null;
    if (r ||= nR(this.canvasContext.canvas, {
      ...e,
      onContextLost: (a) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      })
    }), !r)
      throw new Error("WebGL context creation failed");
    this.handle = r, this.gl = r, this.gl.device = this, this.gl._version = 2, e.spector && (this.spectorJS = jR({ ...this.props, canvas: this.handle.canvas })), this.info = rR(this.gl, this._extensions), this.limits = new SR(this.gl), this.features = new CR(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
    const { enable: i = !0, copyState: o = !1 } = e;
    Cp(this.gl, {
      enable: i,
      copyState: o
    }), e.debug && (this.gl = GR(this.gl, { ...e, throwOnError: !0 }), this.debug = !0, P.level = Math.max(P.level, 1), P.warn("WebGL debug mode activated. Performance reduced.")());
  }
  /**
   * Destroys the context
   * @note Has no effect for WebGL browser contexts, there is no browser API for destroying contexts
   */
  destroy() {
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  getSize() {
    return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
  }
  isTextureFormatSupported(e) {
    return Lc(this.gl, e, this._extensions);
  }
  isTextureFormatFilterable(e) {
    return TR(this.gl, e, this._extensions);
  }
  isTextureFormatRenderable(e) {
    return yR(this.gl, e, this._extensions);
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(e) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(e) {
    const s = this._getBufferProps(e);
    return new Gt(this, s);
  }
  _createTexture(e) {
    return new qe(this, e);
  }
  createExternalTexture(e) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(e) {
    return new Pa(this, e);
  }
  createShader(e) {
    return new ZR(this, e);
  }
  createFramebuffer(e) {
    return new zn(this, e);
  }
  createVertexArray(e) {
    return new kc(this, e);
  }
  createTransformFeedback(e) {
    return new Pw(this, e);
  }
  createQuerySet(e) {
    return new Ow(this, e);
  }
  createRenderPipeline(e) {
    return new Ew(this, e);
  }
  beginRenderPass(e) {
    return new nw(this, e);
  }
  createComputePipeline(e) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(e) {
    throw new Error("ComputePass not supported in WebGL");
  }
  renderPass = null;
  createCommandEncoder(e) {
    return new vw(this, e);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    this.renderPass?.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(e, s) {
    return Nw(e, s);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(e, s) {
    return Fw(e, s);
  }
  setParametersWebGL(e) {
    un(this.gl, e);
  }
  getParametersWebGL(e) {
    return Ep(this.gl, e);
  }
  withParametersWebGL(e, s) {
    return jt(this.gl, e, s);
  }
  clearWebGL(e) {
    zw(this, e);
  }
  resetWebGL() {
    P.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), JS(this.gl);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /** WebGL2 context. */
  gl;
  debug = !1;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = !1;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let e = !1;
    const n = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return n && (e = !0, n.loseContext()), this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    }), e;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    Ni(this.gl);
  }
  /** Restores previously saved context state */
  popState() {
    qn(this.gl);
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(e, s) {
    e.__SPECTOR_Metadata = s;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(e, s) {
    s = s || this.gl2 || this.gl;
    const n = Number(e);
    for (const r in s)
      if (s[r] === n)
        return `GL.${r}`;
    return String(e);
  }
  /** Store constants */
  _constants;
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(e, s) {
    const n = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(n).fill(null);
    const r = this._constants[e];
    switch (r && $w(r, s) && P.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = s, s.constructor) {
      case Float32Array:
        Ww(this, e, s);
        break;
      case Int32Array:
        Xw(this, e, s);
        break;
      case Uint32Array:
        Gw(this, e, s);
        break;
      default:
        q(!1);
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(e) {
    return Jt(this.gl, e, this._extensions), this._extensions;
  }
}
function jw(t) {
  return typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext ? !0 : !!(t && Number.isFinite(t._version));
}
function Ww(t, e, s) {
  switch (s.length) {
    case 1:
      t.gl.vertexAttrib1fv(e, s);
      break;
    case 2:
      t.gl.vertexAttrib2fv(e, s);
      break;
    case 3:
      t.gl.vertexAttrib3fv(e, s);
      break;
    case 4:
      t.gl.vertexAttrib4fv(e, s);
      break;
    default:
      q(!1);
  }
}
function Xw(t, e, s) {
  t.gl.vertexAttribI4iv(e, s);
}
function Gw(t, e, s) {
  t.gl.vertexAttribI4uiv(e, s);
}
function $w(t, e) {
  if (!t || !e || t.length !== e.length || t.constructor !== e.constructor)
    return !1;
  for (let s = 0; s < t.length; ++s)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
var xo = { exports: {} };
var iu;
function Kw() {
  return iu || (iu = 1, (function(t) {
    (function(e, s, n, r) {
      var i = ["", "webkit", "Moz", "MS", "ms", "o"], o = s.createElement("div"), a = "function", c = Math.round, l = Math.abs, h = Date.now;
      function u(d, _, T) {
        return setTimeout(I(d, T), _);
      }
      function f(d, _, T) {
        return Array.isArray(d) ? (p(d, T[_], T), !0) : !1;
      }
      function p(d, _, T) {
        var v;
        if (d)
          if (d.forEach)
            d.forEach(_, T);
          else if (d.length !== r)
            for (v = 0; v < d.length; )
              _.call(T, d[v], v, d), v++;
          else
            for (v in d)
              d.hasOwnProperty(v) && _.call(T, d[v], v, d);
      }
      function m(d, _, T) {
        var v = "DEPRECATED METHOD: " + _ + `
` + T + ` AT 
`;
        return function() {
          var M = new Error("get-stack-trace"), D = M && M.stack ? M.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", j = e.console && (e.console.warn || e.console.log);
          return j && j.call(e.console, v, D), d.apply(this, arguments);
        };
      }
      var A;
      typeof Object.assign != "function" ? A = function(_) {
        if (_ === r || _ === null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var T = Object(_), v = 1; v < arguments.length; v++) {
          var M = arguments[v];
          if (M !== r && M !== null)
            for (var D in M)
              M.hasOwnProperty(D) && (T[D] = M[D]);
        }
        return T;
      } : A = Object.assign;
      var E = m(function(_, T, v) {
        for (var M = Object.keys(T), D = 0; D < M.length; )
          (!v || v && _[M[D]] === r) && (_[M[D]] = T[M[D]]), D++;
        return _;
      }, "extend", "Use `assign`."), C = m(function(_, T) {
        return E(_, T, !0);
      }, "merge", "Use `assign`.");
      function w(d, _, T) {
        var v = _.prototype, M;
        M = d.prototype = Object.create(v), M.constructor = d, M._super = v, T && A(M, T);
      }
      function I(d, _) {
        return function() {
          return d.apply(_, arguments);
        };
      }
      function B(d, _) {
        return typeof d == a ? d.apply(_ && _[0] || r, _) : d;
      }
      function x(d, _) {
        return d === r ? _ : d;
      }
      function N(d, _, T) {
        p(U(_), function(v) {
          d.addEventListener(v, T, !1);
        });
      }
      function L(d, _, T) {
        p(U(_), function(v) {
          d.removeEventListener(v, T, !1);
        });
      }
      function k(d, _) {
        for (; d; ) {
          if (d == _)
            return !0;
          d = d.parentNode;
        }
        return !1;
      }
      function F(d, _) {
        return d.indexOf(_) > -1;
      }
      function U(d) {
        return d.trim().split(/\s+/g);
      }
      function H(d, _, T) {
        if (d.indexOf && !T)
          return d.indexOf(_);
        for (var v = 0; v < d.length; ) {
          if (T && d[v][T] == _ || !T && d[v] === _)
            return v;
          v++;
        }
        return -1;
      }
      function Y(d) {
        return Array.prototype.slice.call(d, 0);
      }
      function te(d, _, T) {
        for (var v = [], M = [], D = 0; D < d.length; ) {
          var j = d[D][_];
          H(M, j) < 0 && v.push(d[D]), M[D] = j, D++;
        }
        return v = v.sort(function(ge, Ce) {
          return ge[_] > Ce[_];
        }), v;
      }
      function z(d, _) {
        for (var T, v, M = _[0].toUpperCase() + _.slice(1), D = 0; D < i.length; ) {
          if (T = i[D], v = T ? T + M : _, v in d)
            return v;
          D++;
        }
        return r;
      }
      var me = 1;
      function es() {
        return me++;
      }
      function yt(d) {
        var _ = d.ownerDocument || d;
        return _.defaultView || _.parentWindow || e;
      }
      var Xi = /mobile|tablet|ip(ad|hone|od)|android/i, dn = "ontouchstart" in e, nt = z(e, "PointerEvent") !== r, Ss = dn && Xi.test(navigator.userAgent), rt = "touch", tg = "pen", Gi = "mouse", sg = "kinect", ng = 25, Ee = 1, ts = 2, ce = 4, Se = 8, fr = 1, pn = 2, _n = 4, gn = 8, mn = 16, it = pn | _n, ss = gn | mn, al = it | ss, cl = ["x", "y"], dr = ["clientX", "clientY"];
      function De(d, _) {
        var T = this;
        this.manager = d, this.callback = _, this.element = d.element, this.target = d.options.inputTarget, this.domHandler = function(v) {
          B(d.options.enable, [d]) && T.handler(v);
        }, this.init();
      }
      De.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && N(this.element, this.evEl, this.domHandler), this.evTarget && N(this.target, this.evTarget, this.domHandler), this.evWin && N(yt(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && L(this.element, this.evEl, this.domHandler), this.evTarget && L(this.target, this.evTarget, this.domHandler), this.evWin && L(yt(this.element), this.evWin, this.domHandler);
        }
      };
      function rg(d) {
        var _, T = d.options.inputClass;
        return T ? _ = T : nt ? _ = Ki : Ss ? _ = gr : dn ? _ = Yi : _ = _r, new _(d, ig);
      }
      function ig(d, _, T) {
        var v = T.pointers.length, M = T.changedPointers.length, D = _ & Ee && v - M === 0, j = _ & (ce | Se) && v - M === 0;
        T.isFirst = !!D, T.isFinal = !!j, D && (d.session = {}), T.eventType = _, og(d, T), d.emit("hammer.input", T), d.recognize(T), d.session.prevInput = T;
      }
      function og(d, _) {
        var T = d.session, v = _.pointers, M = v.length;
        T.firstInput || (T.firstInput = ll(_)), M > 1 && !T.firstMultiple ? T.firstMultiple = ll(_) : M === 1 && (T.firstMultiple = !1);
        var D = T.firstInput, j = T.firstMultiple, de = j ? j.center : D.center, ge = _.center = hl(v);
        _.timeStamp = h(), _.deltaTime = _.timeStamp - D.timeStamp, _.angle = $i(de, ge), _.distance = pr(de, ge), ag(T, _), _.offsetDirection = fl(_.deltaX, _.deltaY);
        var Ce = ul(_.deltaTime, _.deltaX, _.deltaY);
        _.overallVelocityX = Ce.x, _.overallVelocityY = Ce.y, _.overallVelocity = l(Ce.x) > l(Ce.y) ? Ce.x : Ce.y, _.scale = j ? hg(j.pointers, v) : 1, _.rotation = j ? lg(j.pointers, v) : 0, _.maxPointers = T.prevInput ? _.pointers.length > T.prevInput.maxPointers ? _.pointers.length : T.prevInput.maxPointers : _.pointers.length, cg(T, _);
        var at = d.element;
        k(_.srcEvent.target, at) && (at = _.srcEvent.target), _.target = at;
      }
      function ag(d, _) {
        var T = _.center, v = d.offsetDelta || {}, M = d.prevDelta || {}, D = d.prevInput || {};
        (_.eventType === Ee || D.eventType === ce) && (M = d.prevDelta = {
          x: D.deltaX || 0,
          y: D.deltaY || 0
        }, v = d.offsetDelta = {
          x: T.x,
          y: T.y
        }), _.deltaX = M.x + (T.x - v.x), _.deltaY = M.y + (T.y - v.y);
      }
      function cg(d, _) {
        var T = d.lastInterval || _, v = _.timeStamp - T.timeStamp, M, D, j, de;
        if (_.eventType != Se && (v > ng || T.velocity === r)) {
          var ge = _.deltaX - T.deltaX, Ce = _.deltaY - T.deltaY, at = ul(v, ge, Ce);
          D = at.x, j = at.y, M = l(at.x) > l(at.y) ? at.x : at.y, de = fl(ge, Ce), d.lastInterval = _;
        } else
          M = T.velocity, D = T.velocityX, j = T.velocityY, de = T.direction;
        _.velocity = M, _.velocityX = D, _.velocityY = j, _.direction = de;
      }
      function ll(d) {
        for (var _ = [], T = 0; T < d.pointers.length; )
          _[T] = {
            clientX: c(d.pointers[T].clientX),
            clientY: c(d.pointers[T].clientY)
          }, T++;
        return {
          timeStamp: h(),
          pointers: _,
          center: hl(_),
          deltaX: d.deltaX,
          deltaY: d.deltaY
        };
      }
      function hl(d) {
        var _ = d.length;
        if (_ === 1)
          return {
            x: c(d[0].clientX),
            y: c(d[0].clientY)
          };
        for (var T = 0, v = 0, M = 0; M < _; )
          T += d[M].clientX, v += d[M].clientY, M++;
        return {
          x: c(T / _),
          y: c(v / _)
        };
      }
      function ul(d, _, T) {
        return {
          x: _ / d || 0,
          y: T / d || 0
        };
      }
      function fl(d, _) {
        return d === _ ? fr : l(d) >= l(_) ? d < 0 ? pn : _n : _ < 0 ? gn : mn;
      }
      function pr(d, _, T) {
        T || (T = cl);
        var v = _[T[0]] - d[T[0]], M = _[T[1]] - d[T[1]];
        return Math.sqrt(v * v + M * M);
      }
      function $i(d, _, T) {
        T || (T = cl);
        var v = _[T[0]] - d[T[0]], M = _[T[1]] - d[T[1]];
        return Math.atan2(M, v) * 180 / Math.PI;
      }
      function lg(d, _) {
        return $i(_[1], _[0], dr) + $i(d[1], d[0], dr);
      }
      function hg(d, _) {
        return pr(_[0], _[1], dr) / pr(d[0], d[1], dr);
      }
      var ug = {
        mousedown: Ee,
        mousemove: ts,
        mouseup: ce
      }, fg = "mousedown", dg = "mousemove mouseup";
      function _r() {
        this.evEl = fg, this.evWin = dg, this.pressed = !1, De.apply(this, arguments);
      }
      w(_r, De, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(_) {
          var T = ug[_.type];
          T & Ee && _.button === 0 && (this.pressed = !0), T & ts && _.which !== 1 && (T = ce), this.pressed && (T & ce && (this.pressed = !1), this.callback(this.manager, T, {
            pointers: [_],
            changedPointers: [_],
            pointerType: Gi,
            srcEvent: _
          }));
        }
      });
      var pg = {
        pointerdown: Ee,
        pointermove: ts,
        pointerup: ce,
        pointercancel: Se,
        pointerout: Se
      }, _g = {
        2: rt,
        3: tg,
        4: Gi,
        5: sg
        // see https://twitter.com/jacobrossi/status/480596438489890816
      }, dl = "pointerdown", pl = "pointermove pointerup pointercancel";
      e.MSPointerEvent && !e.PointerEvent && (dl = "MSPointerDown", pl = "MSPointerMove MSPointerUp MSPointerCancel");
      function Ki() {
        this.evEl = dl, this.evWin = pl, De.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
      }
      w(Ki, De, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(_) {
          var T = this.store, v = !1, M = _.type.toLowerCase().replace("ms", ""), D = pg[M], j = _g[_.pointerType] || _.pointerType, de = j == rt, ge = H(T, _.pointerId, "pointerId");
          D & Ee && (_.button === 0 || de) ? ge < 0 && (T.push(_), ge = T.length - 1) : D & (ce | Se) && (v = !0), !(ge < 0) && (T[ge] = _, this.callback(this.manager, D, {
            pointers: T,
            changedPointers: [_],
            pointerType: j,
            srcEvent: _
          }), v && T.splice(ge, 1));
        }
      });
      var gg = {
        touchstart: Ee,
        touchmove: ts,
        touchend: ce,
        touchcancel: Se
      }, mg = "touchstart", Ag = "touchstart touchmove touchend touchcancel";
      function _l() {
        this.evTarget = mg, this.evWin = Ag, this.started = !1, De.apply(this, arguments);
      }
      w(_l, De, {
        handler: function(_) {
          var T = gg[_.type];
          if (T === Ee && (this.started = !0), !!this.started) {
            var v = Tg.call(this, _, T);
            T & (ce | Se) && v[0].length - v[1].length === 0 && (this.started = !1), this.callback(this.manager, T, {
              pointers: v[0],
              changedPointers: v[1],
              pointerType: rt,
              srcEvent: _
            });
          }
        }
      });
      function Tg(d, _) {
        var T = Y(d.touches), v = Y(d.changedTouches);
        return _ & (ce | Se) && (T = te(T.concat(v), "identifier")), [T, v];
      }
      var yg = {
        touchstart: Ee,
        touchmove: ts,
        touchend: ce,
        touchcancel: Se
      }, bg = "touchstart touchmove touchend touchcancel";
      function gr() {
        this.evTarget = bg, this.targetIds = {}, De.apply(this, arguments);
      }
      w(gr, De, {
        handler: function(_) {
          var T = yg[_.type], v = Eg.call(this, _, T);
          v && this.callback(this.manager, T, {
            pointers: v[0],
            changedPointers: v[1],
            pointerType: rt,
            srcEvent: _
          });
        }
      });
      function Eg(d, _) {
        var T = Y(d.touches), v = this.targetIds;
        if (_ & (Ee | ts) && T.length === 1)
          return v[T[0].identifier] = !0, [T, T];
        var M, D, j = Y(d.changedTouches), de = [], ge = this.target;
        if (D = T.filter(function(Ce) {
          return k(Ce.target, ge);
        }), _ === Ee)
          for (M = 0; M < D.length; )
            v[D[M].identifier] = !0, M++;
        for (M = 0; M < j.length; )
          v[j[M].identifier] && de.push(j[M]), _ & (ce | Se) && delete v[j[M].identifier], M++;
        if (de.length)
          return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            te(D.concat(de), "identifier"),
            de
          ];
      }
      var Cg = 2500, gl = 25;
      function Yi() {
        De.apply(this, arguments);
        var d = I(this.handler, this);
        this.touch = new gr(this.manager, d), this.mouse = new _r(this.manager, d), this.primaryTouch = null, this.lastTouches = [];
      }
      w(Yi, De, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function(_, T, v) {
          var M = v.pointerType == rt, D = v.pointerType == Gi;
          if (!(D && v.sourceCapabilities && v.sourceCapabilities.firesTouchEvents)) {
            if (M)
              Sg.call(this, T, v);
            else if (D && Rg.call(this, v))
              return;
            this.callback(_, T, v);
          }
        },
        /**
         * remove the event listeners
         */
        destroy: function() {
          this.touch.destroy(), this.mouse.destroy();
        }
      });
      function Sg(d, _) {
        d & Ee ? (this.primaryTouch = _.changedPointers[0].identifier, ml.call(this, _)) : d & (ce | Se) && ml.call(this, _);
      }
      function ml(d) {
        var _ = d.changedPointers[0];
        if (_.identifier === this.primaryTouch) {
          var T = { x: _.clientX, y: _.clientY };
          this.lastTouches.push(T);
          var v = this.lastTouches, M = function() {
            var D = v.indexOf(T);
            D > -1 && v.splice(D, 1);
          };
          setTimeout(M, Cg);
        }
      }
      function Rg(d) {
        for (var _ = d.srcEvent.clientX, T = d.srcEvent.clientY, v = 0; v < this.lastTouches.length; v++) {
          var M = this.lastTouches[v], D = Math.abs(_ - M.x), j = Math.abs(T - M.y);
          if (D <= gl && j <= gl)
            return !0;
        }
        return !1;
      }
      var Al = z(o.style, "touchAction"), Tl = Al !== r, yl = "compute", bl = "auto", Ji = "manipulation", ns = "none", An = "pan-x", Tn = "pan-y", mr = Ig();
      function qi(d, _) {
        this.manager = d, this.set(_);
      }
      qi.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(d) {
          d == yl && (d = this.compute()), Tl && this.manager.element.style && mr[d] && (this.manager.element.style[Al] = d), this.actions = d.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var d = [];
          return p(this.manager.recognizers, function(_) {
            B(_.options.enable, [_]) && (d = d.concat(_.getTouchAction()));
          }), wg(d.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(d) {
          var _ = d.srcEvent, T = d.offsetDirection;
          if (this.manager.session.prevented) {
            _.preventDefault();
            return;
          }
          var v = this.actions, M = F(v, ns) && !mr[ns], D = F(v, Tn) && !mr[Tn], j = F(v, An) && !mr[An];
          if (M) {
            var de = d.pointers.length === 1, ge = d.distance < 2, Ce = d.deltaTime < 250;
            if (de && ge && Ce)
              return;
          }
          if (!(j && D) && (M || D && T & it || j && T & ss))
            return this.preventSrc(_);
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(d) {
          this.manager.session.prevented = !0, d.preventDefault();
        }
      };
      function wg(d) {
        if (F(d, ns))
          return ns;
        var _ = F(d, An), T = F(d, Tn);
        return _ && T ? ns : _ || T ? _ ? An : Tn : F(d, Ji) ? Ji : bl;
      }
      function Ig() {
        if (!Tl)
          return !1;
        var d = {}, _ = e.CSS && e.CSS.supports;
        return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(T) {
          d[T] = _ ? e.CSS.supports("touch-action", T) : !0;
        }), d;
      }
      var Ar = 1, Ue = 2, Rs = 4, Ot = 8, bt = Ot, yn = 16, ot = 32;
      function Et(d) {
        this.options = A({}, this.defaults, d || {}), this.id = es(), this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = Ar, this.simultaneous = {}, this.requireFail = [];
      }
      Et.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(d) {
          return A(this.options, d), this.manager && this.manager.touchAction.update(), this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(d) {
          if (f(d, "recognizeWith", this))
            return this;
          var _ = this.simultaneous;
          return d = Tr(d, this), _[d.id] || (_[d.id] = d, d.recognizeWith(this)), this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(d) {
          return f(d, "dropRecognizeWith", this) ? this : (d = Tr(d, this), delete this.simultaneous[d.id], this);
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(d) {
          if (f(d, "requireFailure", this))
            return this;
          var _ = this.requireFail;
          return d = Tr(d, this), H(_, d) === -1 && (_.push(d), d.requireFailure(this)), this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(d) {
          if (f(d, "dropRequireFailure", this))
            return this;
          d = Tr(d, this);
          var _ = H(this.requireFail, d);
          return _ > -1 && this.requireFail.splice(_, 1), this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(d) {
          return !!this.simultaneous[d.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(d) {
          var _ = this, T = this.state;
          function v(M) {
            _.manager.emit(M, d);
          }
          T < Ot && v(_.options.event + El(T)), v(_.options.event), d.additionalEvent && v(d.additionalEvent), T >= Ot && v(_.options.event + El(T));
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(d) {
          if (this.canEmit())
            return this.emit(d);
          this.state = ot;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          for (var d = 0; d < this.requireFail.length; ) {
            if (!(this.requireFail[d].state & (ot | Ar)))
              return !1;
            d++;
          }
          return !0;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(d) {
          var _ = A({}, d);
          if (!B(this.options.enable, [this, _])) {
            this.reset(), this.state = ot;
            return;
          }
          this.state & (bt | yn | ot) && (this.state = Ar), this.state = this.process(_), this.state & (Ue | Rs | Ot | yn) && this.tryEmit(_);
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(d) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function El(d) {
        return d & yn ? "cancel" : d & Ot ? "end" : d & Rs ? "move" : d & Ue ? "start" : "";
      }
      function Cl(d) {
        return d == mn ? "down" : d == gn ? "up" : d == pn ? "left" : d == _n ? "right" : "";
      }
      function Tr(d, _) {
        var T = _.manager;
        return T ? T.get(d) : d;
      }
      function We() {
        Et.apply(this, arguments);
      }
      w(We, Et, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(d) {
          var _ = this.options.pointers;
          return _ === 0 || d.pointers.length === _;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(d) {
          var _ = this.state, T = d.eventType, v = _ & (Ue | Rs), M = this.attrTest(d);
          return v && (T & Se || !M) ? _ | yn : v || M ? T & ce ? _ | Ot : _ & Ue ? _ | Rs : Ue : ot;
        }
      });
      function yr() {
        We.apply(this, arguments), this.pX = null, this.pY = null;
      }
      w(yr, We, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: al
        },
        getTouchAction: function() {
          var d = this.options.direction, _ = [];
          return d & it && _.push(Tn), d & ss && _.push(An), _;
        },
        directionTest: function(d) {
          var _ = this.options, T = !0, v = d.distance, M = d.direction, D = d.deltaX, j = d.deltaY;
          return M & _.direction || (_.direction & it ? (M = D === 0 ? fr : D < 0 ? pn : _n, T = D != this.pX, v = Math.abs(d.deltaX)) : (M = j === 0 ? fr : j < 0 ? gn : mn, T = j != this.pY, v = Math.abs(d.deltaY))), d.direction = M, T && v > _.threshold && M & _.direction;
        },
        attrTest: function(d) {
          return We.prototype.attrTest.call(this, d) && (this.state & Ue || !(this.state & Ue) && this.directionTest(d));
        },
        emit: function(d) {
          this.pX = d.deltaX, this.pY = d.deltaY;
          var _ = Cl(d.direction);
          _ && (d.additionalEvent = this.options.event + _), this._super.emit.call(this, d);
        }
      });
      function Zi() {
        We.apply(this, arguments);
      }
      w(Zi, We, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [ns];
        },
        attrTest: function(d) {
          return this._super.attrTest.call(this, d) && (Math.abs(d.scale - 1) > this.options.threshold || this.state & Ue);
        },
        emit: function(d) {
          if (d.scale !== 1) {
            var _ = d.scale < 1 ? "in" : "out";
            d.additionalEvent = this.options.event + _;
          }
          this._super.emit.call(this, d);
        }
      });
      function Qi() {
        Et.apply(this, arguments), this._timer = null, this._input = null;
      }
      w(Qi, Et, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [bl];
        },
        process: function(d) {
          var _ = this.options, T = d.pointers.length === _.pointers, v = d.distance < _.threshold, M = d.deltaTime > _.time;
          if (this._input = d, !v || !T || d.eventType & (ce | Se) && !M)
            this.reset();
          else if (d.eventType & Ee)
            this.reset(), this._timer = u(function() {
              this.state = bt, this.tryEmit();
            }, _.time, this);
          else if (d.eventType & ce)
            return bt;
          return ot;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(d) {
          this.state === bt && (d && d.eventType & ce ? this.manager.emit(this.options.event + "up", d) : (this._input.timeStamp = h(), this.manager.emit(this.options.event, this._input)));
        }
      });
      function eo() {
        We.apply(this, arguments);
      }
      w(eo, We, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [ns];
        },
        attrTest: function(d) {
          return this._super.attrTest.call(this, d) && (Math.abs(d.rotation) > this.options.threshold || this.state & Ue);
        }
      });
      function to() {
        We.apply(this, arguments);
      }
      w(to, We, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: it | ss,
          pointers: 1
        },
        getTouchAction: function() {
          return yr.prototype.getTouchAction.call(this);
        },
        attrTest: function(d) {
          var _ = this.options.direction, T;
          return _ & (it | ss) ? T = d.overallVelocity : _ & it ? T = d.overallVelocityX : _ & ss && (T = d.overallVelocityY), this._super.attrTest.call(this, d) && _ & d.offsetDirection && d.distance > this.options.threshold && d.maxPointers == this.options.pointers && l(T) > this.options.velocity && d.eventType & ce;
        },
        emit: function(d) {
          var _ = Cl(d.offsetDirection);
          _ && this.manager.emit(this.options.event + _, d), this.manager.emit(this.options.event, d);
        }
      });
      function br() {
        Et.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
      }
      w(br, Et, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [Ji];
        },
        process: function(d) {
          var _ = this.options, T = d.pointers.length === _.pointers, v = d.distance < _.threshold, M = d.deltaTime < _.time;
          if (this.reset(), d.eventType & Ee && this.count === 0)
            return this.failTimeout();
          if (v && M && T) {
            if (d.eventType != ce)
              return this.failTimeout();
            var D = this.pTime ? d.timeStamp - this.pTime < _.interval : !0, j = !this.pCenter || pr(this.pCenter, d.center) < _.posThreshold;
            this.pTime = d.timeStamp, this.pCenter = d.center, !j || !D ? this.count = 1 : this.count += 1, this._input = d;
            var de = this.count % _.taps;
            if (de === 0)
              return this.hasRequireFailures() ? (this._timer = u(function() {
                this.state = bt, this.tryEmit();
              }, _.interval, this), Ue) : bt;
          }
          return ot;
        },
        failTimeout: function() {
          return this._timer = u(function() {
            this.state = ot;
          }, this.options.interval, this), ot;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          this.state == bt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
        }
      });
      function xt(d, _) {
        return _ = _ || {}, _.recognizers = x(_.recognizers, xt.defaults.preset), new so(d, _);
      }
      xt.VERSION = "2.0.7", xt.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: !1,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: yl,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: !0,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [eo, { enable: !1 }],
          [Zi, { enable: !1 }, ["rotate"]],
          [to, { direction: it }],
          [yr, { direction: it }, ["swipe"]],
          [br],
          [br, { event: "doubletap", taps: 2 }, ["tap"]],
          [Qi]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var vg = 1, Sl = 2;
      function so(d, _) {
        this.options = A({}, xt.defaults, _ || {}), this.options.inputTarget = this.options.inputTarget || d, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = d, this.input = rg(this), this.touchAction = new qi(this, this.options.touchAction), Rl(this, !0), p(this.options.recognizers, function(T) {
          var v = this.add(new T[0](T[1]));
          T[2] && v.recognizeWith(T[2]), T[3] && v.requireFailure(T[3]);
        }, this);
      }
      so.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(d) {
          return A(this.options, d), d.touchAction && this.touchAction.update(), d.inputTarget && (this.input.destroy(), this.input.target = d.inputTarget, this.input.init()), this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(d) {
          this.session.stopped = d ? Sl : vg;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(d) {
          var _ = this.session;
          if (!_.stopped) {
            this.touchAction.preventDefaults(d);
            var T, v = this.recognizers, M = _.curRecognizer;
            (!M || M && M.state & bt) && (M = _.curRecognizer = null);
            for (var D = 0; D < v.length; )
              T = v[D], _.stopped !== Sl && // 1
              (!M || T == M || // 2
              T.canRecognizeWith(M)) ? T.recognize(d) : T.reset(), !M && T.state & (Ue | Rs | Ot) && (M = _.curRecognizer = T), D++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(d) {
          if (d instanceof Et)
            return d;
          for (var _ = this.recognizers, T = 0; T < _.length; T++)
            if (_[T].options.event == d)
              return _[T];
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(d) {
          if (f(d, "add", this))
            return this;
          var _ = this.get(d.options.event);
          return _ && this.remove(_), this.recognizers.push(d), d.manager = this, this.touchAction.update(), d;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(d) {
          if (f(d, "remove", this))
            return this;
          if (d = this.get(d), d) {
            var _ = this.recognizers, T = H(_, d);
            T !== -1 && (_.splice(T, 1), this.touchAction.update());
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(d, _) {
          if (d !== r && _ !== r) {
            var T = this.handlers;
            return p(U(d), function(v) {
              T[v] = T[v] || [], T[v].push(_);
            }), this;
          }
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(d, _) {
          if (d !== r) {
            var T = this.handlers;
            return p(U(d), function(v) {
              _ ? T[v] && T[v].splice(H(T[v], _), 1) : delete T[v];
            }), this;
          }
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(d, _) {
          this.options.domEvents && Bg(d, _);
          var T = this.handlers[d] && this.handlers[d].slice();
          if (!(!T || !T.length)) {
            _.type = d, _.preventDefault = function() {
              _.srcEvent.preventDefault();
            };
            for (var v = 0; v < T.length; )
              T[v](_), v++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && Rl(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
        }
      };
      function Rl(d, _) {
        var T = d.element;
        if (T.style) {
          var v;
          p(d.options.cssProps, function(M, D) {
            v = z(T.style, D), _ ? (d.oldCssProps[v] = T.style[v], T.style[v] = M) : T.style[v] = d.oldCssProps[v] || "";
          }), _ || (d.oldCssProps = {});
        }
      }
      function Bg(d, _) {
        var T = s.createEvent("Event");
        T.initEvent(d, !0, !0), T.gesture = _, _.target.dispatchEvent(T);
      }
      A(xt, {
        INPUT_START: Ee,
        INPUT_MOVE: ts,
        INPUT_END: ce,
        INPUT_CANCEL: Se,
        STATE_POSSIBLE: Ar,
        STATE_BEGAN: Ue,
        STATE_CHANGED: Rs,
        STATE_ENDED: Ot,
        STATE_RECOGNIZED: bt,
        STATE_CANCELLED: yn,
        STATE_FAILED: ot,
        DIRECTION_NONE: fr,
        DIRECTION_LEFT: pn,
        DIRECTION_RIGHT: _n,
        DIRECTION_UP: gn,
        DIRECTION_DOWN: mn,
        DIRECTION_HORIZONTAL: it,
        DIRECTION_VERTICAL: ss,
        DIRECTION_ALL: al,
        Manager: so,
        Input: De,
        TouchAction: qi,
        TouchInput: gr,
        MouseInput: _r,
        PointerEventInput: Ki,
        TouchMouseInput: Yi,
        SingleTouchInput: _l,
        Recognizer: Et,
        AttrRecognizer: We,
        Tap: br,
        Pan: yr,
        Swipe: to,
        Pinch: Zi,
        Rotate: eo,
        Press: Qi,
        on: N,
        off: L,
        each: p,
        merge: C,
        extend: E,
        assign: A,
        inherit: w,
        bindFn: I,
        prefixed: z
      });
      var Mg = typeof e < "u" ? e : typeof self < "u" ? self : {};
      Mg.Hammer = xt, t.exports ? t.exports = xt : e[n] = xt;
    })(window, document, "Hammer");
  })(xo)), xo.exports;
}
var lr = Kw();
const Yw = /* @__PURE__ */ Pg(lr), ut = /* @__PURE__ */ Fg({
  __proto__: null,
  default: Yw
}, [lr]), Fp = 1, Dp = 2, xa = 4, Jw = {
  mousedown: Fp,
  mousemove: Dp,
  mouseup: xa
};
function qw(t, e) {
  for (let s = 0; s < t.length; s++)
    if (e(t[s]))
      return !0;
  return !1;
}
function Zw(t) {
  const e = t.prototype.handler;
  t.prototype.handler = function(n) {
    const r = this.store;
    n.button > 0 && n.type === "pointerdown" && (qw(r, (i) => i.pointerId === n.pointerId) || r.push(n)), e.call(this, n);
  };
}
function Qw(t) {
  t.prototype.handler = function(s) {
    let n = Jw[s.type];
    n & Fp && s.button >= 0 && (this.pressed = !0), n & Dp && s.buttons === 0 && (n = xa), this.pressed && (n & xa && (this.pressed = !1), this.callback(this.manager, n, {
      pointers: [s],
      changedPointers: [s],
      pointerType: "mouse",
      srcEvent: s
    }));
  };
}
Zw(lr.PointerEventInput);
Qw(lr.MouseInput);
const e1 = lr.Manager;
class Di {
  constructor(e, s, n) {
    this.element = e, this.callback = s, this.options = { enable: !0, ...n };
  }
}
const t1 = ut ? [
  [ut.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: !1 }],
  [ut.Rotate, { enable: !1 }],
  [ut.Pinch, { enable: !1 }],
  [ut.Swipe, { enable: !1 }],
  [ut.Pan, { threshold: 0, enable: !1 }],
  [ut.Press, { enable: !1 }],
  [ut.Tap, { event: "doubletap", taps: 2, enable: !1 }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [ut.Tap, { event: "anytap", enable: !1 }],
  [ut.Tap, { enable: !1 }]
] : null, ou = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, s1 = {
  doubletap: ["tap"]
}, n1 = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, Vc = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, r1 = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, au = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, i1 = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", zs = typeof window < "u" ? window : global;
let Na = !1;
try {
  const t = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return Na = !0, !0;
    }
  };
  zs.addEventListener("test", null, t), zs.removeEventListener("test", null);
} catch {
  Na = !1;
}
const o1 = i1.indexOf("firefox") !== -1, { WHEEL_EVENTS: a1 } = Vc, cu = "wheel", lu = 4.000244140625, c1 = 40, l1 = 0.25;
class h1 extends Di {
  constructor(e, s, n) {
    super(e, s, n), this.handleEvent = (r) => {
      if (!this.options.enable)
        return;
      let i = r.deltaY;
      zs.WheelEvent && (o1 && r.deltaMode === zs.WheelEvent.DOM_DELTA_PIXEL && (i /= zs.devicePixelRatio), r.deltaMode === zs.WheelEvent.DOM_DELTA_LINE && (i *= c1)), i !== 0 && i % lu === 0 && (i = Math.floor(i / lu)), r.shiftKey && i && (i = i * l1), this.callback({
        type: cu,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        delta: -i,
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, this.events = (this.options.events || []).concat(a1), this.events.forEach((r) => e.addEventListener(r, this.handleEvent, Na ? { passive: !1 } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, s) {
    e === cu && (this.options.enable = s);
  }
}
const { MOUSE_EVENTS: u1 } = Vc, hu = "pointermove", uu = "pointerover", fu = "pointerout", du = "pointerenter", pu = "pointerleave";
class f1 extends Di {
  constructor(e, s, n) {
    super(e, s, n), this.handleEvent = (i) => {
      this.handleOverEvent(i), this.handleOutEvent(i), this.handleEnterEvent(i), this.handleLeaveEvent(i), this.handleMoveEvent(i);
    }, this.pressed = !1;
    const { enable: r } = this.options;
    this.enableMoveEvent = r, this.enableLeaveEvent = r, this.enableEnterEvent = r, this.enableOutEvent = r, this.enableOverEvent = r, this.events = (this.options.events || []).concat(u1), this.events.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, s) {
    e === hu && (this.enableMoveEvent = s), e === uu && (this.enableOverEvent = s), e === fu && (this.enableOutEvent = s), e === du && (this.enableEnterEvent = s), e === pu && (this.enableLeaveEvent = s);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(uu, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(fu, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(du, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(pu, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit(hu, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, s) {
    this.callback({
      type: e,
      center: {
        x: s.clientX,
        y: s.clientY
      },
      srcEvent: s,
      pointerType: "mouse",
      target: s.target
    });
  }
}
const { KEY_EVENTS: d1 } = Vc, _u = "keydown", gu = "keyup";
class p1 extends Di {
  constructor(e, s, n) {
    super(e, s, n), this.handleEvent = (r) => {
      const i = r.target || r.srcElement;
      i.tagName === "INPUT" && i.type === "text" || i.tagName === "TEXTAREA" || (this.enableDownEvent && r.type === "keydown" && this.callback({
        type: _u,
        srcEvent: r,
        key: r.key,
        target: r.target
      }), this.enableUpEvent && r.type === "keyup" && this.callback({
        type: gu,
        srcEvent: r,
        key: r.key,
        target: r.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(d1), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((r) => e.addEventListener(r, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, s) {
    e === _u && (this.enableDownEvent = s), e === gu && (this.enableUpEvent = s);
  }
}
const mu = "contextmenu";
class _1 extends Di {
  constructor(e, s, n) {
    super(e, s, n), this.handleEvent = (r) => {
      this.options.enable && this.callback({
        type: mu,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, s) {
    e === mu && (this.options.enable = s);
  }
}
const Au = 1, Fa = 2, Tu = 4, g1 = {
  pointerdown: Au,
  pointermove: Fa,
  pointerup: Tu,
  mousedown: Au,
  mousemove: Fa,
  mouseup: Tu
}, m1 = 0, A1 = 1, T1 = 2, y1 = 1, b1 = 2, E1 = 4;
function C1(t) {
  const e = g1[t.srcEvent.type];
  if (!e)
    return null;
  const { buttons: s, button: n } = t.srcEvent;
  let r = !1, i = !1, o = !1;
  return e === Fa ? (r = !!(s & y1), i = !!(s & E1), o = !!(s & b1)) : (r = n === m1, i = n === A1, o = n === T1), { leftButton: r, middleButton: i, rightButton: o };
}
function S1(t, e) {
  const s = t.center;
  if (!s)
    return null;
  const n = e.getBoundingClientRect(), r = n.width / e.offsetWidth || 1, i = n.height / e.offsetHeight || 1, o = {
    x: (s.x - n.left - e.clientLeft) / r,
    y: (s.y - n.top - e.clientTop) / i
  };
  return { center: s, offsetCenter: o };
}
const No = {
  srcElement: "root",
  priority: 0
};
class R1 {
  constructor(e) {
    this.handleEvent = (s) => {
      if (this.isEmpty())
        return;
      const n = this._normalizeEvent(s);
      let r = s.srcEvent.target;
      for (; r && r !== n.rootElement; ) {
        if (this._emit(n, r), n.handled)
          return;
        r = r.parentNode;
      }
      this._emit(n, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, s, n, r = !1, i = !1) {
    const { handlers: o, handlersByElement: a } = this;
    let c = No;
    typeof n == "string" || n && n.addEventListener ? c = { ...No, srcElement: n } : n && (c = { ...No, ...n });
    let l = a.get(c.srcElement);
    l || (l = [], a.set(c.srcElement, l));
    const h = {
      type: e,
      handler: s,
      srcElement: c.srcElement,
      priority: c.priority
    };
    r && (h.once = !0), i && (h.passive = !0), o.push(h), this._active = this._active || !h.passive;
    let u = l.length - 1;
    for (; u >= 0 && !(l[u].priority >= h.priority); )
      u--;
    l.splice(u + 1, 0, h);
  }
  remove(e, s) {
    const { handlers: n, handlersByElement: r } = this;
    for (let i = n.length - 1; i >= 0; i--) {
      const o = n[i];
      if (o.type === e && o.handler === s) {
        n.splice(i, 1);
        const a = r.get(o.srcElement);
        a.splice(a.indexOf(o), 1), a.length === 0 && r.delete(o.srcElement);
      }
    }
    this._active = n.some((i) => !i.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, s) {
    const n = this.handlersByElement.get(s);
    if (n) {
      let r = !1;
      const i = () => {
        e.handled = !0;
      }, o = () => {
        e.handled = !0, r = !0;
      }, a = [];
      for (let c = 0; c < n.length; c++) {
        const { type: l, handler: h, once: u } = n[c];
        if (h({
          ...e,
          // @ts-ignore
          type: l,
          stopPropagation: i,
          stopImmediatePropagation: o
        }), u && a.push(n[c]), r)
          break;
      }
      for (let c = 0; c < a.length; c++) {
        const { type: l, handler: h } = a[c];
        this.remove(l, h);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const s = this.eventManager.getElement();
    return {
      ...e,
      ...C1(e),
      ...S1(e, s),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: s
    };
  }
}
const w1 = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: e1,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class I1 {
  constructor(e = null, s) {
    this._onBasicInput = (r) => {
      const { srcEvent: i } = r, o = n1[i.type];
      o && this.manager.emit(o, r);
    }, this._onOtherEvent = (r) => {
      this.manager.emit(r.type, r);
    }, this.options = { ...w1, ...s }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const { events: n } = this.options;
    n && this.on(n);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const { options: s } = this, n = s.Manager;
    this.manager = new n(e, {
      touchAction: s.touchAction,
      recognizers: s.recognizers || t1
    }).on("hammer.input", this._onBasicInput), s.recognizers || Object.keys(ou).forEach((r) => {
      const i = this.manager.get(r);
      i && ou[r].forEach((o) => {
        i.recognizeWith(o);
      });
    });
    for (const r in s.recognizerOptions) {
      const i = this.manager.get(r);
      if (i) {
        const o = s.recognizerOptions[r];
        delete o.enable, i.set(o);
      }
    }
    this.wheelInput = new h1(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new f1(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new p1(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: s.tabIndex
    }), this.contextmenuInput = new _1(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [r, i] of this.events)
      i.isEmpty() || (this._toggleRecognizer(i.recognizerName, !0), this.manager.on(r, i.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, s, n) {
    this._addEventHandler(e, s, n, !1);
  }
  once(e, s, n) {
    this._addEventHandler(e, s, n, !0);
  }
  watch(e, s, n) {
    this._addEventHandler(e, s, n, !1, !0);
  }
  off(e, s) {
    this._removeEventHandler(e, s);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, s) {
    const { manager: n } = this;
    if (!n)
      return;
    const r = n.get(e);
    if (r && r.options.enable !== s) {
      r.set({ enable: s });
      const i = s1[e];
      i && !this.options.recognizers && i.forEach((o) => {
        const a = n.get(o);
        s ? (a.requireFailure(e), r.dropRequireFailure(o)) : a.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, s), this.moveInput.enableEventType(e, s), this.keyInput.enableEventType(e, s), this.contextmenuInput.enableEventType(e, s);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, s, n, r, i) {
    if (typeof e != "string") {
      n = s;
      for (const h in e)
        this._addEventHandler(h, e[h], n, r, i);
      return;
    }
    const { manager: o, events: a } = this, c = au[e] || e;
    let l = a.get(c);
    l || (l = new R1(this), a.set(c, l), l.recognizerName = r1[c] || c, o && o.on(c, l.handleEvent)), l.add(e, s, n, r, i), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, s) {
    if (typeof e != "string") {
      for (const o in e)
        this._removeEventHandler(o, e[o]);
      return;
    }
    const { events: n } = this, r = au[e] || e, i = n.get(r);
    if (i && (i.remove(e, s), i.isEmpty())) {
      const { recognizerName: o } = i;
      let a = !1;
      for (const c of n.values())
        if (c.recognizerName === o && !c.isEmpty()) {
          a = !0;
          break;
        }
      a || this._toggleRecognizer(o, !1);
    }
  }
}
function Ut() {
}
const v1 = ({ isDragging: t }) => t ? "grabbing" : "grab", Up = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: { type: "webgl" },
  gl: null,
  glOptions: {},
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: Ut,
  onWebGLInitialized: Ut,
  onResize: Ut,
  onViewStateChange: Ut,
  onInteractionStateChange: Ut,
  onBeforeRender: Ut,
  onAfterRender: Ut,
  onLoad: Ut,
  onError: (t) => $.error(t.message, t.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: v1,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Zn {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new hn({ id: "deck.gl" }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (n) => {
      const { _pickRequest: r } = this;
      if (n.type === "pointerleave")
        r.x = -1, r.y = -1, r.radius = 0;
      else {
        if (n.leftButton || n.rightButton)
          return;
        {
          const i = n.offsetCenter;
          if (!i)
            return;
          r.x = i.x, r.y = i.y, r.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: r.x, y: r.y }), r.event = n;
    }, this._onEvent = (n) => {
      const r = Sa[n.type], i = n.offsetCenter;
      if (!r || !i || !this.layerManager)
        return;
      const o = this.layerManager.getLayers(), a = this.deckPicker.getLastPickedObject({
        x: i.x,
        y: i.y,
        layers: o,
        viewports: this.getViewports(i)
      }, this._lastPointerDownInfo), { layer: c } = a, l = c && (c[r.handler] || c.props[r.handler]), h = this.props[r.handler];
      let u = !1;
      l && (u = l.call(c, a, n)), u || (h?.(a, n), this.widgetManager.onEvent(a, n));
    }, this._onPointerDown = (n) => {
      const r = n.offsetCenter, i = this._pick("pickObject", "pickObject Time", {
        x: r.x,
        y: r.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = i.result[0] || i.emptyInfo;
    }, this.props = { ...Up, ...e }, e = this.props, e.viewState && e.initialViewState && $.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device ? this.device = e.device : e.gl && (e.gl instanceof WebGLRenderingContext && $.error("WebGL1 context not supported.")(), this.device = Wt.attach(e.gl));
    let s = this.device;
    s || (Xs.registerDevices([Wt]), s = Xs.createDevice({
      ...e.deviceProps,
      canvas: this._createCanvas(e)
    })), this.animationLoop = this._createAnimationLoop(s, e), this.setProps(e), e._typedArrayManagerProps && Yn.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && $.removed("onLayerHover", "onHover")(), "onLayerClick" in e && $.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Je(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const s = Object.create(this.props);
    Object.assign(s, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop?.setProps(s), this.layerManager && (this.viewManager.setProps(s), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(s), this.effectManager.setProps(s), this.deckRenderer.setProps(s), this.deckPicker.setProps(s), this.widgetManager.setProps(s)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let s = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const n = this.viewManager.needsRedraw(e), r = this.layerManager.needsRedraw(e), i = this.effectManager.needsRedraw(e), o = this.deckRenderer.needsRedraw(e);
    return s = s || n || r || i || o, s;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let s = this.needsRedraw({ clearRedrawFlags: !0 });
    s = e || s, s && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(s) : this._drawLayers(s));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return ue(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return ue(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const s = this._pick("pickObject", "pickObject Time", e).result;
    return s.length ? s[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e, s = !1) {
    for (const n in e)
      this.layerManager.resourceManager.add({ resourceId: n, data: e[n], forceUpdate: s });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const s of e)
      this.layerManager.resourceManager.remove(s);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    this.layerManager?.removeDefaultShaderModule(e);
  }
  _pick(e, s, n) {
    ue(this.deckPicker);
    const { stats: r } = this;
    r.get("Pick Count").incrementCount(), r.get(s).timeStart();
    const i = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(n),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(n),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...n
    });
    return r.get(s).timeEnd(), i;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let s = e.canvas;
    return typeof s == "string" && (s = document.getElementById(s), ue(s)), s || (s = document.createElement("canvas"), s.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(s)), Object.assign(s.style, e.style), s;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const { width: s, height: n } = e;
    if (s || s === 0) {
      const r = Number.isFinite(s) ? `${s}px` : s;
      this.canvas.style.width = r;
    }
    if (n || n === 0) {
      const r = Number.isFinite(n) ? `${n}px` : n;
      this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = r;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: e } = this;
    if (!e)
      return;
    const s = e.clientWidth ?? e.width, n = e.clientHeight ?? e.height;
    (s !== this.width || n !== this.height) && (this.width = s, this.height = n, this.viewManager?.setProps({ width: s, height: n }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({ width: s, height: n }));
  }
  _createAnimationLoop(e, s) {
    const {
      // width,
      // height,
      gl: n,
      // deviceProps,
      // glOptions,
      // debug,
      onError: r,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: i
    } = s;
    return new qC({
      device: e,
      useDevicePixels: i,
      // TODO v9
      autoResizeDrawingBuffer: !n,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (o) => this._setDevice(o.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: r
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views: e } = this.props, s = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new Fc({ id: "default-view" })]
    );
    return s.length && this.props.controller && (s[0].props.controller = this.props.controller), s;
  }
  _onContextLost() {
    const { onError: e } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    const { _pickRequest: e } = this;
    if (e.event) {
      const { result: s, emptyInfo: n } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = s.length > 0;
      let r = n, i = !1;
      for (const o of s)
        r = o, i = o.layer?.onHover(o, e.event) || i;
      i || (this.props.onHover?.(r, e.event), this.widgetManager.onHover(r, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device instanceof Wt && this.props.onWebGLInitialized(this.device.gl);
    const s = new gp();
    s.play(), this.animationLoop.attachTimeline(s), this.eventManager = new I1(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const r in Sa)
      this.eventManager.on(r, this._onEvent);
    this.viewManager = new _S({
      timeline: s,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const n = this.viewManager.getViewports()[0];
    this.layerManager = new pS(this.device, {
      deck: this,
      stats: this.stats,
      viewport: n,
      timeline: s
    }), this.effectManager = new OS({
      deck: this,
      device: this.device
    }), this.deckRenderer = new FS(this.device), this.deckPicker = new HS(this.device), this.widgetManager = new WS({
      deck: this,
      parentElement: this.canvas?.parentElement
    }), this.widgetManager.addDefault(new GS()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, s) {
    const { device: n, gl: r } = this.layerManager.context;
    this.props.onBeforeRender({ device: n, gl: r });
    const i = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...s
    };
    this.deckRenderer?.renderLayers(i), i.pass === "screen" && this.widgetManager.onRedraw({
      viewports: i.viewports,
      layers: i.layers
    }), this.props.onAfterRender({ device: n, gl: r });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), $.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const s = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = { ...this.viewState, [e.viewId]: s }, this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const { stats: e } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const s = this.animationLoop.stats;
    e.get("GPU Time").addTime(s.get("GPU Time").lastTiming), e.get("CPU Time").addTime(s.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics: e, stats: s } = this;
    e.fps = s.get("frameRate").getHz(), e.setPropsTime = s.get("setProps Time").time, e.updateAttributesTime = s.get("Update Attributes").time, e.framesRedrawn = s.get("Redraw Count").count, e.pickTime = s.get("pickObject Time").time + s.get("pickMultipleObjects Time").time + s.get("pickObjects Time").time, e.pickCount = s.get("Pick Count").count, e.gpuTime = s.get("GPU Time").time, e.cpuTime = s.get("CPU Time").time, e.gpuTimePerFrame = s.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = s.get("CPU Time").getAverageTime();
    const n = Xs.stats.get("Memory Usage");
    e.bufferMemory = n.get("Buffer Memory").count, e.textureMemory = n.get("Texture Memory").count, e.renderbufferMemory = n.get("Renderbuffer Memory").count, e.gpuMemory = n.get("GPU Memory").count;
  }
}
Zn.defaultProps = Up;
Zn.VERSION = IT;
function B1(t) {
  switch (t) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return Id(t);
  }
}
const M1 = wd;
function Lr(t, e) {
  return {
    attribute: t,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${e.type}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function fs(t) {
  return t.stride || t.size * t.bytesPerElement;
}
function P1(t, e) {
  return t.type === e.type && t.size === e.size && fs(t) === fs(e) && (t.offset || 0) === (e.offset || 0);
}
function Da(t, e) {
  e.offset && $.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const s = fs(t), n = e.vertexOffset !== void 0 ? e.vertexOffset : t.vertexOffset || 0, r = e.elementOffset || 0, i = (
    // offsets defined by the attribute
    n * s + r * t.bytesPerElement + // offsets defined by external buffers if any
    (t.offset || 0)
  );
  return {
    ...e,
    offset: i,
    stride: s
  };
}
function O1(t, e) {
  const s = Da(t, e);
  return {
    high: s,
    low: {
      ...s,
      offset: s.offset + t.size * 4
    }
  };
}
class x1 {
  /* eslint-disable max-statements */
  constructor(e, s, n) {
    this._buffer = null, this.device = e, this.id = s.id || "", this.size = s.size || 1;
    const r = s.logicalType || s.type, i = r === "float64";
    let { defaultValue: o } = s;
    o = Number.isFinite(o) ? [o] : o || new Array(this.size).fill(0);
    let a;
    i ? a = "float32" : !r && s.isIndexed ? a = "uint32" : a = r || "float32";
    let c = B1(r || a);
    this.doublePrecision = i, i && s.fp64 === !1 && (c = Float32Array), this.value = null, this.settings = {
      ...s,
      defaultType: c,
      defaultValue: o,
      logicalType: r,
      type: a,
      normalized: a.includes("norm"),
      size: this.size,
      bytesPerElement: c.BYTES_PER_ELEMENT
    }, this.state = {
      ...n,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * fs(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Yn.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(e = this.id, s = null) {
    const n = {};
    if (this.state.constant) {
      const r = this.value;
      if (s) {
        const i = Da(this.getAccessor(), s), o = i.offset / r.BYTES_PER_ELEMENT, a = i.size || this.size;
        n[e] = r.subarray(o, o + a);
      } else
        n[e] = r;
    } else
      n[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? n[`${e}64Low`] = n[e] : n[`${e}64Low`] = new Float32Array(this.size)), n;
  }
  _getBufferLayout(e = this.id, s = null) {
    const n = this.getAccessor(), r = [], i = {
      name: this.id,
      byteStride: fs(n),
      attributes: r
    };
    if (this.doublePrecision) {
      const o = O1(n, s || {});
      r.push(Lr(e, { ...n, ...o.high }), Lr(`${e}64Low`, {
        ...n,
        ...o.low
      }));
    } else if (s) {
      const o = Da(n, s);
      r.push(Lr(e, { ...n, ...o }));
    } else
      r.push(Lr(e, n));
    return i;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const s = Array.from(this.value);
      e = [s, s];
    } else {
      const { value: s, numInstances: n, size: r } = this, i = n * r;
      if (s && i && s.length >= i) {
        const o = new Array(r).fill(1 / 0), a = new Array(r).fill(-1 / 0);
        for (let c = 0; c < i; )
          for (let l = 0; l < r; l++) {
            const h = s[c++];
            h < o[l] && (o[l] = h), h > a[l] && (a[l] = h);
          }
        e = [o, a];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const { state: s } = this;
    let n;
    ArrayBuffer.isView(e) ? n = { value: e } : e instanceof re ? n = { buffer: e } : n = e;
    const r = { ...this.settings, ...n };
    if (ArrayBuffer.isView(n.value)) {
      if (!n.type)
        if (this.doublePrecision && n.value instanceof Float64Array)
          r.type = "float32";
        else {
          const o = M1(n.value);
          r.type = r.normalized ? o.replace("int", "norm") : o;
        }
      r.bytesPerElement = n.value.BYTES_PER_ELEMENT, r.stride = fs(r);
    }
    if (s.bounds = null, n.constant) {
      let i = n.value;
      if (i = this._normalizeValue(i, [], 0), this.settings.normalized && (i = this.normalizeConstant(i)), !(!s.constant || !this._areValuesEqual(i, this.value)))
        return !1;
      s.externalBuffer = null, s.constant = !0, this.value = ArrayBuffer.isView(i) ? i : new Float32Array(i);
    } else if (n.buffer) {
      const i = n.buffer;
      s.externalBuffer = i, s.constant = !1, this.value = n.value || null;
    } else if (n.value) {
      this._checkExternalBuffer(n);
      let i = n.value;
      s.externalBuffer = null, s.constant = !1, this.value = i;
      let { buffer: o } = this;
      const a = fs(r), c = (r.vertexOffset || 0) * a;
      if (this.doublePrecision && i instanceof Float64Array && (i = yo(i, r)), this.settings.isIndexed) {
        const h = this.settings.defaultType;
        i.constructor !== h && (i = new h(i));
      }
      const l = i.byteLength + c + a * 2;
      (!o || o.byteLength < l) && (o = this._createBuffer(l)), o.write(i, c);
    }
    return this.setAccessor(r), !0;
  }
  updateSubBuffer(e = {}) {
    this.state.bounds = null;
    const s = this.value, { startOffset: n = 0, endOffset: r } = e;
    this.buffer.write(this.doublePrecision && s instanceof Float64Array ? yo(s, {
      size: this.size,
      startIndex: n,
      endIndex: r
    }) : s.subarray(n, r), n * s.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e, s = !1) {
    const { state: n } = this, r = n.allocatedValue, i = Yn.allocate(r, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: s
    });
    this.value = i;
    const { byteOffset: o } = this;
    let { buffer: a } = this;
    return (!a || a.byteLength < i.byteLength + o) && (a = this._createBuffer(i.byteLength + o), s && r && a.write(r instanceof Float64Array ? yo(r, this) : r, o)), n.allocatedValue = i, n.constant = !1, n.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const { value: s } = e;
    if (!ArrayBuffer.isView(s))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const n = this.settings.defaultType;
    let r = !1;
    if (this.doublePrecision && (r = s.BYTES_PER_ELEMENT < 4), r)
      throw new Error(`Attribute ${this.id} does not support ${s.constructor.name}`);
    !(s instanceof n) && this.settings.normalized && !("normalized" in e) && $.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((s) => (s + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((s) => (s + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((s) => s / 255);
      case "unorm16":
        return new Float32Array(e).map((s) => s / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, s, n) {
    const { defaultValue: r, size: i } = this.settings;
    if (Number.isFinite(e))
      return s[n] = e, s;
    if (!e) {
      let o = i;
      for (; --o >= 0; )
        s[n + o] = r[o];
      return s;
    }
    switch (i) {
      case 4:
        s[n + 3] = Number.isFinite(e[3]) ? e[3] : r[3];
      case 3:
        s[n + 2] = Number.isFinite(e[2]) ? e[2] : r[2];
      case 2:
        s[n + 1] = Number.isFinite(e[1]) ? e[1] : r[1];
      case 1:
        s[n + 0] = Number.isFinite(e[0]) ? e[0] : r[0];
        break;
      default:
        let o = i;
        for (; --o >= 0; )
          s[n + o] = Number.isFinite(e[o]) ? e[o] : r[o];
    }
    return s;
  }
  _areValuesEqual(e, s) {
    if (!e || !s)
      return !1;
    const { size: n } = this;
    for (let r = 0; r < n; r++)
      if (e[r] !== s[r])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    this._buffer && this._buffer.destroy();
    const { isIndexed: s, type: n } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      usage: s ? re.INDEX : re.VERTEX,
      indexType: s ? n : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const yu = [], bu = [];
function Lp(t, e = 0, s = 1 / 0) {
  let n = yu;
  const r = {
    index: -1,
    data: t,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return t ? typeof t[Symbol.iterator] == "function" ? n = t : t.length > 0 && (bu.length = t.length, n = bu) : n = yu, (e > 0 || Number.isFinite(s)) && (n = (Array.isArray(n) ? n : Array.from(n)).slice(e, s), r.index = e - 1), { iterable: n, objectInfo: r };
}
function kp(t) {
  return t && t[Symbol.asyncIterator];
}
function N1(t, e) {
  const { size: s, stride: n, offset: r, startIndices: i, nested: o } = e, a = t.BYTES_PER_ELEMENT, c = n ? n / a : s, l = r ? r / a : 0, h = Math.floor((t.length - l) / c);
  return (u, { index: f, target: p }) => {
    if (!i) {
      const C = f * c + l;
      for (let w = 0; w < s; w++)
        p[w] = t[C + w];
      return p;
    }
    const m = i[f], A = i[f + 1] || h;
    let E;
    if (o) {
      E = new Array(A - m);
      for (let C = m; C < A; C++) {
        const w = C * c + l;
        p = new Array(s);
        for (let I = 0; I < s; I++)
          p[I] = t[w + I];
        E[C - m] = p;
      }
    } else if (c === s)
      E = t.subarray(m * s + l, A * s + l);
    else {
      E = new t.constructor((A - m) * s);
      let C = 0;
      for (let w = m; w < A; w++) {
        const I = w * c + l;
        for (let B = 0; B < s; B++)
          E[C++] = t[I + B];
      }
    }
    return E;
  };
}
const F1 = [], si = [[0, 1 / 0]];
function D1(t, e) {
  if (t === si || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return t;
  const s = [], n = t.length;
  let r = 0;
  for (let i = 0; i < n; i++) {
    const o = t[i];
    o[1] < e[0] ? (s.push(o), r = i + 1) : o[0] > e[1] ? s.push(o) : e = [Math.min(o[0], e[0]), Math.max(o[1], e[1])];
  }
  return s.splice(r, 0, e), s;
}
const U1 = {
  interpolation: {
    duration: 0,
    easing: (t) => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function Vp(t, e) {
  if (!t)
    return null;
  Number.isFinite(t) && (t = { type: "interpolation", duration: t });
  const s = t.type || "interpolation";
  return {
    ...U1[s],
    ...e,
    ...t,
    type: s
  };
}
class Hp extends x1 {
  constructor(e, s) {
    super(e, s, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: si
    }), this.constant = !1, this.settings.update = s.update || (s.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags: e = !1 } = {}) {
    const s = this.state.needsRedraw;
    return this.state.needsRedraw = s && !e, s;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var s;
    (s = this.state).layoutChanged || (s.layoutChanged = !P1(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const { accessor: e } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const { accessor: s } = this.settings, n = this.settings.transition, r = Array.isArray(s) ? (
      // @ts-ignore
      e[s.find((i) => e[i])]
    ) : (
      // @ts-ignore
      e[s]
    );
    return Vp(r, n);
  }
  setNeedsUpdate(e = this.id, s) {
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), s) {
      const { startRow: n = 0, endRow: r = 1 / 0 } = s;
      this.state.updateRanges = D1(this.state.updateRanges, [n, r]);
    } else
      this.state.updateRanges = si;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = F1;
  }
  setNeedsRedraw(e = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const { state: s, settings: n } = this;
    return n.noAlloc ? !1 : n.update ? (super.allocate(e, s.updateRanges !== si), !0) : !1;
  }
  updateBuffer({ numInstances: e, data: s, props: n, context: r }) {
    if (!this.needsUpdate())
      return !1;
    const { state: { updateRanges: i }, settings: { update: o, noAlloc: a } } = this;
    let c = !0;
    if (o) {
      for (const [l, h] of i)
        o.call(r, this, { data: s, startRow: l, endRow: h, props: n, numInstances: e });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [l, h] of i) {
          const u = Number.isFinite(l) ? this.getVertexOffset(l) : 0, f = Number.isFinite(h) ? this.getVertexOffset(h) : a || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({ startOffset: u, endOffset: f });
        }
      this._checkAttributeArray();
    } else
      c = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), c;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({ constant: !0, value: e }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const { state: s } = this;
    return e ? (this.clearNeedsUpdate(), s.lastExternalBuffer === e || (s.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (s.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e, s = null) {
    const { state: n, settings: r } = this;
    if (!e)
      return n.binaryValue = null, n.binaryAccessor = null, !1;
    if (r.noAlloc)
      return !1;
    if (n.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (n.binaryValue = e, this.setNeedsRedraw(), r.transform || s !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = { value: e });
      const o = e;
      ue(ArrayBuffer.isView(o.value), `invalid ${r.accessor}`);
      const a = !!o.size && o.size !== this.size;
      return n.binaryAccessor = N1(o.value, {
        size: o.size || this.size,
        stride: o.stride,
        offset: o.offset,
        startIndices: s,
        nested: a
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const { startIndices: s } = this;
    return (s ? e < s.length ? s[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, s = super.getValue();
    if (!e)
      return s;
    for (const n in e)
      Object.assign(s, super.getValue(n, e[n]));
    return s;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const s = this.settings.shaderAttributes, n = super._getBufferLayout(), { stepMode: r } = this.settings;
    if (r === "dynamic" ? n.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : n.stepMode = r ?? "vertex", !s)
      return n;
    for (const i in s) {
      const o = super._getBufferLayout(i, s[i]);
      n.attributes.push(...o.attributes);
    }
    return n;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, { data: s, startRow: n, endRow: r, props: i, numInstances: o }) {
    if (e.constant)
      return;
    const { settings: a, state: c, value: l, size: h, startIndices: u } = e, { accessor: f, transform: p } = a, m = c.binaryAccessor || // @ts-ignore
    (typeof f == "function" ? f : i[f]);
    ue(typeof m == "function", `accessor "${f}" is not a function`);
    let A = e.getVertexOffset(n);
    const { iterable: E, objectInfo: C } = Lp(s, n, r);
    for (const w of E) {
      C.index++;
      let I = m(w, C);
      if (p && (I = p.call(this, I)), u) {
        const B = (C.index < u.length - 1 ? u[C.index + 1] : o) - u[C.index];
        if (I && Array.isArray(I[0])) {
          let x = A;
          for (const N of I)
            e._normalizeValue(N, l, x), x += h;
        } else I && I.length > h ? l.set(I, A) : (e._normalizeValue(I, C.target, 0), lS({
          target: l,
          source: C.target,
          start: A,
          count: B
        }));
        A += B * h;
      } else
        e._normalizeValue(I, l, A), A += h;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings: e } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value: e } = this, s = Math.min(4, this.size);
    if (e && e.length >= s) {
      let n = !0;
      switch (s) {
        case 4:
          n = n && Number.isFinite(e[3]);
        case 3:
          n = n && Number.isFinite(e[2]);
        case 2:
          n = n && Number.isFinite(e[1]);
        case 1:
          n = n && Number.isFinite(e[0]);
          break;
        default:
          n = !1;
      }
      if (!n)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function Fo(t) {
  const { source: e, target: s, start: n = 0, size: r, getData: i } = t, o = t.end || s.length, a = e.length, c = o - n;
  if (a > c) {
    s.set(e.subarray(0, c), n);
    return;
  }
  if (s.set(e, n), !i)
    return;
  let l = a;
  for (; l < c; ) {
    const h = i(l, e);
    for (let u = 0; u < r; u++)
      s[n + l] = h[u] || 0, l++;
  }
}
function L1({ source: t, target: e, size: s, getData: n, sourceStartIndices: r, targetStartIndices: i }) {
  if (!r || !i)
    return Fo({
      source: t,
      target: e,
      size: s,
      getData: n
    }), e;
  let o = 0, a = 0;
  const c = n && ((h, u) => n(h + a, u)), l = Math.min(r.length, i.length);
  for (let h = 1; h < l; h++) {
    const u = r[h] * s, f = i[h] * s;
    Fo({
      source: t.subarray(o, u),
      target: e,
      start: a,
      end: f,
      size: s,
      getData: c
    }), o = u, a = f;
  }
  return a < e.length && Fo({
    // @ts-ignore
    source: [],
    target: e,
    start: a,
    size: s,
    getData: c
  }), e;
}
function k1(t) {
  const { device: e, settings: s, value: n } = t, r = new Hp(e, s);
  return r.setData({
    value: n instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: s.normalized
  }), r;
}
function zp(t) {
  switch (t) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${t}"`);
  }
}
function jp(t) {
  switch (t) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function Wp(t) {
  t.push(t.shift());
}
function V1(t, e) {
  const { doublePrecision: s, settings: n, value: r, size: i } = t, o = s && r instanceof Float64Array ? 2 : 1;
  let a = 0;
  const { shaderAttributes: c } = t.settings;
  if (c)
    for (const l of Object.values(c))
      a = Math.max(a, l.vertexOffset ?? 0);
  return (n.noAlloc ? r.length : (e + a) * i) * o;
}
function Xp({ device: t, source: e, target: s }) {
  return (!s || s.byteLength < e.byteLength) && (s?.destroy(), s = t.createBuffer({
    byteLength: e.byteLength,
    usage: e.usage
  })), s;
}
function Gp({ device: t, buffer: e, attribute: s, fromLength: n, toLength: r, fromStartIndices: i, getData: o = (a) => a }) {
  const a = s.doublePrecision && s.value instanceof Float64Array ? 2 : 1, c = s.size * a, l = s.byteOffset, h = s.settings.bytesPerElement < 4 ? l / s.settings.bytesPerElement * 4 : l, u = s.startIndices, f = i && u, p = s.isConstant;
  if (!f && e && n >= r)
    return e;
  const m = s.value instanceof Float64Array ? Float32Array : s.value.constructor, A = p ? s.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new m(s.getBuffer().readSyncWebGL(l, r * m.BYTES_PER_ELEMENT).buffer)
  );
  if (s.settings.normalized && !p) {
    const I = o;
    o = (B, x) => s.normalizeConstant(I(B, x));
  }
  const E = p ? (I, B) => o(A, B) : (I, B) => o(A.subarray(I + l, I + l + c), B), C = e ? new Float32Array(e.readSyncWebGL(h, n * 4).buffer) : new Float32Array(0), w = new Float32Array(r);
  return L1({
    source: C,
    target: w,
    sourceStartIndices: i,
    targetStartIndices: u,
    size: c,
    getData: E
  }), (!e || e.byteLength < w.byteLength + h) && (e?.destroy(), e = t.createBuffer({
    byteLength: w.byteLength + h,
    usage: 35050
  })), e.write(w, h), e;
}
class $p {
  constructor({ device: e, attribute: s, timeline: n }) {
    this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new xi(n), this.attribute = s, this.attributeInTransition = k1(s), this.currentStartIndices = s.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, s, n = 1 / 0) {
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = V1(this.attribute, s), this.transition.start({ ...e, duration: n });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class H1 extends $p {
  constructor({ device: e, attribute: s, timeline: n }) {
    super({ device: e, attribute: s, timeline: n }), this.type = "interpolation", this.transform = W1(e, s);
  }
  start(e, s) {
    const n = this.currentLength, r = this.currentStartIndices;
    if (super.start(e, s, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers: i, attribute: o } = this;
    Wp(i), i[0] = Gp({
      device: this.device,
      buffer: i[0],
      attribute: o,
      fromLength: n,
      toLength: this.currentLength,
      fromStartIndices: r,
      getData: e.enter
    }), i[1] = Xp({
      device: this.device,
      source: i[0],
      target: i[1]
    }), this.setBuffer(i[1]);
    const { transform: a } = this, c = a.model;
    let l = Math.floor(this.currentLength / o.size);
    Kp(o) && (l /= 2), c.setVertexCount(l), o.isConstant ? (c.setAttributes({ aFrom: i[0] }), c.setConstantAttributes({ aTo: o.value })) : c.setAttributes({
      aFrom: i[0],
      aTo: o.getBuffer()
    }), a.transformFeedback.setBuffers({ vCurrent: i[1] });
  }
  onUpdate() {
    const { duration: e, easing: s } = this.settings, { time: n } = this.transition;
    let r = n / e;
    s && (r = s(r));
    const { model: i } = this.transform;
    i.setUniforms({ time: r }), this.transform.run({ discard: !0 });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const z1 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`, j1 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function Kp(t) {
  return t.doublePrecision && t.value instanceof Float64Array;
}
function W1(t, e) {
  const s = e.size, n = zp(s), r = jp(s), i = e.getBufferLayout();
  return Kp(e) ? new Jn(t, {
    vs: j1,
    bufferLayout: [
      {
        name: "aFrom",
        byteStride: 8 * s,
        attributes: [
          { attribute: "aFrom", format: r, byteOffset: 0 },
          { attribute: "aFrom64Low", format: r, byteOffset: 4 * s }
        ]
      },
      {
        name: "aTo",
        byteStride: 8 * s,
        attributes: [
          { attribute: "aTo", format: r, byteOffset: 0 },
          { attribute: "aTo64Low", format: r, byteOffset: 4 * s }
        ]
      }
    ],
    modules: [tE],
    defines: {
      ATTRIBUTE_TYPE: n,
      ATTRIBUTE_SIZE: s
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    // @ts-expect-error WebGLRenderPipeline only prop TODO - support in RenderPipeline?
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Jn(t, {
    vs: z1,
    bufferLayout: [
      { name: "aFrom", format: r },
      { name: "aTo", format: i.attributes[0].format }
    ],
    defines: {
      ATTRIBUTE_TYPE: n
    },
    varyings: ["vCurrent"],
    disableWarnings: !0
  });
}
class X1 extends $p {
  constructor({ device: e, attribute: s, timeline: n }) {
    super({ device: e, attribute: s, timeline: n }), this.type = "spring", this.texture = Y1(e), this.framebuffer = J1(e, this.texture), this.transform = K1(e, s);
  }
  start(e, s) {
    const n = this.currentLength, r = this.currentStartIndices;
    super.start(e, s);
    const { buffers: i, attribute: o } = this;
    for (let c = 0; c < 2; c++)
      i[c] = Gp({
        device: this.device,
        buffer: i[c],
        attribute: o,
        fromLength: n,
        toLength: this.currentLength,
        fromStartIndices: r,
        getData: e.enter
      });
    i[2] = Xp({
      device: this.device,
      source: i[0],
      target: i[2]
    }), this.setBuffer(i[1]);
    const { model: a } = this.transform;
    a.setVertexCount(Math.floor(this.currentLength / o.size)), o.isConstant ? a.setConstantAttributes({ aTo: o.value }) : a.setAttributes({ aTo: o.getBuffer() });
  }
  onUpdate() {
    const { buffers: e, transform: s, framebuffer: n, transition: r } = this, i = this.settings;
    s.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), s.transformFeedback.setBuffers({ vNext: e[2] }), s.model.setUniforms({
      stiffness: i.stiffness,
      damping: i.damping
    }), s.run({
      framebuffer: n,
      discard: !1,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    }), Wp(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(n)[0] > 0 || r.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const G1 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, $1 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function K1(t, e) {
  const s = zp(e.size), n = jp(e.size);
  return new Jn(t, {
    vs: G1,
    fs: $1,
    bufferLayout: [
      { name: "aPrev", format: n },
      { name: "aCur", format: n },
      { name: "aTo", format: e.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    defines: { ATTRIBUTE_TYPE: s },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function Y1(t) {
  return t.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    // dataFormat: GL.RGBA,
    width: 1,
    height: 1
  });
}
function J1(t, e) {
  return t.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const q1 = {
  interpolation: H1,
  spring: X1
};
class Z1 {
  constructor(e, { id: s, timeline: n }) {
    if (!e)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = s, this.device = e, this.timeline = n, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes: e, transitions: s, numInstances: n }) {
    this.numInstances = n || 1;
    for (const r in e) {
      const i = e[r], o = i.getTransitionSetting(s);
      o && this._updateAttribute(r, i, o);
    }
    for (const r in this.transitions) {
      const i = e[r];
      (!i || !i.getTransitionSetting(s)) && this._removeTransition(r);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const s = this.transitions[e];
    return s && s.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const s in this.transitions) {
      const n = this.transitions[s];
      n.inProgress && (e[s] = n.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const s in this.transitions)
      this.transitions[s].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, s, n) {
    const r = this.transitions[e];
    let i = !r || r.type !== n.type;
    if (i) {
      r && this._removeTransition(e);
      const o = q1[n.type];
      o ? this.transitions[e] = new o({
        attribute: s,
        timeline: this.timeline,
        device: this.device
      }) : ($.error(`unsupported transition type '${n.type}'`)(), i = !1);
    }
    (i || s.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(n, this.numInstances));
  }
}
const Eu = "attributeManager.invalidate", Q1 = "attributeManager.updateStart", eI = "attributeManager.updateEnd", tI = "attribute.updateStart", sI = "attribute.allocate", nI = "attribute.updateEnd";
class rI {
  constructor(e, { id: s = "attribute-manager", stats: n, timeline: r } = {}) {
    this.mergeBoundsMemoized = ar(VC), this.id = s, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new Z1(e, {
      id: `${s}-transitions`,
      timeline: r
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    const s = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, s && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const s of e)
      this.attributes[s] !== void 0 && (this.attributes[s].delete(), delete this.attributes[s]);
  }
  // Marks an attribute for update
  invalidate(e, s) {
    const n = this._invalidateTrigger(e, s);
    Te(Eu, this, e, n);
  }
  invalidateAll(e) {
    for (const s in this.attributes)
      this.attributes[s].setNeedsUpdate(s, e);
    Te(Eu, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data: e, numInstances: s, startIndices: n = null, transitions: r, props: i = {}, buffers: o = {}, context: a = {} }) {
    let c = !1;
    Te(Q1, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const l in this.attributes) {
      const h = this.attributes[l], u = h.settings.accessor;
      h.startIndices = n, h.numInstances = s, i[l] && $.removed(`props.${l}`, `data.attributes.${l}`)(), h.setExternalBuffer(o[l]) || h.setBinaryValue(typeof u == "string" ? o[u] : void 0, e.startIndices) || typeof u == "string" && !o[u] && h.setConstantValue(i[u]) || h.needsUpdate() && (c = !0, this._updateAttribute({
        attribute: h,
        numInstances: s,
        data: e,
        props: i,
        context: a
      })), this.needsRedraw = this.needsRedraw || h.needsRedraw();
    }
    c && Te(eI, this, s), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: s,
      transitions: r
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager: e } = this, s = e.run();
    return this.needsRedraw = this.needsRedraw || s, s;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const s = e.map((n) => this.attributes[n]?.getBounds());
    return this.mergeBoundsMemoized(s);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(e = { clearChangedFlags: !1 }) {
    const { attributes: s, attributeTransitionManager: n } = this, r = { ...n.getAttributes() };
    for (const i in s) {
      const o = s[i];
      o.needsRedraw(e) && !n.hasAttribute(i) && (r[i] = o);
    }
    return r;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((s) => s.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, s) {
    for (const n in e) {
      const r = e[n], i = {
        ...r,
        id: n,
        size: r.isIndexed && 1 || r.size || 1,
        ...s
      };
      this.attributes[n] = new Hp(this.device, i);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const s in this.attributes)
      this.attributes[s].getUpdateTriggers().forEach((r) => {
        e[r] || (e[r] = []), e[r].push(s);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, s) {
    const { attributes: n, updateTriggers: r } = this, i = r[e];
    return i && i.forEach((o) => {
      const a = n[o];
      a && a.setNeedsUpdate(a.id, s);
    }), i;
  }
  _updateAttribute(e) {
    const { attribute: s, numInstances: n } = e;
    if (Te(tI, s), s.constant) {
      s.setConstantValue(s.value);
      return;
    }
    s.allocate(n) && Te(sI, s, n), s.updateBuffer(e) && (this.needsRedraw = !0, Te(nI, s, n));
  }
}
class iI extends xi {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: e, settings: { fromValue: s, toValue: n, duration: r, easing: i } } = this, o = i(e / r);
    this._value = di(s, n, o);
  }
}
const Cu = 1e-5;
function Su(t, e, s, n, r) {
  const i = e - t, a = (s - e) * r, c = -i * n;
  return a + c + i + e;
}
function oI(t, e, s, n, r) {
  if (Array.isArray(s)) {
    const i = [];
    for (let o = 0; o < s.length; o++)
      i[o] = Su(t[o], e[o], s[o], n, r);
    return i;
  }
  return Su(t, e, s, n, r);
}
function Ru(t, e) {
  if (Array.isArray(t)) {
    let s = 0;
    for (let n = 0; n < t.length; n++) {
      const r = t[n] - e[n];
      s += r * r;
    }
    return Math.sqrt(s);
  }
  return Math.abs(t - e);
}
class aI extends xi {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue: e, toValue: s, damping: n, stiffness: r } = this.settings, { _prevValue: i = e, _currValue: o = e } = this;
    let a = oI(i, o, s, n, r);
    const c = Ru(a, s), l = Ru(a, o);
    c < Cu && l < Cu && (a = s, this.end()), this._prevValue = o, this._currValue = a;
  }
}
const cI = {
  interpolation: iI,
  spring: aI
};
class lI {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, s, n, r) {
    const { transitions: i } = this;
    if (i.has(e)) {
      const c = i.get(e), { value: l = c.settings.fromValue } = c;
      s = l, this.remove(e);
    }
    if (r = Vp(r), !r)
      return;
    const o = cI[r.type];
    if (!o) {
      $.error(`unsupported transition type '${r.type}'`)();
      return;
    }
    const a = new o(this.timeline);
    a.start({
      ...r,
      fromValue: s,
      toValue: n
    }), i.set(e, a);
  }
  remove(e) {
    const { transitions: s } = this;
    s.has(e) && (s.get(e).cancel(), s.delete(e));
  }
  update() {
    const e = {};
    for (const [s, n] of this.transitions)
      n.update(), e[s] = n.value, n.inProgress || this.remove(s);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function hI(t) {
  const e = t[Xt];
  for (const s in e) {
    const n = e[s], { validate: r } = n;
    if (r && !r(t[s], n))
      throw new Error(`Invalid prop ${s}: ${t[s]}`);
  }
}
function uI(t, e) {
  const s = Yp({
    newProps: t,
    oldProps: e,
    propTypes: t[Xt],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  }), n = dI(t, e);
  let r = !1;
  return n || (r = pI(t, e)), {
    dataChanged: n,
    propsChanged: s,
    updateTriggersChanged: r,
    extensionsChanged: _I(t, e),
    transitionsChanged: fI(t, e)
  };
}
function fI(t, e) {
  if (!t.transitions)
    return !1;
  const s = {}, n = t[Xt];
  let r = !1;
  for (const i in t.transitions) {
    const o = n[i], a = o && o.type;
    (a === "number" || a === "color" || a === "array") && Ua(t[i], e[i], o) && (s[i] = !0, r = !0);
  }
  return r ? s : !1;
}
function Yp({ newProps: t, oldProps: e, ignoreProps: s = {}, propTypes: n = {}, triggerName: r = "props" }) {
  if (e === t)
    return !1;
  if (typeof t != "object" || t === null)
    return `${r} changed shallowly`;
  if (typeof e != "object" || e === null)
    return `${r} changed shallowly`;
  for (const i of Object.keys(t))
    if (!(i in s)) {
      if (!(i in e))
        return `${r}.${i} added`;
      const o = Ua(t[i], e[i], n[i]);
      if (o)
        return `${r}.${i} ${o}`;
    }
  for (const i of Object.keys(e))
    if (!(i in s)) {
      if (!(i in t))
        return `${r}.${i} dropped`;
      if (!Object.hasOwnProperty.call(t, i)) {
        const o = Ua(t[i], e[i], n[i]);
        if (o)
          return `${r}.${i} ${o}`;
      }
    }
  return !1;
}
function Ua(t, e, s) {
  let n = s && s.equal;
  return n && !n(t, e, s) || !n && (n = t && e && t.equals, n && !n.call(t, e)) ? "changed deeply" : !n && e !== t ? "changed shallowly" : null;
}
function dI(t, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let s = !1;
  const { dataComparator: n, _dataDiff: r } = t;
  return n ? n(t.data, e.data) || (s = "Data comparator detected a change") : t.data !== e.data && (s = "A new data container was supplied"), s && r && (s = r(t.data, e.data) || s), s;
}
function pI(t, e) {
  if (e === null)
    return { all: !0 };
  if ("all" in t.updateTriggers && wu(t, e, "all"))
    return { all: !0 };
  const s = {};
  let n = !1;
  for (const r in t.updateTriggers)
    r !== "all" && wu(t, e, r) && (s[r] = !0, n = !0);
  return n ? s : !1;
}
function _I(t, e) {
  if (e === null)
    return !0;
  const s = e.extensions, { extensions: n } = t;
  if (n === s)
    return !1;
  if (!s || !n || n.length !== s.length)
    return !0;
  for (let r = 0; r < n.length; r++)
    if (!n[r].equals(s[r]))
      return !0;
  return !1;
}
function wu(t, e, s) {
  let n = t.updateTriggers[s];
  n = n ?? {};
  let r = e.updateTriggers[s];
  return r = r ?? {}, Yp({
    oldProps: r,
    newProps: n,
    triggerName: s
  });
}
const gI = "count(): argument not an object", mI = "count(): argument not a container";
function AI(t) {
  if (!yI(t))
    throw new Error(gI);
  if (typeof t.count == "function")
    return t.count();
  if (Number.isFinite(t.size))
    return t.size;
  if (Number.isFinite(t.length))
    return t.length;
  if (TI(t))
    return Object.keys(t).length;
  throw new Error(mI);
}
function TI(t) {
  return t !== null && typeof t == "object" && t.constructor === Object;
}
function yI(t) {
  return t !== null && typeof t == "object";
}
function Iu(t, e) {
  if (!e)
    return t;
  const s = { ...t, ...e };
  if ("defines" in e && (s.defines = { ...t.defines, ...e.defines }), "modules" in e && (s.modules = (t.modules || []).concat(e.modules), e.modules.some((n) => n.name === "project64"))) {
    const n = s.modules.findIndex((r) => r.name === "project32");
    n >= 0 && s.modules.splice(n, 1);
  }
  if ("inject" in e)
    if (!t.inject)
      s.inject = e.inject;
    else {
      const n = { ...t.inject };
      for (const r in e.inject)
        n[r] = (n[r] || "") + e.inject[r];
      s.inject = n;
    }
  return s;
}
const bI = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, La = {};
function EI(t, e, s, n) {
  if (s instanceof Ne)
    return s;
  s.constructor && s.constructor.name !== "Object" && (s = { data: s });
  let r = null;
  s.compressed && (r = {
    minFilter: "linear",
    mipmapFilter: s.data.length > 1 ? "nearest" : "linear"
  });
  const i = e.createTexture({
    ...s,
    sampler: {
      ...bI,
      ...r,
      ...n
    }
  });
  return La[i.id] = t, i;
}
function CI(t, e) {
  !e || !(e instanceof Ne) || La[e.id] === t && (e.delete(), delete La[e.id]);
}
const SI = {
  boolean: {
    validate(t, e) {
      return !0;
    },
    equal(t, e, s) {
      return !!t == !!e;
    }
  },
  number: {
    validate(t, e) {
      return Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min);
    }
  },
  color: {
    validate(t, e) {
      return e.optional && !t || ka(t) && (t.length === 3 || t.length === 4);
    },
    equal(t, e, s) {
      return Je(t, e, 1);
    }
  },
  accessor: {
    validate(t, e) {
      const s = yi(t);
      return s === "function" || s === yi(e.value);
    },
    equal(t, e, s) {
      return typeof e == "function" ? !0 : Je(t, e, 1);
    }
  },
  array: {
    validate(t, e) {
      return e.optional && !t || ka(t);
    },
    equal(t, e, s) {
      const { compare: n } = s, r = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Je(t, e, r) : t === e;
    }
  },
  object: {
    equal(t, e, s) {
      if (s.ignore)
        return !0;
      const { compare: n } = s, r = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Je(t, e, r) : t === e;
    }
  },
  function: {
    validate(t, e) {
      return e.optional && !t || typeof t == "function";
    },
    equal(t, e, s) {
      return !s.compare && s.ignore !== !1 || t === e;
    }
  },
  data: {
    transform: (t, e, s) => {
      if (!t)
        return t;
      const { dataTransform: n } = s.props;
      return n ? n(t) : typeof t.shape == "string" && t.shape.endsWith("-table") && Array.isArray(t.data) ? t.data : t;
    }
  },
  image: {
    transform: (t, e, s) => {
      const n = s.context;
      return !n || !n.device ? null : EI(s.id, n.device, t, {
        ...e.parameters,
        ...s.props.textureParameters
      });
    },
    release: (t, e, s) => {
      CI(s.id, t);
    }
  }
};
function RI(t) {
  const e = {}, s = {}, n = {};
  for (const [r, i] of Object.entries(t)) {
    const o = i?.deprecatedFor;
    if (o)
      n[r] = Array.isArray(o) ? o : [o];
    else {
      const a = wI(r, i);
      e[r] = a, s[r] = a.value;
    }
  }
  return { propTypes: e, defaultProps: s, deprecatedProps: n };
}
function wI(t, e) {
  switch (yi(e)) {
    case "object":
      return In(t, e);
    case "array":
      return In(t, { type: "array", value: e, compare: !1 });
    case "boolean":
      return In(t, { type: "boolean", value: e });
    case "number":
      return In(t, { type: "number", value: e });
    case "function":
      return In(t, { type: "function", value: e, compare: !0 });
    default:
      return { name: t, type: "unknown", value: e };
  }
}
function In(t, e) {
  return "type" in e ? { name: t, ...SI[e.type], ...e } : "value" in e ? { name: t, type: yi(e.value), ...e } : { name: t, type: "object", value: e };
}
function ka(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t);
}
function yi(t) {
  return ka(t) ? "array" : t === null ? "null" : typeof t;
}
function II(t, e) {
  let s;
  for (let i = e.length - 1; i >= 0; i--) {
    const o = e[i];
    "extensions" in o && (s = o.extensions);
  }
  const n = Va(t.constructor, s), r = Object.create(n);
  r[Ai] = t, r[As] = {}, r[zt] = {};
  for (let i = 0; i < e.length; ++i) {
    const o = e[i];
    for (const a in o)
      r[a] = o[a];
  }
  return Object.freeze(r), r;
}
const vI = "_mergedDefaultProps";
function Va(t, e) {
  if (!(t instanceof Ui.constructor))
    return {};
  let s = vI;
  if (e)
    for (const r of e) {
      const i = r.constructor;
      i && (s += `:${i.extensionName || i.name}`);
    }
  const n = Jp(t, s);
  return n || (t[s] = BI(t, e || []));
}
function BI(t, e) {
  if (!t.prototype)
    return null;
  const n = Object.getPrototypeOf(t), r = Va(n), i = Jp(t, "defaultProps") || {}, o = RI(i), a = Object.assign(/* @__PURE__ */ Object.create(null), r, o.defaultProps), c = Object.assign(/* @__PURE__ */ Object.create(null), r?.[Xt], o.propTypes), l = Object.assign(/* @__PURE__ */ Object.create(null), r?.[Co], o.deprecatedProps);
  for (const h of e) {
    const u = Va(h.constructor);
    u && (Object.assign(a, u), Object.assign(c, u[Xt]), Object.assign(l, u[Co]));
  }
  return MI(a, t), OI(a, c), PI(a, l), a[Xt] = c, a[Co] = l, e.length === 0 && !Hc(t, "_propTypes") && (t._propTypes = c), a;
}
function MI(t, e) {
  const s = NI(e);
  Object.defineProperties(t, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: s
    }
  });
}
function PI(t, e) {
  for (const s in e)
    Object.defineProperty(t, s, {
      enumerable: !1,
      set(n) {
        const r = `${this.id}: ${s}`;
        for (const i of e[s])
          Hc(this, i) || (this[i] = n);
        $.deprecated(r, e[s].join("/"))();
      }
    });
}
function OI(t, e) {
  const s = {}, n = {};
  for (const r in e) {
    const i = e[r], { name: o, value: a } = i;
    i.async && (s[o] = a, n[o] = xI(o));
  }
  t[Js] = s, t[As] = {}, Object.defineProperties(t, n);
}
function xI(t) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || kp(e) ? this[As][t] = e : this[zt][t] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[zt]) {
        if (t in this[zt])
          return this[zt][t] || this[Js][t];
        if (t in this[As]) {
          const e = this[Ai] && this[Ai].internalState;
          if (e && e.hasAsyncProp(t))
            return e.getAsyncProp(t) || this[Js][t];
        }
      }
      return this[Js][t];
    }
  };
}
function Hc(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Jp(t, e) {
  return Hc(t, e) && t[e];
}
function NI(t) {
  const e = t.componentName;
  return e || $.warn(`${t.name}.componentName not specified`)(), e || t.name;
}
let FI = 0;
class Ui {
  constructor(...e) {
    this.props = II(this, e), this.id = this.props.id, this.count = FI++;
  }
  // clone this layer with modified props
  clone(e) {
    const { props: s } = this, n = {};
    for (const r in s[Js])
      r in s[zt] ? n[r] = s[zt][r] : r in s[As] && (n[r] = s[As][r]);
    return new this.constructor({ ...s, ...n, ...e });
  }
}
Ui.componentName = "Component";
Ui.defaultProps = {};
const DI = Object.freeze({});
class UI {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const s = this.asyncProps[e];
      s && s.type && s.type.release && s.type.release(s.resolvedValue, s.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || DI;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const s = this.asyncProps[e];
    return s && s.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const s = this.asyncProps[e];
      return !!(s && s.pendingLoadCount > 0 && s.pendingLoadCount !== s.resolvedLoadCount);
    }
    for (const s in this.asyncProps)
      if (this.isAsyncPropLoading(s))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, s) {
    this._watchPromise(e, Promise.resolve(s));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[Ai] || this.component;
    const s = e[zt] || {}, n = e[As] || e, r = e[Js] || {};
    for (const i in s) {
      const o = s[i];
      this._createAsyncPropData(i, r[i]), this._updateAsyncProp(i, o), s[i] = this.getAsyncProp(i);
    }
    for (const i in n) {
      const o = n[i];
      this._createAsyncPropData(i, r[i]), this._updateAsyncProp(i, o);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, s) {
    return null;
  }
  _onResolve(e, s) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, s) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, s) {
    if (this._didAsyncInputValueChange(e, s)) {
      if (typeof s == "string" && (s = this._fetch(e, s)), s instanceof Promise) {
        this._watchPromise(e, s);
        return;
      }
      if (kp(s)) {
        this._resolveAsyncIterable(e, s);
        return;
      }
      this._setPropValue(e, s);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, s) {
    const n = this.asyncProps[e];
    return s === n.resolvedValue || s === n.lastValue ? !1 : (n.lastValue = s, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, s) {
    this._freezeAsyncOldProps();
    const n = this.asyncProps[e];
    n && (s = this._postProcessValue(n, s), n.resolvedValue = s, n.pendingLoadCount++, n.resolvedLoadCount = n.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, s, n) {
    const r = this.asyncProps[e];
    r && n >= r.resolvedLoadCount && s !== void 0 && (this._freezeAsyncOldProps(), r.resolvedValue = s, r.resolvedLoadCount = n, this.onAsyncPropUpdated(e, s));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, s) {
    const n = this.asyncProps[e];
    if (n) {
      n.pendingLoadCount++;
      const r = n.pendingLoadCount;
      s.then((i) => {
        this.component && (i = this._postProcessValue(n, i), this._setAsyncPropValue(e, i, r), this._onResolve(e, i));
      }).catch((i) => {
        this._onError(e, i);
      });
    }
  }
  async _resolveAsyncIterable(e, s) {
    if (e !== "data") {
      this._setPropValue(e, s);
      return;
    }
    const n = this.asyncProps[e];
    if (!n)
      return;
    n.pendingLoadCount++;
    const r = n.pendingLoadCount;
    let i = [], o = 0;
    for await (const a of s) {
      if (!this.component)
        return;
      const { dataTransform: c } = this.component.props;
      c ? i = c(a, i) : i = i.concat(a), Object.defineProperty(i, "__diff", {
        enumerable: !1,
        value: [{ startRow: o, endRow: i.length }]
      }), o = i.length, this._setAsyncPropValue(e, i, r);
    }
    this._onResolve(e, i);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, s) {
    const n = e.type;
    return n && this.component && (n.release && n.release(e.resolvedValue, n, this.component), n.transform) ? n.transform(s, n, this.component) : s;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, s) {
    if (!this.asyncProps[e]) {
      const r = this.component && this.component.props[Xt];
      this.asyncProps[e] = {
        type: r && r[e],
        lastValue: null,
        resolvedValue: s,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class LI extends UI {
  constructor({ attributeManager: e, layer: s }) {
    super(s), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, s) {
    const n = this.layer, r = n?.props.fetch;
    return r ? r(s, { propName: e, layer: n }) : super._fetch(e, s);
  }
  _onResolve(e, s) {
    const n = this.layer;
    if (n) {
      const r = n.props.onDataLoad;
      e === "data" && r && r(s, { propName: e, layer: n });
    }
  }
  _onError(e, s) {
    const n = this.layer;
    n && n.raiseError(s, `loading ${e} of ${this.layer}`);
  }
}
const kI = "layer.changeFlag", VI = "layer.initialize", HI = "layer.update", zI = "layer.finalize", jI = "layer.matched", vu = 2 ** 24 - 1, WI = Object.freeze([]), XI = ar(({ oldViewport: t, viewport: e }) => t.equals(e));
let ft = new Uint8ClampedArray(0);
const GI = {
  // data: Special handling for null, see below
  data: { type: "data", value: WI, async: !0 },
  dataComparator: { type: "function", value: null, optional: !0 },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (t) => t && t.__diff,
    optional: !0
  },
  dataTransform: { type: "function", value: null, optional: !0 },
  onDataLoad: { type: "function", value: null, optional: !0 },
  onError: { type: "function", value: null, optional: !0 },
  fetch: {
    type: "function",
    value: (t, { propName: e, layer: s, loaders: n, loadOptions: r, signal: i }) => {
      const { resourceManager: o } = s.context;
      r = r || s.getLoadOptions(), n = n || s.props.loaders, i && (r = {
        ...r,
        fetch: {
          ...r?.fetch,
          signal: i
        }
      });
      let a = o.contains(t);
      return !a && !r && (o.add({ resourceId: t, data: $t(t, n), persistent: !1 }), a = !0), a ? o.subscribe({
        resourceId: t,
        onChange: (c) => s.internalState?.reloadAsyncProp(e, c),
        consumerId: s.id,
        requestId: e
      }) : $t(t, n, r);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: !0 },
  onClick: { type: "function", value: null, optional: !0 },
  onDragStart: { type: "function", value: null, optional: !0 },
  onDrag: { type: "function", value: null, optional: !0 },
  onDragEnd: { type: "function", value: null, optional: !0 },
  coordinateSystem: X.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
  modelMatrix: { type: "array", value: null, compare: !0, optional: !0 },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: !0, compare: 2 },
  loadOptions: { type: "object", value: null, optional: !0, ignore: !0 },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: !0, ignore: !0 },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex: t }) => [0, -t * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class fn extends Ui {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = Fs.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    ue(this.internalState);
    const s = this.internalState.viewport || this.context.viewport, n = _p(e, {
      viewport: s,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [r, i, o] = fp(n, s.pixelProjectionMatrix);
    return e.length === 2 ? [r, i] : [r, i, o];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return ue(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, s) {
    ue(this.internalState);
    const n = this.internalState.viewport || this.context.viewport;
    return GC(e, {
      viewport: n,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...s
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({ stateChanged: !0 }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  // TODO deprecate in favour of setShaderModuleProps
  /** Update shader module parameters */
  setModuleParameters(e) {
    for (const s of this.getModels())
      s.updateModuleSettings(e);
  }
  /** Update shader input parameters */
  setShaderModuleProps(...e) {
    for (const s of this.getModels())
      s.shaderInputs.setProps(...e);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem: e } = this.props;
    return e === X.DEFAULT || e === X.LNGLAT || e === X.CARTESIAN;
  }
  // Event handling
  onHover(e, s) {
    return this.props.onHover && this.props.onHover(e, s) || !1;
  }
  onClick(e, s) {
    return this.props.onClick && this.props.onClick(e, s) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e, s = []) {
    return s[0] = e + 1 & 255, s[1] = e + 1 >> 8 & 255, s[2] = e + 1 >> 8 >> 8 & 255, s;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    ue(e instanceof Uint8Array);
    const [s, n, r] = e;
    return s + n * 256 + r * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : AI(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = Iu(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const s of this.props.extensions)
      e = Iu(e, s.getShaders.call(this, s));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const s = this.getAttributeManager(), { dataChanged: n } = e.changeFlags;
    if (n && s)
      if (Array.isArray(n))
        for (const r of n)
          s.invalidateAll(r);
      else
        s.invalidateAll();
    if (s) {
      const { props: r } = e, i = this.internalState.hasPickingBuffer, o = Number.isInteger(r.highlightedObjectIndex) || r.pickable || r.extensions.some((a) => a.getNeedsPickingBuffer.call(this, a));
      if (i !== o) {
        this.internalState.hasPickingBuffer = o;
        const { pickingColors: a, instancePickingColors: c } = s.attributes, l = a || c;
        l && (o && l.constant && (l.constant = !1, s.invalidate(l.id)), !l.value && !o && (l.constant = !0, l.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const n of this.getModels())
      n.destroy();
    const s = this.getAttributeManager();
    s && s.finalize(), this.context && this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const s of this.getModels())
      s.draw(e);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info: e, mode: s, sourceLayer: n }) {
    const { index: r } = e;
    return r >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[r]), e;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, s) {
    s && (e = new Error(`${s}: ${e.message}`, { cause: e })), this.props.onError?.(e) || this.context?.onError?.(e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const s = this.internalState.viewport;
    this.internalState.viewport = e, (!s || !XI({ oldViewport: s, viewport: e })) && (this.setChangeFlags({ viewportChanged: !0 }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(e = "all") {
    const s = this.getAttributeManager();
    s && (e === "all" ? s.invalidateAll() : s.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let s = !1;
    for (const n in e)
      e[n].layoutChanged() && (s = !0);
    for (const n of this.getModels())
      this._setModelAttributes(n, e, s);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const s = this.props, n = this.getNumInstances(), r = this.getStartIndices();
    e.update({
      data: s.data,
      numInstances: n,
      startIndices: r,
      props: s,
      transitions: s.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: s.data.attributes,
      context: this
    });
    const i = e.getChangedAttributes({ clearChangedFlags: !0 });
    this.updateAttributes(i);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions: e } = this.internalState;
    if (e.active) {
      const s = e.update(), n = Object.create(this.props);
      for (const r in s)
        Object.defineProperty(n, r, { value: s[r] });
      return n;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, { numInstances: s }) {
    if (e.constant)
      return;
    const n = Math.floor(ft.length / 4);
    if (this.internalState.usesPickingColorCache = !0, n < s) {
      s > vu && $.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), ft = Yn.allocate(ft, s, {
        size: 4,
        copy: !0,
        maxCount: Math.max(s, vu)
      });
      const r = Math.floor(ft.length / 4), i = [];
      for (let o = n; o < r; o++)
        this.encodePickingColor(o, i), ft[o * 4 + 0] = i[0], ft[o * 4 + 1] = i[1], ft[o * 4 + 2] = i[2];
    }
    e.value = ft.subarray(0, s * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, s, n = !1) {
    if (!Object.keys(s).length)
      return;
    if (n) {
      const a = this.getAttributeManager();
      e.setBufferLayout(a.getBufferLayouts(e)), s = a.getAttributes();
    }
    const r = e.userData?.excludeAttributes || {}, i = {}, o = {};
    for (const a in s) {
      if (r[a])
        continue;
      const c = s[a].getValue();
      for (const l in c) {
        const h = c[l];
        h instanceof re ? s[a].settings.isIndexed ? e.setIndexBuffer(h) : i[l] = h : h && (o[l] = h);
      }
    }
    e.setAttributes(i), e.setConstantAttributes(o);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const s = this.props.data;
    if (!("attributes" in s)) {
      this._disablePickingIndex(e);
      return;
    }
    const { pickingColors: n, instancePickingColors: r } = this.getAttributeManager().attributes, i = n || r, o = i && s.attributes && s.attributes[i.id];
    if (o && o.value) {
      const a = o.value, c = this.encodePickingColor(e);
      for (let l = 0; l < s.length; l++) {
        const h = i.getVertexOffset(l);
        a[h] === c[0] && a[h + 1] === c[1] && a[h + 2] === c[2] && this._disablePickingIndex(l);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const { pickingColors: s, instancePickingColors: n } = this.getAttributeManager().attributes, r = s || n;
    if (!r)
      return;
    const i = r.getVertexOffset(e), o = r.getVertexOffset(e + 1);
    r.buffer.write(new Uint8Array(o - i), i);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors: e, instancePickingColors: s } = this.getAttributeManager().attributes, n = e || s;
    n && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && n.value.buffer !== ft.buffer && (n.value = ft.subarray(0, n.value.length)), n.updateSubBuffer({ startOffset: 0 }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    ue(!this.internalState), ue(Number.isFinite(this.props.coordinateSystem)), Te(VI, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new LI({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => ($.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new lI(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const s of this.props.extensions)
      s.initializeState.call(this, this.context, s);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    Te(jI, this, this === e);
    const { state: s, internalState: n } = e;
    this !== e && (this.internalState = n, this.state = s, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (Te(HI, this, e), !e)
      return;
    const s = this.props, n = this.context, r = this.internalState, i = n.viewport, o = this._updateUniformTransition();
    r.propsInTransition = o, n.viewport = r.viewport || i, this.props = o;
    try {
      const a = this._getUpdateParams(), c = this.getModels();
      if (n.device)
        this.updateState(a);
      else
        try {
          this.updateState(a);
        } catch {
        }
      for (const h of this.props.extensions)
        h.updateState.call(this, a, h);
      const l = this.getModels()[0] !== c[0];
      this._postUpdate(a, l);
    } finally {
      n.viewport = i, this.props = s, this._clearChangeFlags(), r.needsUpdate = !1, r.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    Te(zI, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer({ renderPass: e, moduleParameters: s = null, uniforms: n = {}, parameters: r = {} }) {
    this._updateAttributeTransition();
    const i = this.props, o = this.context;
    this.props = this.internalState.propsInTransition || i;
    const a = this.props.opacity;
    n.opacity = Math.pow(a, 1 / 2.2);
    try {
      if (s) {
        const { isActive: h, isAttribute: u } = s.picking;
        this.setModuleParameters(s), this.setShaderModuleProps({ picking: { isActive: h, isAttribute: u } });
      }
      const { getPolygonOffset: c } = this.props, l = c && c(n) || [0, 0];
      o.device.setParametersWebGL({ polygonOffset: l });
      for (const h of this.getModels())
        h.setParameters(r);
      o.device.withParametersWebGL(r, () => {
        const h = { renderPass: e, moduleParameters: s, uniforms: n, parameters: r, context: o };
        for (const u of this.props.extensions)
          u.draw.call(this, h, u);
        this.draw(h);
      });
    } finally {
      this.props = i;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const { changeFlags: s } = this.internalState;
    for (const r in e)
      if (e[r]) {
        let i = !1;
        switch (r) {
          case "dataChanged":
            const o = e[r], a = s[r];
            o && Array.isArray(a) && (s.dataChanged = Array.isArray(o) ? a.concat(o) : o, i = !0);
          default:
            s[r] || (s[r] = e[r], i = !0);
        }
        i && Te(kI, this, r, e);
      }
    const n = !!(s.dataChanged || s.updateTriggersChanged || s.propsChanged || s.extensionsChanged);
    s.propsOrDataChanged = n, s.somethingChanged = n || s.viewportChanged || s.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, s) {
    const n = uI(e, s);
    if (n.updateTriggersChanged)
      for (const r in n.updateTriggersChanged)
        n.updateTriggersChanged[r] && this.invalidateAttribute(r);
    if (n.transitionsChanged)
      for (const r in n.transitionsChanged)
        this.internalState.uniformTransitions.add(r, s[r], e[r], e.transitions?.[r]);
    return this.setChangeFlags(n);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    hI(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const s = {
      // @ts-expect-error stricter luma gl types
      highlightedObjectColor: e.picked ? e.color : null
    }, { highlightColor: n } = this.props;
    e.picked && typeof n == "function" && (s.highlightColor = n(e)), this.setShaderModuleProps({ picking: s }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new rI(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(e, s) {
    const { props: n, oldProps: r } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const i = this.state.model;
    i?.isInstanced && i.setInstanceCount(this.getNumInstances());
    const { autoHighlight: o, highlightedObjectIndex: a, highlightColor: c } = n;
    if (s || r.autoHighlight !== o || r.highlightedObjectIndex !== a || r.highlightColor !== c) {
      const l = {};
      Array.isArray(c) && (l.highlightColor = c), (s || r.autoHighlight !== o || a !== r.highlightedObjectIndex) && (l.highlightedObjectColor = Number.isFinite(a) && a >= 0 ? this.encodePickingColor(a) : null), this.setShaderModuleProps({ picking: l });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let s = !1;
    s = s || this.internalState.needsRedraw && this.id;
    const n = this.getAttributeManager(), r = n ? n.getNeedsRedraw(e) : !1;
    if (s = s || r, s)
      for (const i of this.props.extensions)
        i.onNeedsRedraw.call(this, i);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, s;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
fn.defaultProps = GI;
fn.layerName = "Layer";
const $I = "compositeLayer.renderLayers";
class qp extends fn {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info: e }) {
    const { object: s } = e;
    return s && s.__source && s.__source.parent && s.__source.parent.id === this.id && (e.object = s.__source.object, e.index = s.__source.index), e;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, s) {
    return s && s.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, s) {
    const { _subLayerProps: n } = this.props;
    return n && n[e] && n[e].type || s;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, s, n) {
    return e.__source = {
      parent: this,
      object: s,
      index: n
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const s = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (n, r) => n && n.__source ? (s.index = n.__source.index, e(n.__source.object, s)) : e(n, r);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(e = {}) {
    const { opacity: s, pickable: n, visible: r, parameters: i, getPolygonOffset: o, highlightedObjectIndex: a, autoHighlight: c, highlightColor: l, coordinateSystem: h, coordinateOrigin: u, wrapLongitude: f, positionFormat: p, modelMatrix: m, extensions: A, fetch: E, operation: C, _subLayerProps: w } = this.props, I = {
      id: "",
      updateTriggers: {},
      opacity: s,
      pickable: n,
      visible: r,
      parameters: i,
      getPolygonOffset: o,
      highlightedObjectIndex: a,
      autoHighlight: c,
      highlightColor: l,
      coordinateSystem: h,
      coordinateOrigin: u,
      wrapLongitude: f,
      positionFormat: p,
      modelMatrix: m,
      extensions: A,
      fetch: E,
      operation: C
    }, B = w && e.id && w[e.id], x = B && B.updateTriggers, N = e.id || "sublayer";
    if (B) {
      const L = this.props[Xt], k = e.type ? e.type._propTypes : {};
      for (const F in B) {
        const U = k[F] || L[F];
        U && U.type === "accessor" && (B[F] = this.getSubLayerAccessor(B[F]));
      }
    }
    Object.assign(
      I,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      B
    ), I.id = `${this.props.id}-${N}`, I.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...e.updateTriggers,
      ...x
    };
    for (const L of A) {
      const k = L.getSubLayerProps.call(this, L);
      k && Object.assign(I, k, {
        updateTriggers: Object.assign(I.updateTriggers, k.updateTriggers)
      });
    }
    return I;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const s of this.getSubLayers())
      s.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, s) {
    let n = this.internalState.subLayers;
    const r = !n || this.needsUpdate();
    if (r) {
      const i = this.renderLayers();
      n = nn(i, Boolean), this.internalState.subLayers = n;
    }
    Te($I, this, r, n);
    for (const i of n)
      i.parent = this;
  }
}
qp.layerName = "CompositeLayer";
const KI = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, YI = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Zp = [0, 0, 0, 255], Qp = [0, 0, 1], JI = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (t) => t.position },
  getNormal: { type: "accessor", value: Qp },
  getColor: { type: "accessor", value: Zp },
  material: !0,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function qI(t) {
  const { header: e, attributes: s } = t;
  if (!(!e || !s) && (t.length = e.vertexCount, s.POSITION && (s.instancePositions = s.POSITION), s.NORMAL && (s.instanceNormals = s.NORMAL), s.COLOR_0)) {
    const { size: n, value: r } = s.COLOR_0;
    s.instanceColors = { size: n, type: "unorm8", value: r };
  }
}
class zc extends fn {
  getShaders() {
    return super.getShaders({ vs: KI, fs: YI, modules: [vc, O0, Pc] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: Qp
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: Zp
      }
    });
  }
  updateState(e) {
    const { changeFlags: s, props: n } = e;
    super.updateState(e), s.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), s.dataChanged && qI(n.data);
  }
  draw({ uniforms: e }) {
    const { pointSize: s, sizeUnits: n } = this.props, r = this.state.model;
    r.setUniforms(e), r.setUniforms({
      sizeUnits: Ca[n],
      radiusPixels: s
    }), r.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [];
    for (let s = 0; s < 3; s++) {
      const n = s / 3 * Math.PI * 2;
      e.push(Math.cos(n) * 2, Math.sin(n) * 2, 0);
    }
    return new Yt(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Ks({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(e)
        }
      }),
      isInstanced: !0
    });
  }
}
zc.layerName = "PointCloudLayer";
zc.defaultProps = JI;
const xe = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new S();
new S();
const vn = new S(), Bu = new S();
class hr {
  /** Creates a bounding sphere */
  constructor(e = [0, 0, 0], s = 0) {
    this.radius = -0, this.center = new S(), this.fromCenterRadius(e, s);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, s) {
    return this.center.from(e), this.radius = s, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, s) {
    return s = vn.from(s), this.center = new S().from(e).add(s).scale(0.5), this.radius = this.center.distance(s), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new hr(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const s = this.center, n = this.radius, r = e.center, i = e.radius, o = vn.copy(r).subtract(s), a = o.magnitude();
    if (n >= a + i)
      return this.clone();
    if (i >= a + n)
      return e.clone();
    const c = (n + a + i) * 0.5;
    return Bu.copy(o).scale((-n + c) / a).add(s), this.center.copy(Bu), this.radius = c, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const n = vn.from(e).subtract(this.center).magnitude();
    return n > this.radius && (this.radius = n), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const s = zE(vn, e);
    return this.radius = Math.max(s[0], Math.max(s[1], s[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const s = this.distanceTo(e);
    return s * s;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const n = vn.from(e).subtract(this.center);
    return Math.max(0, n.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const s = this.center, n = this.radius, i = e.normal.dot(s) + e.distance;
    return i < -n ? xe.OUTSIDE : i < n ? xe.INTERSECTING : xe.INSIDE;
  }
}
const ZI = new S(), QI = new S(), kr = new S(), Vr = new S(), Hr = new S(), ev = new S(), tv = new S(), Ct = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class ur {
  constructor(e = [0, 0, 0], s = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new S().from(e), this.halfAxes = new ae(s);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), s = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2);
    return [new S(e).len(), new S(s).len(), new S(n).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), s = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2), r = new S(e).normalize(), i = new S(s).normalize(), o = new S(n).normalize();
    return new $n().fromMatrix3(new ae([...r, ...i, ...o]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, s, n) {
    const r = new $n(n), i = new ae().fromQuaternion(r);
    return i[0] = i[0] * s[0], i[1] = i[1] * s[0], i[2] = i[2] * s[0], i[3] = i[3] * s[1], i[4] = i[4] * s[1], i[5] = i[5] * s[1], i[6] = i[6] * s[2], i[7] = i[7] * s[2], i[8] = i[8] * s[2], this.center = new S().from(e), this.halfAxes = i, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new ur(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(e = new hr()) {
    const s = this.halfAxes, n = s.getColumn(0, kr), r = s.getColumn(1, Vr), i = s.getColumn(2, Hr), o = ZI.copy(n).add(r).add(i);
    return e.center.copy(this.center), e.radius = o.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const s = this.center, n = e.normal, r = this.halfAxes, i = n.x, o = n.y, a = n.z, c = Math.abs(i * r[Ct.COLUMN0ROW0] + o * r[Ct.COLUMN0ROW1] + a * r[Ct.COLUMN0ROW2]) + Math.abs(i * r[Ct.COLUMN1ROW0] + o * r[Ct.COLUMN1ROW1] + a * r[Ct.COLUMN1ROW2]) + Math.abs(i * r[Ct.COLUMN2ROW0] + o * r[Ct.COLUMN2ROW1] + a * r[Ct.COLUMN2ROW2]), l = n.dot(s) + e.distance;
    return l <= -c ? xe.OUTSIDE : l >= c ? xe.INSIDE : xe.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const s = QI.from(e).subtract(this.center), n = this.halfAxes, r = n.getColumn(0, kr), i = n.getColumn(1, Vr), o = n.getColumn(2, Hr), a = r.magnitude(), c = i.magnitude(), l = o.magnitude();
    r.normalize(), i.normalize(), o.normalize();
    let h = 0, u;
    return u = Math.abs(s.dot(r)) - a, u > 0 && (h += u * u), u = Math.abs(s.dot(i)) - c, u > 0 && (h += u * u), u = Math.abs(s.dot(o)) - l, u > 0 && (h += u * u), h;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, s, n = [-0, -0]) {
    let r = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    const o = this.center, a = this.halfAxes, c = a.getColumn(0, kr), l = a.getColumn(1, Vr), h = a.getColumn(2, Hr), u = ev.copy(c).add(l).add(h).add(o), f = tv.copy(u).subtract(e);
    let p = s.dot(f);
    return r = Math.min(p, r), i = Math.max(p, i), u.copy(o).add(c).add(l).subtract(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), u.copy(o).add(c).subtract(l).add(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), u.copy(o).add(c).subtract(l).subtract(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), o.copy(u).subtract(c).add(l).add(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), o.copy(u).subtract(c).add(l).subtract(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), o.copy(u).subtract(c).subtract(l).add(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), o.copy(u).subtract(c).subtract(l).subtract(h), f.copy(u).subtract(e), p = s.dot(f), r = Math.min(p, r), i = Math.max(p, i), n[0] = r, n[1] = i, n;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const s = this.halfAxes.getColumn(0, kr);
    s.transformAsPoint(e);
    const n = this.halfAxes.getColumn(1, Vr);
    n.transformAsPoint(e);
    const r = this.halfAxes.getColumn(2, Hr);
    return r.transformAsPoint(e), this.halfAxes = new ae([...s, ...n, ...r]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const Mu = new S(), Pu = new S();
class pt {
  constructor(e = [0, 0, 1], s = 0) {
    this.normal = new S(), this.distance = -0, this.fromNormalDistance(e, s);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, s) {
    return $e(Number.isFinite(s)), this.normal.from(e).normalize(), this.distance = s, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, s) {
    e = Mu.from(e), this.normal.from(s).normalize();
    const n = -this.normal.dot(e);
    return this.distance = n, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, s, n, r) {
    return this.normal.set(e, s, n), $e(Qe(this.normal.len(), 1)), this.distance = r, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new pt(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return Qe(this.distance, e.distance) && Qe(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const s = Pu.copy(this.normal).transformAsVector(e).normalize(), n = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(n, s);
  }
  projectPointOntoPlane(e, s = [0, 0, 0]) {
    const n = Mu.from(e), r = this.getPointDistance(n), i = Pu.copy(this.normal).scale(r);
    return n.subtract(i).to(s);
  }
}
const Ou = [new S([1, 0, 0]), new S([0, 1, 0]), new S([0, 0, 1])], xu = new S(), sv = new S();
class ke {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(e = []) {
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * Ou.length;
    const s = e.center, n = e.radius;
    let r = 0;
    for (const i of Ou) {
      let o = this.planes[r], a = this.planes[r + 1];
      o || (o = this.planes[r] = new pt()), a || (a = this.planes[r + 1] = new pt());
      const c = xu.copy(i).scale(-n).add(s);
      o.fromPointNormal(c, i);
      const l = xu.copy(i).scale(n).add(s), h = sv.copy(i).negate();
      a.fromPointNormal(l, h), r += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let s = xe.INSIDE;
    for (const n of this.planes)
      switch (e.intersectPlane(n)) {
        case xe.OUTSIDE:
          return xe.OUTSIDE;
        case xe.INTERSECTING:
          s = xe.INTERSECTING;
          break;
      }
    return s;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, s) {
    if ($e(Number.isFinite(s), "parentPlaneMask is required."), s === ke.MASK_OUTSIDE || s === ke.MASK_INSIDE)
      return s;
    let n = ke.MASK_INSIDE;
    const r = this.planes;
    for (let i = 0; i < this.planes.length; ++i) {
      const o = i < 31 ? 1 << i : 0;
      if (i < 31 && (s & o) === 0)
        continue;
      const a = r[i], c = e.intersectPlane(a);
      if (c === xe.OUTSIDE)
        return ke.MASK_OUTSIDE;
      c === xe.INTERSECTING && (n |= o);
    }
    return n;
  }
}
ke.MASK_OUTSIDE = 4294967295;
ke.MASK_INSIDE = 0;
ke.MASK_INDETERMINATE = 2147483647;
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
new S();
const dt = new ae(), nv = new ae(), rv = new ae(), zr = new ae(), Nu = new ae();
function iv(t, e = {}) {
  const s = I0, n = 10;
  let r = 0, i = 0;
  const o = nv, a = rv;
  o.identity(), a.copy(t);
  const c = s * ov(a);
  for (; i < n && av(a) > c; )
    cv(a, zr), Nu.copy(zr).transpose(), a.multiplyRight(zr), a.multiplyLeft(Nu), o.multiplyRight(zr), ++r > 2 && (++i, r = 0);
  return e.unitary = o.toTarget(e.unitary), e.diagonal = a.toTarget(e.diagonal), e;
}
function ov(t) {
  let e = 0;
  for (let s = 0; s < 9; ++s) {
    const n = t[s];
    e += n * n;
  }
  return Math.sqrt(e);
}
const Ha = [1, 0, 0], za = [2, 2, 1];
function av(t) {
  let e = 0;
  for (let s = 0; s < 3; ++s) {
    const n = t[dt.getElementIndex(za[s], Ha[s])];
    e += 2 * n * n;
  }
  return Math.sqrt(e);
}
function cv(t, e) {
  const s = tp;
  let n = 0, r = 1;
  for (let l = 0; l < 3; ++l) {
    const h = Math.abs(t[dt.getElementIndex(za[l], Ha[l])]);
    h > n && (r = l, n = h);
  }
  const i = Ha[r], o = za[r];
  let a = 1, c = 0;
  if (Math.abs(t[dt.getElementIndex(o, i)]) > s) {
    const l = t[dt.getElementIndex(o, o)], h = t[dt.getElementIndex(i, i)], u = t[dt.getElementIndex(o, i)], f = (l - h) / 2 / u;
    let p;
    f < 0 ? p = -1 / (-f + Math.sqrt(1 + f * f)) : p = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + p * p), c = p * a;
  }
  return ae.IDENTITY.to(e), e[dt.getElementIndex(i, i)] = e[dt.getElementIndex(o, o)] = a, e[dt.getElementIndex(o, i)] = c, e[dt.getElementIndex(i, o)] = -c, e;
}
const Lt = new S(), lv = new S(), hv = new S(), uv = new S(), fv = new S(), dv = new ae(), pv = {
  diagonal: new ae(),
  unitary: new ae()
};
function _v(t, e = new ur()) {
  if (!t || t.length === 0)
    return e.halfAxes = new ae([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new S(), e;
  const s = t.length, n = new S(0, 0, 0);
  for (const F of t)
    n.add(F);
  const r = 1 / s;
  n.multiplyByScalar(r);
  let i = 0, o = 0, a = 0, c = 0, l = 0, h = 0;
  for (const F of t) {
    const U = Lt.copy(F).subtract(n);
    i += U.x * U.x, o += U.x * U.y, a += U.x * U.z, c += U.y * U.y, l += U.y * U.z, h += U.z * U.z;
  }
  i *= r, o *= r, a *= r, c *= r, l *= r, h *= r;
  const u = dv;
  u[0] = i, u[1] = o, u[2] = a, u[3] = o, u[4] = c, u[5] = l, u[6] = a, u[7] = l, u[8] = h;
  const { unitary: f } = iv(u, pv), p = e.halfAxes.copy(f);
  let m = p.getColumn(0, hv), A = p.getColumn(1, uv), E = p.getColumn(2, fv), C = -Number.MAX_VALUE, w = -Number.MAX_VALUE, I = -Number.MAX_VALUE, B = Number.MAX_VALUE, x = Number.MAX_VALUE, N = Number.MAX_VALUE;
  for (const F of t)
    Lt.copy(F), C = Math.max(Lt.dot(m), C), w = Math.max(Lt.dot(A), w), I = Math.max(Lt.dot(E), I), B = Math.min(Lt.dot(m), B), x = Math.min(Lt.dot(A), x), N = Math.min(Lt.dot(E), N);
  m = m.multiplyByScalar(0.5 * (B + C)), A = A.multiplyByScalar(0.5 * (x + w)), E = E.multiplyByScalar(0.5 * (N + I)), e.center.copy(m).add(A).add(E);
  const L = lv.set(C - B, w - x, I - N).multiplyByScalar(0.5), k = new ae([L[0], 0, 0, 0, L[1], 0, 0, 0, L[2]]);
  return e.halfAxes.multiplyRight(k), e;
}
const Do = Math.PI / 180, jr = new Float32Array(16), Fu = new Float32Array(12);
function Du(t, e, s) {
  const n = e[0] * Do, r = e[1] * Do, i = e[2] * Do, o = Math.sin(i), a = Math.sin(n), c = Math.sin(r), l = Math.cos(i), h = Math.cos(n), u = Math.cos(r), f = s[0], p = s[1], m = s[2];
  t[0] = f * u * h, t[1] = f * c * h, t[2] = f * -a, t[3] = p * (-c * l + u * a * o), t[4] = p * (u * l + c * a * o), t[5] = p * h * o, t[6] = m * (c * o + u * a * l), t[7] = m * (-u * o + c * a * l), t[8] = m * h * l;
}
function Uu(t) {
  return t[0] = t[0], t[1] = t[1], t[2] = t[2], t[3] = t[4], t[4] = t[5], t[5] = t[6], t[6] = t[8], t[7] = t[9], t[8] = t[10], t[9] = t[12], t[10] = t[13], t[11] = t[14], t.subarray(0, 12);
}
const e_ = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(t, { startRow: e, endRow: s }) {
    const { data: n, getOrientation: r, getScale: i, getTranslation: o, getTransformMatrix: a } = this.props, c = Array.isArray(a), l = c && a.length === 16, h = Array.isArray(i), u = Array.isArray(r), f = Array.isArray(o), p = l || !c && !!a(n[0]);
    p ? t.constant = l : t.constant = u && h && f;
    const m = t.value;
    if (t.constant) {
      let A;
      p ? (jr.set(a), A = Uu(jr)) : (A = Fu, Du(A, r, i), A.set(o, 9)), t.value = new Float32Array(A);
    } else {
      let A = e * t.size;
      const { iterable: E, objectInfo: C } = Lp(n, e, s);
      for (const w of E) {
        C.index++;
        let I;
        if (p)
          jr.set(l ? a : a(w, C)), I = Uu(jr);
        else {
          I = Fu;
          const B = u ? r : r(w, C), x = h ? i : i(w, C);
          Du(I, B, x), I.set(f ? o : o(w, C), 9);
        }
        m[A++] = I[0], m[A++] = I[1], m[A++] = I[2], m[A++] = I[3], m[A++] = I[4], m[A++] = I[5], m[A++] = I[6], m[A++] = I[7], m[A++] = I[8], m[A++] = I[9], m[A++] = I[10], m[A++] = I[11];
      }
    }
  }
};
function t_(t, e) {
  return e === X.CARTESIAN || e === X.METER_OFFSETS || e === X.DEFAULT && !t.isGeospatial;
}
const gv = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;
if (composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, mv = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
}
`;
function Uo(t) {
  const e = t.positions || t.POSITION;
  $.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const s = e.value.length / e.size;
  let n = t.COLOR_0 || t.colors;
  n || (n = { size: 3, value: new Float32Array(s * 3).fill(1) });
  let r = t.NORMAL || t.normals;
  r || (r = { size: 3, value: new Float32Array(s * 3).fill(0) });
  let i = t.TEXCOORD_0 || t.texCoords;
  return i || (i = { size: 2, value: new Float32Array(s * 2).fill(0) }), {
    positions: e,
    colors: n,
    normals: r,
    texCoords: i
  };
}
function Lu(t) {
  return t instanceof Ks ? (t.attributes = Uo(t.attributes), t) : t.attributes ? new Ks({
    ...t,
    topology: "triangle-list",
    attributes: Uo(t.attributes)
  }) : new Ks({
    topology: "triangle-list",
    attributes: Uo(t)
  });
}
const Av = [0, 0, 0, 255], Tv = {
  mesh: { type: "object", value: null, async: !0 },
  texture: { type: "image", value: null, async: !0 },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: Av },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class jc extends fn {
  getShaders() {
    return super.getShaders({
      vs: gv,
      fs: mv,
      modules: [vc, x0, Pc]
    });
  }
  getBounds() {
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const { mesh: s } = this.props;
    if (!s)
      return null;
    if (e = s.header?.boundingBox, !e) {
      const { attributes: n } = Lu(s);
      n.POSITION = n.POSITION || n.positions, e = cd(n);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: e_
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: s, oldProps: n, changeFlags: r } = e;
    if (s.mesh !== n.mesh || r.extensionsChanged) {
      if (this.state.positionBounds = null, this.state.model?.destroy(), s.mesh) {
        this.state.model = this.getModel(s.mesh);
        const i = s.mesh.attributes || s.mesh;
        this.setState({
          hasNormals: !!(i.NORMAL || i.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    s.texture !== n.texture && s.texture instanceof Ne && this.setTexture(s.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw({ uniforms: e }) {
    const { model: s } = this.state;
    if (!s)
      return;
    const { viewport: n, renderPass: r } = this.context, { sizeScale: i, coordinateSystem: o, _instanced: a } = this.props;
    s.setUniforms(e), s.setUniforms({
      sizeScale: i,
      composeModelMatrix: !a || t_(n, o),
      flatShading: !this.state.hasNormals
    }), s.draw(r);
  }
  get isLoaded() {
    return !!(this.state?.model && super.isLoaded);
  }
  getModel(e) {
    const s = new Yt(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: Lu(e),
      isInstanced: !0
    }), { texture: n } = this.props, { emptyTexture: r } = this.state;
    return s.setBindings({
      sampler: n || r
    }), s.setUniforms({
      hasTexture: !!n
    }), s;
  }
  setTexture(e) {
    const { emptyTexture: s, model: n } = this.state;
    n && (n.setBindings({
      sampler: e || s
    }), n.setUniforms({
      hasTexture: !!e
    }));
  }
}
jc.defaultProps = Tv;
jc.layerName = "SimpleMeshLayer";
var Ke;
(function(t) {
  t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.ONE = 1] = "ONE", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.LINEAR = 9729] = "LINEAR", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(Ke || (Ke = {}));
function s_(t, e, s, n) {
  const r = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      u_Camera: [0, 0, 0],
      // Model should override
      u_MetallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  r.defines.USE_TEX_LOD = 1;
  const { imageBasedLightingEnvironment: i } = n;
  return i && (r.bindings.u_DiffuseEnvSampler = i.diffuseEnvSampler, r.bindings.u_SpecularEnvSampler = i.specularEnvSampler, r.bindings.u_brdfLUT = i.brdfLutTexture, r.uniforms.u_ScaleIBLAmbient = [1, 1]), n?.pbrDebug && (r.defines.PBR_DEBUG = 1, r.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], r.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), s.NORMAL && (r.defines.HAS_NORMALS = 1), s.TANGENT && n?.useTangents && (r.defines.HAS_TANGENTS = 1), s.TEXCOORD_0 && (r.defines.HAS_UV = 1), n?.imageBasedLightingEnvironment && (r.defines.USE_IBL = 1), n?.lights && (r.defines.USE_LIGHTS = 1), e && yv(t, e, r), r;
}
function yv(t, e, s) {
  if (s.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && bv(t, e.pbrMetallicRoughness, s), e.normalTexture) {
    Wn(t, e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP", s);
    const { scale: n = 1 } = e.normalTexture;
    s.uniforms.u_NormalScale = n;
  }
  if (e.occlusionTexture) {
    Wn(t, e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP", s);
    const { strength: n = 1 } = e.occlusionTexture;
    s.uniforms.u_OcclusionStrength = n;
  }
  switch (e.emissiveTexture && (Wn(t, e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP", s), s.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode) {
    case "MASK":
      const { alphaCutoff: n = 0.5 } = e;
      s.defines.ALPHA_CUTOFF = 1, s.uniforms.u_AlphaCutoff = n;
      break;
    case "BLEND":
      P.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), s.parameters.blendColorOperation = "add", s.parameters.blendColorSrcFactor = "src-alpha", s.parameters.blendColorDstFactor = "one-minus-src-alpha", s.parameters.blendAlphaOperation = "add", s.parameters.blendAlphaSrcFactor = "one", s.parameters.blendAlphaDstFactor = "one-minus-src-alpha", s.glParameters.blend = !0, s.glParameters.blendEquation = Ke.FUNC_ADD, s.glParameters.blendFunc = [
        Ke.SRC_ALPHA,
        Ke.ONE_MINUS_SRC_ALPHA,
        Ke.ONE,
        Ke.ONE_MINUS_SRC_ALPHA
      ];
      break;
  }
}
function bv(t, e, s) {
  e.baseColorTexture && Wn(t, e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP", s), s.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && Wn(t, e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP", s);
  const { metallicFactor: n = 1, roughnessFactor: r = 1 } = e;
  s.uniforms.u_MetallicRoughnessValues = [n, r];
}
function Wn(t, e, s, n = null, r) {
  const i = e?.texture?.sampler?.parameters || {}, o = e.texture.source.image;
  let a, c = {};
  o.compressed ? (a = o, c = {
    [Ke.TEXTURE_MIN_FILTER]: o.data.length > 1 ? Ke.LINEAR_MIPMAP_NEAREST : Ke.LINEAR
  }) : a = { data: o };
  const l = t.createTexture({
    id: e.uniformName || e.id,
    parameters: {
      ...i,
      ...c
    },
    pixelStore: {
      [Ke.UNPACK_FLIP_Y_WEBGL]: !1
    },
    ...a
  });
  r.bindings[s] = l, n && (r.defines[n] = 1), r.generatedTextures.push(l);
}
const Ev = "4.3.1", bi = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let ku;
async function Vu(t) {
  Zg(t.modules);
  const e = Qg("basis");
  return e || (ku ||= Cv(t), await ku);
}
async function Cv(t) {
  let e = null, s = null;
  return [e, s] = await Promise.all([
    await ps(bi.TRANSCODER, "textures", t),
    await ps(bi.TRANSCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await Sv(e, s);
}
function Sv(t, e) {
  const s = {};
  return e && (s.wasmBinary = e), new Promise((n) => {
    t(s).then((r) => {
      const { BasisFile: i, initializeBasis: o } = r;
      o(), n({ BasisFile: i });
    });
  });
}
let Lo;
async function Hu(t) {
  const e = t.modules || {};
  return e.basisEncoder ? e.basisEncoder : (Lo = Lo || Rv(t), await Lo);
}
async function Rv(t) {
  let e = null, s = null;
  return [e, s] = await Promise.all([
    await ps(bi.ENCODER, "textures", t),
    await ps(bi.ENCODER_WASM, "textures", t)
  ]), e = e || globalThis.BASIS, await wv(e, s);
}
function wv(t, e) {
  const s = {};
  return e && (s.wasmBinary = e), new Promise((n) => {
    t(s).then((r) => {
      const { BasisFile: i, KTX2File: o, initializeBasis: a, BasisEncoder: c } = r;
      a(), n({ BasisFile: i, KTX2File: o, BasisEncoder: c });
    });
  });
}
const Os = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, Iv = ["", "WEBKIT_", "MOZ_"], zu = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let Wr = null;
function vv(t) {
  if (!Wr) {
    t = t || Bv() || void 0, Wr = /* @__PURE__ */ new Set();
    for (const e of Iv)
      for (const s in zu)
        if (t && t.getExtension(`${e}${s}`)) {
          const n = zu[s];
          Wr.add(n);
        }
  }
  return Wr;
}
function Bv() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const Pe = [
  // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function Mv(t) {
  const e = new Uint8Array(t);
  return !(e.byteLength < Pe.length || e[0] !== Pe[0] || // ''
  e[1] !== Pe[1] || // 'K'
  e[2] !== Pe[2] || // 'T'
  e[3] !== Pe[3] || // 'X'
  e[4] !== Pe[4] || // ' '
  e[5] !== Pe[5] || // '2'
  e[6] !== Pe[6] || // '0'
  e[7] !== Pe[7] || // ''
  e[8] !== Pe[8] || // '\r'
  e[9] !== Pe[9] || // '\n'
  e[10] !== Pe[10] || // '\x1A'
  e[11] !== Pe[11]);
}
const Pv = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: Os.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: !0 },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: Os.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: Os.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: !0 },
  bc5: { basisFormat: 5, compressed: !0 },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: !0 },
  "bc7-m5": { basisFormat: 7, compressed: !0 },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: Os.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: Os.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: Os.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: !0 },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: !0 },
  rgba32: { basisFormat: 13, compressed: !1 },
  rgb565: { basisFormat: 14, compressed: !1 },
  bgr565: { basisFormat: 15, compressed: !1 },
  rgba4444: { basisFormat: 16, compressed: !1 }
};
async function Ov(t, e) {
  if (e.basis.containerFormat === "auto") {
    if (Mv(t)) {
      const n = await Hu(e);
      return ju(n.KTX2File, t, e);
    }
    const { BasisFile: s } = await Vu(e);
    return ko(s, t, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const s = await Hu(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return ju(s.KTX2File, t, e);
        case "basis":
        default:
          return ko(s.BasisFile, t, e);
      }
    case "transcoder":
    default:
      const { BasisFile: n } = await Vu(e);
      return ko(n, t, e);
  }
}
function ko(t, e, s) {
  const n = new t(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const r = n.getNumImages(), i = [];
    for (let o = 0; o < r; o++) {
      const a = n.getNumLevels(o), c = [];
      for (let l = 0; l < a; l++)
        c.push(xv(n, o, l, s));
      i.push(c);
    }
    return i;
  } finally {
    n.close(), n.delete();
  }
}
function xv(t, e, s, n) {
  const r = t.getImageWidth(e, s), i = t.getImageHeight(e, s), o = t.getHasAlpha(
    /* imageIndex, levelIndex */
  ), { compressed: a, format: c, basisFormat: l } = n_(n, o), h = t.getImageTranscodedSizeInBytes(e, s, l), u = new Uint8Array(h);
  if (!t.transcodeImage(u, e, s, l, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: r,
    height: i,
    data: u,
    compressed: a,
    format: c,
    // Additional fields
    // Add levelSize field.
    hasAlpha: o
  };
}
function ju(t, e, s) {
  const n = new t(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const r = n.getLevels(), i = [];
    for (let o = 0; o < r; o++)
      i.push(Nv(n, o, s));
    return [i];
  } finally {
    n.close(), n.delete();
  }
}
function Nv(t, e, s) {
  const { alphaFlag: n, height: r, width: i } = t.getImageLevelInfo(e, 0, 0), { compressed: o, format: a, basisFormat: c } = n_(s, n), l = t.getImageTranscodedSizeInBytes(e, 0, 0, c), h = new Uint8Array(l);
  if (!t.transcodeImage(
    h,
    e,
    0,
    0,
    c,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: i,
    height: r,
    data: h,
    compressed: o,
    // Additional fields
    levelSize: l,
    hasAlpha: n,
    format: a
  };
}
function n_(t, e) {
  let s = t && t.basis && t.basis.format;
  return s === "auto" && (s = r_()), typeof s == "object" && (s = e ? s.alpha : s.noAlpha), s = s.toLowerCase(), Pv[s];
}
function r_() {
  const t = vv();
  return t.has("astc") ? "astc-4x4" : t.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : t.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : t.has("etc1") ? "etc1" : t.has("etc2") ? "etc2" : "rgb565";
}
const Fv = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: Ev,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, Dv = {
  ...Fv,
  parse: Ov
}, Uv = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Lv = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
class kv {
  name;
  startTime = 0;
  playing = !0;
  speed = 1;
  channels = [];
  constructor(e) {
    Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const n = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach(({ sampler: r, target: i, path: o }) => {
      Gv(n, r, i, o), zv(i, i._node);
    });
  }
}
class Vv {
  animations;
  constructor(e) {
    this.animations = e.animations.map((s, n) => {
      const r = s.name || `Animation-${n}`, i = s.samplers.map(({ input: a, interpolation: c = "LINEAR", output: l }) => ({
        input: Wu(e.accessors[a]),
        interpolation: c,
        output: Wu(e.accessors[l])
      })), o = s.channels.map(({ sampler: a, target: c }) => ({
        sampler: i[a],
        target: e.nodes[c.node],
        path: c.path
      }));
      return new kv({ name: r, channels: o });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((s) => s.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
function Wu(t) {
  if (!t._animation) {
    const e = Lv[t.componentType], s = Uv[t.type], n = s * t.count, { buffer: r, byteOffset: i } = t.bufferView.data, o = new e(r, i + (t.byteOffset || 0), n);
    if (s === 1)
      t._animation = Array.from(o);
    else {
      const a = [];
      for (let c = 0; c < o.length; c += s)
        a.push(Array.from(o.slice(c, c + s)));
      t._animation = a;
    }
  }
  return t._animation;
}
const Hv = new W();
function zv(t, e) {
  if (e.matrix.identity(), t.translation && e.matrix.translate(t.translation), t.rotation) {
    const s = Hv.fromQuaternion(t.rotation);
    e.matrix.multiplyRight(s);
  }
  t.scale && e.matrix.scale(t.scale);
}
const Vo = new $n();
function jv(t, e, s, n, r) {
  if (e === "rotation") {
    Vo.slerp({ start: s, target: n, ratio: r });
    for (let i = 0; i < Vo.length; i++)
      t[e][i] = Vo[i];
  } else
    for (let i = 0; i < s.length; i++)
      t[e][i] = r * n[i] + (1 - r) * s[i];
}
function Wv(t, e, { p0: s, outTangent0: n, inTangent1: r, p1: i, tDiff: o, ratio: a }) {
  for (let c = 0; c < t[e].length; c++) {
    const l = n[c] * o, h = r[c] * o;
    t[e][c] = (2 * Math.pow(a, 3) - 3 * Math.pow(a, 2) + 1) * s[c] + (Math.pow(a, 3) - 2 * Math.pow(a, 2) + a) * l + (-2 * Math.pow(a, 3) + 3 * Math.pow(a, 2)) * i[c] + (Math.pow(a, 3) - Math.pow(a, 2)) * h;
  }
}
function Xv(t, e, s) {
  for (let n = 0; n < s.length; n++)
    t[e][n] = s[n];
}
function Gv(t, { input: e, interpolation: s, output: n }, r, i) {
  const o = e[e.length - 1], a = t % o, c = e.findIndex((f) => f >= a), l = Math.max(0, c - 1);
  if (!Array.isArray(r[i]))
    switch (i) {
      case "translation":
        r[i] = [0, 0, 0];
        break;
      case "rotation":
        r[i] = [0, 0, 0, 1];
        break;
      case "scale":
        r[i] = [1, 1, 1];
        break;
      default:
        P.warn(`Bad animation path ${i}`)();
    }
  q(r[i].length === n[l].length);
  const h = e[l], u = e[c];
  switch (s) {
    case "STEP":
      Xv(r, i, n[l]);
      break;
    case "LINEAR":
      if (u > h) {
        const f = (a - h) / (u - h);
        jv(r, i, n[l], n[c], f);
      }
      break;
    case "CUBICSPLINE":
      if (u > h) {
        const f = (a - h) / (u - h), p = u - h, m = n[3 * l + 1], A = n[3 * l + 2], E = n[3 * c + 0], C = n[3 * c + 1];
        Wv(r, i, { p0: m, outTangent0: A, inTangent1: E, p1: C, tDiff: p, ratio: f });
      }
      break;
    default:
      P.warn(`Interpolation ${s} not supported`)();
      break;
  }
}
const $v = `
#pragma vscode_glsllint_stage: vert
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  // _attr vec4 POSITION;
  _attr vec4 positions;

  #ifdef HAS_NORMALS
    // _attr vec4 NORMAL;
    _attr vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // _attr vec2 TEXCOORD_0;
    _attr vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }
`, Kv = `
#pragma vscode_glsllint_stage: frag
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;
function Yv(t, e) {
  const { id: s, geometry: n, material: r, vertexCount: i, materialOptions: o, modelOptions: a } = e, c = s_(t, r, n.attributes, o);
  P.info(4, "createGLTFModel defines: ", c.defines)();
  const l = [], h = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, u = {
    id: s,
    geometry: n,
    topology: n.topology,
    vertexCount: i,
    modules: [wc],
    vs: Xu(t, $v),
    fs: Xu(t, Kv),
    ...a,
    bindings: { ...c.bindings, ...a.bindings },
    defines: { ...c.defines, ...a.defines },
    parameters: { ...h, ...c.parameters, ...a.parameters },
    uniforms: { ...c.uniforms, ...a.uniforms }
  }, f = new Yt(t, u);
  return new va({ managedResources: l, model: f });
}
function Xu(t, e) {
  return `#version 300 es
${e}`;
}
const Jv = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class qv {
  device;
  options;
  gltf;
  constructor(e, s = {}) {
    this.device = e, this.options = { ...Jv, ...s };
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((n) => this.createScene(n));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new Vv(this.gltf) : null;
  }
  createScene(e) {
    const n = (e.nodes || []).map((i) => this.createNode(i));
    return new Ys({
      id: e.name || e.id,
      children: n
    });
  }
  createNode(e) {
    if (!e._node) {
      const n = (e.children || []).map((i) => this.createNode(i));
      e.mesh && n.push(this.createMesh(e.mesh));
      const r = new Ys({
        id: e.name || e.id,
        children: n
      });
      if (e.matrix)
        r.setMatrix(e.matrix);
      else {
        if (r.matrix.identity(), e.translation && r.matrix.translate(e.translation), e.rotation) {
          const i = new W().fromQuaternion(e.rotation);
          r.matrix.multiplyRight(i);
        }
        e.scale && r.matrix.scale(e.scale);
      }
      e._node = r;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const n = (e.primitives || []).map((i, o) => this.createPrimitive(i, o, e)), r = new Ys({
        id: e.name || e.id,
        children: n
      });
      e._mesh = r;
    }
    return e._mesh;
  }
  createPrimitive(e, s, n) {
    const r = e.name || `${n.name || n.id}-primitive-${s}`, i = Zv(e.mode || 4), o = e.indices ? e.indices.count : this.getVertexCount(e.attributes), a = Yv(this.device, {
      id: r,
      geometry: this.createGeometry(r, e, i),
      material: e.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount: o
    });
    return a.bounds = [
      e.attributes.POSITION.min,
      e.attributes.POSITION.max
    ], a;
  }
  getVertexCount(e) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(e, s, n) {
    const r = {};
    for (const [i, o] of Object.entries(s.attributes)) {
      const { components: a, size: c, value: l } = o;
      r[i] = { size: c ?? a, value: l };
    }
    return new Ks({
      id: e,
      topology: n,
      indices: s.indices.value,
      attributes: r
    });
  }
  createBuffer(e, s) {
    e.bufferView || (e.bufferView = {});
    const { bufferView: n } = e;
    return n.lumaBuffers || (n.lumaBuffers = {}), n.lumaBuffers[s] || (n.lumaBuffers[s] = this.device.createBuffer({
      id: `from-${n.id}`,
      // Draco decoded files have attribute.value
      data: n.data || e.value
    })), n.lumaBuffers[s];
  }
  // TODO - create sampler in WebGL2
  createSampler(e) {
    return e;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return !1;
  }
}
var St;
(function(t) {
  t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(St || (St = {}));
function Zv(t) {
  switch (t) {
    case St.POINTS:
      return "point-list";
    case St.LINES:
      return "line-list";
    case St.LINE_STRIP:
      return "line-strip";
    case St.LINE_LOOP:
      return "line-loop-webgl";
    case St.TRIANGLES:
      return "triangle-list";
    case St.TRIANGLE_STRIP:
      return "triangle-strip";
    case St.TRIANGLE_FAN:
      return "triangle-fan-webgl";
    default:
      throw new Error(t);
  }
}
function Qv(t, e, s) {
  const n = new qv(t, s), r = n.instantiate(e), i = n.createAnimator();
  return { scenes: r, animator: i };
}
function Fe(t, e) {
  if (!t)
    throw new Error(e || "assert failed: gltf");
}
const i_ = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, o_ = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, eB = 1.33, Gu = ["SCALAR", "VEC2", "VEC3", "VEC4"], tB = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
], sB = new Map(tB), nB = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, rB = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, iB = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function a_(t) {
  return Gu[t - 1] || Gu[0];
}
function Li(t) {
  const e = sB.get(t.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function Wc(t, e) {
  const s = iB[t.componentType], n = nB[t.type], r = rB[t.componentType], i = t.count * n, o = t.count * n * r;
  Fe(o >= 0 && o <= e.byteLength);
  const a = o_[t.componentType], c = i_[t.type];
  return { ArrayType: s, length: i, byteLength: o, componentByteSize: a, numberOfComponentsInElement: c };
}
function c_(t) {
  let { images: e, bufferViews: s } = t;
  e = e || [], s = s || [];
  const n = e.map((o) => o.bufferView);
  s = s.filter((o) => !n.includes(o));
  const r = s.reduce((o, a) => o + a.byteLength, 0), i = e.reduce((o, a) => {
    const { width: c, height: l } = a.image;
    return o + c * l;
  }, 0);
  return r + Math.ceil(4 * i * eB);
}
function oB(t, e, s) {
  const n = t.bufferViews[s];
  Fe(n);
  const r = n.buffer, i = e[r];
  Fe(i);
  const o = (n.byteOffset || 0) + i.byteOffset;
  return new Uint8Array(i.arrayBuffer, o, n.byteLength);
}
function aB(t, e, s) {
  const n = typeof s == "number" ? t.accessors?.[s] : s;
  if (!n)
    throw new Error(`No gltf accessor ${JSON.stringify(s)}`);
  const r = t.bufferViews?.[n.bufferView || 0];
  if (!r)
    throw new Error(`No gltf buffer view for accessor ${r}`);
  const { arrayBuffer: i, byteOffset: o } = e[r.buffer], a = (o || 0) + (n.byteOffset || 0) + (r.byteOffset || 0), { ArrayType: c, length: l, componentByteSize: h, numberOfComponentsInElement: u } = Wc(n, r), f = h * u, p = r.byteStride || f;
  if (typeof r.byteStride > "u" || r.byteStride === f)
    return new c(i, a, l);
  const m = new c(l);
  for (let A = 0; A < n.count; A++) {
    const E = new c(i, a + A * p, u);
    m.set(E, A * u);
  }
  return m;
}
function cB() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class _e {
  // internal
  gltf;
  sourceBuffers;
  byteLength;
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    this.gltf = {
      json: e?.json || cB(),
      buffers: e?.buffers || [],
      images: e?.images || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const s = this.getUsedExtensions().find((r) => r === e), n = this.getRequiredExtensions().find((r) => r === e);
    return typeof s == "string" || typeof n == "string";
  }
  getExtension(e) {
    const s = this.getUsedExtensions().find((r) => r === e), n = this.json.extensions || {};
    return s ? n[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((n) => n === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, s) {
    return (e.extensions || {})[s];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, s) {
    if (typeof s == "object")
      return s;
    const n = this.json[e] && this.json[e][s];
    if (!n)
      throw new Error(`glTF file error: Could not find ${e}[${s}]`);
    return n;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const s = e.buffer, n = this.gltf.buffers[s];
    Fe(n);
    const r = (e.byteOffset || 0) + n.byteOffset;
    return new Uint8Array(n.arrayBuffer, r, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const s = this.getAccessor(e);
    return aB(this.gltf.json, this.gltf.buffers, s);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const s = this.getBufferView(e.bufferView), r = this.getBuffer(s.buffer).data, i = s.byteOffset || 0;
    return new Uint8Array(r, i, s.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, s) {
    return this.json[e] = s, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, s) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = s, this;
  }
  addObjectExtension(e, s, n) {
    return e.extensions = e.extensions || {}, e.extensions[s] = n, this.registerUsedExtension(s), this;
  }
  setObjectExtension(e, s, n) {
    const r = e.extensions || {};
    r[s] = n;
  }
  removeObjectExtension(e, s) {
    const n = e?.extensions || {};
    if (n[s]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const r = this.json.extensionsRemoved;
      r.includes(s) || r.push(s);
    }
    delete n[s];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e, s = {}) {
    return Fe(s), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = s, this.registerUsedExtension(e), s;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e, s = {}) {
    return Fe(s), this.addExtension(e, s), this.registerRequiredExtension(e), s;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((s) => s === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((s) => s === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    if (this.json.extensions?.[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const s = this.json.extensionsRemoved;
      s.includes(e) || s.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const { nodeIndices: s } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({ nodes: s }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const { meshIndex: s, matrix: n } = e;
    this.json.nodes = this.json.nodes || [];
    const r = { mesh: s };
    return n && (r.matrix = n), this.json.nodes.push(r), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const { attributes: s, indices: n, material: r, mode: i = 4 } = e, a = {
      primitives: [
        {
          attributes: this._addAttributes(s),
          mode: i
        }
      ]
    };
    if (n) {
      const c = this._addIndices(n);
      a.primitives[0].indices = c;
    }
    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const n = {
      primitives: [
        {
          attributes: this._addAttributes(e),
          mode: 0
          // GL.POINTS
        }
      ]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(n), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, s) {
    const n = ac(e), r = s || n?.mimeType, o = {
      bufferView: this.addBufferView(e),
      mimeType: r
    };
    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e, s = 0, n = this.byteLength) {
    const r = e.byteLength;
    Fe(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const i = {
      buffer: s,
      // Write offset from the start of the binary body
      byteOffset: n,
      byteLength: r
    };
    return this.byteLength += nr(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, s) {
    const n = {
      bufferView: e,
      // @ts-ignore
      type: a_(s.size),
      // @ts-ignore
      componentType: s.componentType,
      // @ts-ignore
      count: s.count,
      // @ts-ignore
      max: s.max,
      // @ts-ignore
      min: s.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(n), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e, s = { size: 3 }) {
    const n = this.addBufferView(e);
    let r = { min: s.min, max: s.max };
    (!r.min || !r.max) && (r = this._getAccessorMinMax(e, s.size));
    const i = {
      // @ts-ignore
      size: s.size,
      componentType: Li(e),
      // @ts-ignore
      count: Math.round(e.length / s.size),
      min: r.min,
      max: r.max
    };
    return this.addAccessor(n, Object.assign(i, s));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const { imageIndex: s } = e, n = {
      source: s
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(n), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    const e = this.byteLength, s = new ArrayBuffer(e), n = new Uint8Array(s);
    let r = 0;
    for (const i of this.sourceBuffers || [])
      r = Sm(i, n, r);
    this.json?.buffers?.[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{ byteLength: e }], this.gltf.binary = s, this.sourceBuffers = [s], this.gltf.buffers = [{ arrayBuffer: s, byteOffset: 0, byteLength: s.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(e, s) {
    let n = !0;
    for (; n; ) {
      const r = e.indexOf(s);
      r > -1 ? e.splice(r, 1) : n = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(e = {}) {
    const s = {};
    for (const n in e) {
      const r = e[n], i = this._getGltfAttributeName(n), o = this.addBinaryBuffer(r.value, r);
      s[i] = o;
    }
    return s;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, s) {
    const n = { min: null, max: null };
    if (e.length < s)
      return n;
    n.min = [], n.max = [];
    const r = e.subarray(0, s);
    for (const i of r)
      n.min.push(i), n.max.push(i);
    for (let i = s; i < e.length; i += s)
      for (let o = 0; o < s; o++)
        n.min[0 + o] = Math.min(
          // @ts-ignore
          n.min[0 + o],
          e[i + o]
        ), n.max[0 + o] = Math.max(
          // @ts-ignore
          n.max[0 + o],
          e[i + o]
        );
    return n;
  }
}
function $u(t) {
  return (t % 1 + 1) % 1;
}
const l_ = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, lB = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, h_ = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function Xc(t, e) {
  return h_[e] * l_[t];
}
function ki(t, e, s, n) {
  if (s !== "UINT8" && s !== "UINT16" && s !== "UINT32" && s !== "UINT64")
    return null;
  const r = t.getTypedArrayForBufferView(e), i = Vi(
    r,
    "SCALAR",
    // offsets consist of ONE component
    s,
    n + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;
}
function Vi(t, e, s, n = 1) {
  const r = l_[e], i = lB[s], o = h_[s], a = n * r, c = a * o;
  let l = t.buffer, h = t.byteOffset;
  return h % o !== 0 && (l = new Uint8Array(l).slice(h, h + c).buffer, h = 0), new i(l, h, a);
}
function Gc(t, e, s) {
  const n = `TEXCOORD_${e.texCoord || 0}`, r = s.attributes[n], i = t.getTypedArrayForAccessor(r), o = t.gltf.json, a = e.index, c = o.textures?.[a]?.source;
  if (typeof c < "u") {
    const l = o.images?.[c]?.mimeType, h = t.gltf.images?.[c];
    if (h && typeof h.width < "u") {
      const u = [];
      for (let f = 0; f < i.length; f += 2) {
        const p = hB(h, l, i, f, e.channels);
        u.push(p);
      }
      return u;
    }
  }
  return [];
}
function u_(t, e, s, n, r) {
  if (!s?.length)
    return;
  const i = [];
  for (const h of s) {
    let u = n.findIndex((f) => f === h);
    u === -1 && (u = n.push(h) - 1), i.push(u);
  }
  const o = new Uint32Array(i), a = t.gltf.buffers.push({
    arrayBuffer: o.buffer,
    byteOffset: o.byteOffset,
    byteLength: o.byteLength
  }) - 1, c = t.addBufferView(o, a, 0), l = t.addAccessor(c, {
    size: 1,
    componentType: Li(o),
    count: o.length
  });
  r.attributes[e] = l;
}
function hB(t, e, s, n, r = [0]) {
  const i = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  }, o = s[n], a = s[n + 1];
  let c = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (c = 4);
  const l = uB(o, a, t, c);
  let h = 0;
  for (const u of r) {
    const f = typeof u == "number" ? Object.values(i)[u] : i[u], p = l + f.offset, m = ld(t);
    if (m.data.length <= p)
      throw new Error(`${m.data.length} <= ${p}`);
    const A = m.data[p];
    h |= A << f.shift;
  }
  return h;
}
function uB(t, e, s, n = 1) {
  const r = s.width, i = $u(t) * (r - 1), o = Math.round(i), a = s.height, c = $u(e) * (a - 1), l = Math.round(c), h = s.components ? s.components : n;
  return (l * r + o) * h;
}
function f_(t, e, s, n, r) {
  const i = [];
  for (let o = 0; o < e; o++) {
    const a = s[o], c = s[o + 1] - s[o];
    if (c + a > n)
      break;
    const l = a / r, h = c / r;
    i.push(t.slice(l, l + h));
  }
  return i;
}
function d_(t, e, s) {
  const n = [];
  for (let r = 0; r < e; r++) {
    const i = r * s;
    n.push(t.slice(i, i + s));
  }
  return n;
}
function p_(t, e, s, n) {
  if (s)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (n) {
    const r = [], i = new TextDecoder("utf8");
    let o = 0;
    for (let a = 0; a < t; a++) {
      const c = n[a + 1] - n[a];
      if (c + o <= e.length) {
        const l = e.subarray(o, c + o), h = i.decode(l);
        r.push(h), o += c;
      }
    }
    return r;
  }
  return [];
}
const qs = "EXT_mesh_features", fB = qs;
async function dB(t, e) {
  const s = new _e(t);
  _B(s, e);
}
function pB(t, e) {
  const s = new _e(t);
  return mB(s), s.createBinaryChunk(), s.gltf;
}
function _B(t, e) {
  const s = t.gltf.json;
  if (s.meshes)
    for (const n of s.meshes)
      for (const r of n.primitives)
        gB(t, r, e);
}
function gB(t, e, s) {
  if (!s?.gltf?.loadBuffers)
    return;
  const r = e.extensions?.[qs]?.featureIds;
  if (r)
    for (const i of r) {
      let o;
      if (typeof i.attribute < "u") {
        const a = `_FEATURE_ID_${i.attribute}`, c = e.attributes[a];
        o = t.getTypedArrayForAccessor(c);
      } else typeof i.texture < "u" && s?.gltf?.loadImages ? o = Gc(t, i.texture, e) : o = [];
      i.data = o;
    }
}
function mB(t, e) {
  const s = t.gltf.json.meshes;
  if (s)
    for (const n of s)
      for (const r of n.primitives)
        TB(t, r);
}
function AB(t, e, s, n) {
  e.extensions || (e.extensions = {});
  let r = e.extensions[qs];
  r || (r = { featureIds: [] }, e.extensions[qs] = r);
  const { featureIds: i } = r, o = {
    featureCount: s.length,
    propertyTable: n,
    data: s
  };
  i.push(o), t.addObjectExtension(e, qs, r);
}
function TB(t, e) {
  const s = e.extensions?.[qs];
  if (!s)
    return;
  const n = s.featureIds;
  n.forEach((r, i) => {
    if (r.data) {
      const { accessorKey: o, index: a } = yB(e.attributes), c = new Uint32Array(r.data);
      n[i] = {
        featureCount: c.length,
        propertyTable: r.propertyTable,
        attribute: a
      }, t.gltf.buffers.push({
        arrayBuffer: c.buffer,
        byteOffset: c.byteOffset,
        byteLength: c.byteLength
      });
      const l = t.addBufferView(c), h = t.addAccessor(l, {
        size: 1,
        componentType: Li(c),
        count: c.length
      });
      e.attributes[o] = h;
    }
  });
}
function yB(t) {
  const e = "_FEATURE_ID_", s = Object.keys(t).filter((i) => i.indexOf(e) === 0);
  let n = -1;
  for (const i of s) {
    const o = Number(i.substring(e.length));
    o > n && (n = o);
  }
  return n++, { accessorKey: `${e}${n}`, index: n };
}
const bB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: AB,
  decode: dB,
  encode: pB,
  name: fB
}, Symbol.toStringTag, { value: "Module" })), rn = "EXT_structural_metadata", EB = rn;
async function CB(t, e) {
  const s = new _e(t);
  RB(s, e);
}
function SB(t, e) {
  const s = new _e(t);
  return HB(s), s.createBinaryChunk(), s.gltf;
}
function RB(t, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const s = t.getExtension(rn);
  s && (e.gltf?.loadImages && wB(t, s), IB(t, s));
}
function wB(t, e) {
  const s = e.propertyTextures, n = t.gltf.json;
  if (s && n.meshes)
    for (const r of n.meshes)
      for (const i of r.primitives)
        BB(t, s, i, e);
}
function IB(t, e) {
  const s = e.schema;
  if (!s)
    return;
  const n = s.classes, r = e.propertyTables;
  if (n && r)
    for (const i in n) {
      const o = vB(r, i);
      o && PB(t, s, o);
    }
}
function vB(t, e) {
  for (const s of t)
    if (s.class === e)
      return s;
  return null;
}
function BB(t, e, s, n) {
  if (!e)
    return;
  const i = s.extensions?.[rn]?.propertyTextures;
  if (i)
    for (const o of i) {
      const a = e[o];
      MB(t, a, s, n);
    }
}
function MB(t, e, s, n) {
  if (!e.properties)
    return;
  n.dataAttributeNames || (n.dataAttributeNames = []);
  const r = e.class;
  for (const i in e.properties) {
    const o = `${r}_${i}`, a = e.properties?.[i];
    if (!a)
      continue;
    a.data || (a.data = []);
    const c = a.data, l = Gc(t, a, s);
    l !== null && (u_(t, o, l, c, s), a.data = c, n.dataAttributeNames.push(o));
  }
}
function PB(t, e, s) {
  const n = e.classes?.[s.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${s.class}`);
  const r = s.count;
  for (const i in n.properties) {
    const o = n.properties[i], a = s.properties?.[i];
    if (a) {
      const c = OB(t, e, o, r, a);
      a.data = c;
    }
  }
}
function OB(t, e, s, n, r) {
  let i = [];
  const o = r.values, a = t.getTypedArrayForBufferView(o), c = xB(t, s, r, n), l = NB(t, r, n);
  switch (s.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      i = FB(s, n, a, c);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${s.type}`);
    case "STRING": {
      i = p_(n, a, c, l);
      break;
    }
    case "ENUM": {
      i = DB(e, s, n, a, c);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${s.type}`);
  }
  return i;
}
function xB(t, e, s, n) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof s.arrayOffsets < "u" ? ki(t, s.arrayOffsets, s.arrayOffsetType || "UINT32", n) : null;
}
function NB(t, e, s) {
  return typeof e.stringOffsets < "u" ? ki(t, e.stringOffsets, e.stringOffsetType || "UINT32", s) : null;
}
function FB(t, e, s, n) {
  const r = t.array, i = t.count, o = Xc(t.type, t.componentType), a = s.byteLength / o;
  let c;
  return t.componentType ? c = Vi(
    s,
    t.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    t.componentType,
    a
  ) : c = s, r ? n ? f_(c, e, n, s.length, o) : i ? d_(c, e, i) : [] : c;
}
function DB(t, e, s, n, r) {
  const i = e.enumType;
  if (!i)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const o = t.enums?.[i];
  if (!o)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${i}`);
  const a = o.valueType || "UINT16", c = Xc(e.type, a), l = n.byteLength / c;
  let h = Vi(n, e.type, a, l);
  if (h || (h = n), e.array) {
    if (r)
      return UB({
        valuesData: h,
        numberOfElements: s,
        arrayOffsets: r,
        valuesDataBytesLength: n.length,
        elementSize: c,
        enumEntry: o
      });
    const u = e.count;
    return u ? LB(h, s, u, o) : [];
  }
  return $c(h, 0, s, o);
}
function UB(t) {
  const { valuesData: e, numberOfElements: s, arrayOffsets: n, valuesDataBytesLength: r, elementSize: i, enumEntry: o } = t, a = [];
  for (let c = 0; c < s; c++) {
    const l = n[c], h = n[c + 1] - n[c];
    if (h + l > r)
      break;
    const u = l / i, f = h / i, p = $c(e, u, f, o);
    a.push(p);
  }
  return a;
}
function LB(t, e, s, n) {
  const r = [];
  for (let i = 0; i < e; i++) {
    const o = s * i, a = $c(t, o, s, n);
    r.push(a);
  }
  return r;
}
function $c(t, e, s, n) {
  const r = [];
  for (let i = 0; i < s; i++)
    if (t instanceof BigInt64Array || t instanceof BigUint64Array)
      r.push("");
    else {
      const o = t[e + i], a = kB(n, o);
      a ? r.push(a.name) : r.push("");
    }
  return r;
}
function kB(t, e) {
  for (const s of t.values)
    if (s.value === e)
      return s;
  return null;
}
const VB = "schemaClassId";
function HB(t, e) {
  const s = t.getExtension(rn);
  if (s && s.propertyTables)
    for (const n of s.propertyTables) {
      const r = n.class, i = s.schema?.classes?.[r];
      n.properties && i && zB(n, i, t);
    }
}
function zB(t, e, s) {
  for (const n in t.properties) {
    const r = t.properties[n].data;
    if (r) {
      const i = e.properties[n];
      if (i) {
        const o = GB(r, i, s);
        t.properties[n] = o;
      }
    }
  }
}
function jB(t, e, s = VB) {
  let n = t.getExtension(rn);
  n || (n = t.addExtension(rn)), n.schema = WB(e, s, n.schema);
  const r = XB(e, s, n.schema);
  return n.propertyTables || (n.propertyTables = []), n.propertyTables.push(r) - 1;
}
function WB(t, e, s) {
  const n = s ?? {
    id: "schema_id"
  }, r = {
    properties: {}
  };
  for (const i of t) {
    const o = {
      type: i.elementType,
      componentType: i.componentType
    };
    r.properties[i.name] = o;
  }
  return n.classes = {}, n.classes[e] = r, n;
}
function XB(t, e, s) {
  const n = {
    class: e,
    count: 0
  };
  let r = 0;
  const i = s.classes?.[e];
  for (const o of t) {
    if (r === 0 && (r = o.values.length), r !== o.values.length && o.values.length)
      throw new Error("Illegal values in attributes");
    i?.properties[o.name] && (n.properties || (n.properties = {}), n.properties[o.name] = { values: 0, data: o.values });
  }
  return n.count = r, n;
}
function GB(t, e, s) {
  const n = { values: 0 };
  if (e.type === "STRING") {
    const { stringData: r, stringOffsets: i } = YB(t);
    n.stringOffsets = Ho(i, s), n.values = Ho(r, s);
  } else if (e.type === "SCALAR" && e.componentType) {
    const r = KB(t, e.componentType);
    n.values = Ho(r, s);
  }
  return n;
}
const $B = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function KB(t, e) {
  const s = [];
  for (const r of t)
    s.push(Number(r));
  const n = $B[e];
  if (!n)
    throw new Error("Illegal component type");
  return new n(s);
}
function YB(t) {
  const e = new TextEncoder(), s = [];
  let n = 0;
  for (const c of t) {
    const l = e.encode(c);
    n += l.length, s.push(l);
  }
  const r = new Uint8Array(n), i = [];
  let o = 0;
  for (const c of s)
    r.set(c, o), i.push(o), o += c.length;
  i.push(o);
  const a = new Uint32Array(i);
  return { stringData: r, stringOffsets: a };
}
function Ho(t, e) {
  return e.gltf.buffers.push({
    arrayBuffer: t.buffer,
    byteOffset: t.byteOffset,
    byteLength: t.byteLength
  }), e.addBufferView(t);
}
const JB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: jB,
  decode: CB,
  encode: SB,
  name: EB
}, Symbol.toStringTag, { value: "Module" })), __ = "EXT_feature_metadata", qB = __;
async function ZB(t, e) {
  const s = new _e(t);
  QB(s, e);
}
function QB(t, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const s = t.getExtension(__);
  s && (e.gltf?.loadImages && eM(t, s), tM(t, s));
}
function eM(t, e) {
  const s = e.schema;
  if (!s)
    return;
  const n = s.classes, { featureTextures: r } = e;
  if (n && r)
    for (const i in n) {
      const o = n[i], a = nM(r, i);
      a && iM(t, a, o);
    }
}
function tM(t, e) {
  const s = e.schema;
  if (!s)
    return;
  const n = s.classes, r = e.featureTables;
  if (n && r)
    for (const i in n) {
      const o = sM(r, i);
      o && rM(t, s, o);
    }
}
function sM(t, e) {
  for (const s in t) {
    const n = t[s];
    if (n.class === e)
      return n;
  }
  return null;
}
function nM(t, e) {
  for (const s in t) {
    const n = t[s];
    if (n.class === e)
      return n;
  }
  return null;
}
function rM(t, e, s) {
  if (!s.class)
    return;
  const n = e.classes?.[s.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${s.class}`);
  const r = s.count;
  for (const i in n.properties) {
    const o = n.properties[i], a = s.properties?.[i];
    if (a) {
      const c = oM(t, e, o, r, a);
      a.data = c;
    }
  }
}
function iM(t, e, s) {
  const n = e.class;
  for (const r in s.properties) {
    const i = e?.properties?.[r];
    if (i) {
      const o = uM(t, i, n);
      i.data = o;
    }
  }
}
function oM(t, e, s, n, r) {
  let i = [];
  const o = r.bufferView, a = t.getTypedArrayForBufferView(o), c = aM(t, s, r, n), l = cM(t, s, r, n);
  return s.type === "STRING" || s.componentType === "STRING" ? i = p_(n, a, c, l) : lM(s) && (i = hM(s, n, a, c)), i;
}
function aM(t, e, s, n) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof s.arrayOffsetBufferView < "u" ? ki(
    t,
    s.arrayOffsetBufferView,
    s.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function cM(t, e, s, n) {
  return typeof s.stringOffsetBufferView < "u" ? ki(
    t,
    s.stringOffsetBufferView,
    s.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function lM(t) {
  const e = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return e.includes(t.type) || typeof t.componentType < "u" && e.includes(t.componentType);
}
function hM(t, e, s, n) {
  const r = t.type === "ARRAY", i = t.componentCount, o = "SCALAR", a = t.componentType || t.type, c = Xc(o, a), l = s.byteLength / c, h = Vi(s, o, a, l);
  return r ? n ? f_(h, e, n, s.length, c) : i ? d_(h, e, i) : [] : h;
}
function uM(t, e, s) {
  const n = t.gltf.json;
  if (!n.meshes)
    return [];
  const r = [];
  for (const i of n.meshes)
    for (const o of i.primitives)
      fM(t, s, e, r, o);
  return r;
}
function fM(t, e, s, n, r) {
  const i = {
    channels: s.channels,
    ...s.texture
  }, o = Gc(t, i, r);
  o && u_(t, e, o, n, r);
}
const dM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: ZB,
  name: qB
}, Symbol.toStringTag, { value: "Module" })), pM = "4.3.1", on = !0, Ku = 1735152710, Kc = 12, Ei = 8, _M = 1313821514, gM = 5130562, mM = 0, AM = 0, TM = 1;
function yM(t, e = 0) {
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
function bM(t, e = 0, s = {}) {
  const n = new DataView(t), { magic: r = Ku } = s, i = n.getUint32(e, !1);
  return i === r || i === Ku;
}
function EM(t, e, s = 0, n = {}) {
  const r = new DataView(e), i = yM(r, s + 0), o = r.getUint32(s + 4, on), a = r.getUint32(s + 8, on);
  switch (Object.assign(t, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: s,
      // Byte offset into the initial arrayBuffer
      byteLength: a,
      hasBinChunk: !1
    },
    type: i,
    version: o,
    json: {},
    binChunks: []
  }), s += Kc, t.version) {
    case 1:
      return CM(t, r, s);
    case 2:
      return SM(t, r, s, n = {});
    default:
      throw new Error(`Invalid GLB version ${t.version}. Only supports version 1 and 2.`);
  }
}
function CM(t, e, s) {
  se(t.header.byteLength > Kc + Ei);
  const n = e.getUint32(s + 0, on), r = e.getUint32(s + 4, on);
  return s += Ei, se(r === mM), ja(t, e, s, n), s += n, s += Wa(t, e, s, t.header.byteLength), s;
}
function SM(t, e, s, n) {
  return se(t.header.byteLength > Kc + Ei), RM(t, e, s, n), s + t.header.byteLength;
}
function RM(t, e, s, n) {
  for (; s + 8 <= t.header.byteLength; ) {
    const r = e.getUint32(s + 0, on), i = e.getUint32(s + 4, on);
    switch (s += Ei, i) {
      case _M:
        ja(t, e, s, r);
        break;
      case gM:
        Wa(t, e, s, r);
        break;
      // Backward compatibility for very old xviz files
      case AM:
        n.strict || ja(t, e, s, r);
        break;
      case TM:
        n.strict || Wa(t, e, s, r);
        break;
    }
    s += nr(r, 4);
  }
  return s;
}
function ja(t, e, s, n) {
  const r = new Uint8Array(e.buffer, s, n), o = new TextDecoder("utf8").decode(r);
  return t.json = JSON.parse(o), nr(n, 4);
}
function Wa(t, e, s, n) {
  return t.header.hasBinChunk = !0, t.binChunks.push({
    byteOffset: s,
    byteLength: n,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), nr(n, 4);
}
function g_(t, e) {
  if (t.startsWith("data:") || t.startsWith("http:") || t.startsWith("https:"))
    return t;
  const n = e.baseUri || e.uri;
  if (!n)
    throw new Error(`'baseUri' must be provided to resolve relative url ${t}`);
  return n.substr(0, n.lastIndexOf("/") + 1) + t;
}
const wM = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", IM = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", vM = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]), BM = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]), MM = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, PM = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function OM(t, e, s, n, r, i = "NONE") {
  const o = await xM();
  DM(o, o.exports[PM[r]], t, e, s, n, o.exports[MM[i || "NONE"]]);
}
let zo;
async function xM() {
  return zo || (zo = NM()), zo;
}
async function NM() {
  let t = wM;
  WebAssembly.validate(vM) && (t = IM, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(FM(t), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function FM(t) {
  const e = new Uint8Array(t.length);
  for (let n = 0; n < t.length; ++n) {
    const r = t.charCodeAt(n);
    e[n] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;
  }
  let s = 0;
  for (let n = 0; n < t.length; ++n)
    e[s++] = e[n] < 60 ? BM[e[n]] : (e[n] - 60) * 64 + e[++n];
  return e.buffer.slice(0, s);
}
function DM(t, e, s, n, r, i, o) {
  const a = t.exports.sbrk, c = n + 3 & -4, l = a(c * r), h = a(i.length), u = new Uint8Array(t.exports.memory.buffer);
  u.set(i, h);
  const f = e(l, n, r, h, i.length);
  if (f === 0 && o && o(l, c, r), s.set(u.subarray(l, l + n * r)), a(l - a(0)), f !== 0)
    throw new Error(`Malformed buffer data: ${f}`);
}
const Ci = "EXT_meshopt_compression", UM = Ci;
async function LM(t, e) {
  const s = new _e(t);
  if (!e?.gltf?.decompressMeshes || !e.gltf?.loadBuffers)
    return;
  const n = [];
  for (const r of t.json.bufferViews || [])
    n.push(kM(s, r));
  await Promise.all(n), s.removeExtension(Ci);
}
async function kM(t, e) {
  const s = t.getObjectExtension(e, Ci);
  if (s) {
    const { byteOffset: n = 0, byteLength: r = 0, byteStride: i, count: o, mode: a, filter: c = "NONE", buffer: l } = s, h = t.gltf.buffers[l], u = new Uint8Array(h.arrayBuffer, h.byteOffset + n, r), f = new Uint8Array(t.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await OM(f, o, i, u, a, c), t.removeObjectExtension(e, Ci);
  }
}
const VM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: LM,
  name: UM
}, Symbol.toStringTag, { value: "Module" })), Ds = "EXT_texture_webp", HM = Ds;
function zM(t, e) {
  const s = new _e(t);
  if (!TT("image/webp")) {
    if (s.getRequiredExtensions().includes(Ds))
      throw new Error(`gltf: Required extension ${Ds} not supported by browser`);
    return;
  }
  const { json: n } = s;
  for (const r of n.textures || []) {
    const i = s.getObjectExtension(r, Ds);
    i && (r.source = i.source), s.removeObjectExtension(r, Ds);
  }
  s.removeExtension(Ds);
}
const jM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: HM,
  preprocess: zM
}, Symbol.toStringTag, { value: "Module" })), ni = "KHR_texture_basisu", WM = ni;
function XM(t, e) {
  const s = new _e(t), { json: n } = s;
  for (const r of n.textures || []) {
    const i = s.getObjectExtension(r, ni);
    i && (r.source = i.source, s.removeObjectExtension(r, ni));
  }
  s.removeExtension(ni);
}
const GM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: WM,
  preprocess: XM
}, Symbol.toStringTag, { value: "Module" })), $M = "4.3.1", KM = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: $M,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function YM(t, e, s) {
  const n = m_(e.metadata), r = [], i = JM(e.attributes);
  for (const o in t) {
    const a = t[o], c = Yu(o, a, i[o]);
    r.push(c);
  }
  if (s) {
    const o = Yu("indices", s);
    r.push(o);
  }
  return { fields: r, metadata: n };
}
function JM(t) {
  const e = {};
  for (const s in t) {
    const n = t[s];
    e[n.name || "undefined"] = n;
  }
  return e;
}
function Yu(t, e, s) {
  const n = s ? m_(s.metadata) : void 0;
  return kA(t, e, n);
}
function m_(t) {
  Object.entries(t);
  const e = {};
  for (const s in t)
    e[`${s}.string`] = JSON.stringify(t[s]);
  return e;
}
const Ju = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, qM = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, ZM = 4;
class QM {
  draco;
  decoder;
  metadataQuerier;
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e, s = {}) {
    const n = new this.draco.DecoderBuffer();
    n.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(s);
    const r = this.decoder.GetEncodedGeometryType(n), i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let o;
      switch (r) {
        case this.draco.TRIANGULAR_MESH:
          o = this.decoder.DecodeBufferToMesh(n, i);
          break;
        case this.draco.POINT_CLOUD:
          o = this.decoder.DecodeBufferToPointCloud(n, i);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!o.ok() || !i.ptr) {
        const f = `DRACO decompression failed: ${o.error_msg()}`;
        throw new Error(f);
      }
      const a = this._getDracoLoaderData(i, r, s), c = this._getMeshData(i, a, s), l = cd(c.attributes), h = YM(c.attributes, a, c.indices);
      return {
        loader: "draco",
        loaderData: a,
        header: {
          vertexCount: i.num_points(),
          boundingBox: l
        },
        ...c,
        schema: h
      };
    } finally {
      this.draco.destroy(n), i && this.draco.destroy(i);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, s, n) {
    const r = this._getTopLevelMetadata(e), i = this._getDracoAttributes(e, n);
    return {
      geometry_type: s,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: r,
      attributes: i
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, s) {
    const n = {};
    for (let r = 0; r < e.num_attributes(); r++) {
      const i = this.decoder.GetAttribute(e, r), o = this._getAttributeMetadata(e, r);
      n[i.unique_id()] = {
        unique_id: i.unique_id(),
        attribute_type: i.attribute_type(),
        data_type: i.data_type(),
        num_components: i.num_components(),
        byte_offset: i.byte_offset(),
        byte_stride: i.byte_stride(),
        normalized: i.normalized(),
        attribute_index: r,
        metadata: o
      };
      const a = this._getQuantizationTransform(i, s);
      a && (n[i.unique_id()].quantization_transform = a);
      const c = this._getOctahedronTransform(i, s);
      c && (n[i.unique_id()].octahedron_transform = c);
    }
    return n;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, s, n) {
    const r = this._getMeshAttributes(s, e, n);
    if (!r.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (n.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: r,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: r,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: r
    };
  }
  _getMeshAttributes(e, s, n) {
    const r = {};
    for (const i of Object.values(e.attributes)) {
      const o = this._deduceAttributeName(i, n);
      i.name = o;
      const a = this._getAttributeValues(s, i);
      if (a) {
        const { value: c, size: l } = a;
        r[o] = {
          value: c,
          size: l,
          byteOffset: i.byte_offset,
          byteStride: i.byte_stride,
          normalized: i.normalized
        };
      }
    }
    return r;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const n = e.num_faces() * 3, r = n * ZM, i = this.draco._malloc(r);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, n).slice();
    } finally {
      this.draco._free(i);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const s = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, s), s3(s);
    } finally {
      this.draco.destroy(s);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, s) {
    const n = qM[s.data_type];
    if (!n)
      return console.warn(`DRACO: Unsupported attribute type ${s.data_type}`), null;
    const r = s.num_components, o = e.num_points() * r, a = o * n.BYTES_PER_ELEMENT, c = e3(this.draco, n);
    let l;
    const h = this.draco._malloc(a);
    try {
      const u = this.decoder.GetAttribute(e, s.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, u, c, a, h), l = new n(this.draco.HEAPF32.buffer, h, o).slice();
    } finally {
      this.draco._free(h);
    }
    return { value: l, size: r };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, s) {
    const n = e.unique_id;
    for (const [o, a] of Object.entries(s.extraAttributes || {}))
      if (a === n)
        return o;
    const r = e.attribute_type;
    for (const o in Ju)
      if (this.draco[o] === r)
        return Ju[o];
    const i = s.attributeNameEntry || "name";
    return e.metadata[i] ? e.metadata[i].string : `CUSTOM_ATTRIBUTE_${n}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const s = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(s);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, s) {
    const n = this.decoder.GetAttributeMetadata(e, s);
    return this._getDracoMetadata(n);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const s = {}, n = this.metadataQuerier.NumEntries(e);
    for (let r = 0; r < n; r++) {
      const i = this.metadataQuerier.GetEntryName(e, r);
      s[i] = this._getDracoMetadataField(e, i);
    }
    return s;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, s) {
    const n = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, s, n);
      const r = t3(n);
      return {
        int: this.metadataQuerier.GetIntEntry(e, s),
        string: this.metadataQuerier.GetStringEntry(e, s),
        double: this.metadataQuerier.GetDoubleEntry(e, s),
        intArray: r
      };
    } finally {
      this.draco.destroy(n);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const { quantizedAttributes: s = [], octahedronAttributes: n = [] } = e, r = [...s, ...n];
    for (const i of r)
      this.decoder.SkipAttributeTransform(this.draco[i]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, s) {
    const { quantizedAttributes: n = [] } = s, r = e.attribute_type();
    if (n.map((o) => this.decoder[o]).includes(r)) {
      const o = new this.draco.AttributeQuantizationTransform();
      try {
        if (o.InitFromAttribute(e))
          return {
            quantization_bits: o.quantization_bits(),
            range: o.range(),
            min_values: new Float32Array([1, 2, 3]).map((a) => o.min_value(a))
          };
      } finally {
        this.draco.destroy(o);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, s) {
    const { octahedronAttributes: n = [] } = s, r = e.attribute_type();
    if (n.map((o) => this.decoder[o]).includes(r)) {
      const o = new this.draco.AttributeQuantizationTransform();
      try {
        if (o.InitFromAttribute(e))
          return {
            quantization_bits: o.quantization_bits()
          };
      } finally {
        this.draco.destroy(o);
      }
    }
    return null;
  }
}
function e3(t, e) {
  switch (e) {
    case Float32Array:
      return t.DT_FLOAT32;
    case Int8Array:
      return t.DT_INT8;
    case Int16Array:
      return t.DT_INT16;
    case Int32Array:
      return t.DT_INT32;
    case Uint8Array:
      return t.DT_UINT8;
    case Uint16Array:
      return t.DT_UINT16;
    case Uint32Array:
      return t.DT_UINT32;
    default:
      return t.DT_INVALID;
  }
}
function t3(t) {
  const e = t.size(), s = new Int32Array(e);
  for (let n = 0; n < e; n++)
    s[n] = t.GetValue(n);
  return s;
}
function s3(t) {
  const e = t.size(), s = new Int32Array(e);
  for (let n = 0; n < e; n++)
    s[n] = t.GetValue(n);
  return s;
}
const n3 = "1.5.6", r3 = "1.4.1", jo = `https://www.gstatic.com/draco/versioned/decoders/${n3}`, ve = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, Wo = {
  [ve.DECODER]: `${jo}/${ve.DECODER}`,
  [ve.DECODER_WASM]: `${jo}/${ve.DECODER_WASM}`,
  [ve.FALLBACK_DECODER]: `${jo}/${ve.FALLBACK_DECODER}`,
  [ve.ENCODER]: `https://raw.githubusercontent.com/google/draco/${r3}/javascript/${ve.ENCODER}`
};
let Xo;
async function i3(t) {
  const e = t.modules || {};
  return e.draco3d ? Xo ||= e.draco3d.createDecoderModule({}).then((s) => ({ draco: s })) : Xo ||= o3(t), await Xo;
}
async function o3(t) {
  let e, s;
  switch (t.draco && t.draco.decoderType) {
    case "js":
      e = await ps(Wo[ve.FALLBACK_DECODER], "draco", t, ve.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, s] = await Promise.all([
        await ps(Wo[ve.DECODER], "draco", t, ve.DECODER),
        await ps(Wo[ve.DECODER_WASM], "draco", t, ve.DECODER_WASM)
      ]);
  }
  return e = e || globalThis.DracoDecoderModule, await a3(e, s);
}
function a3(t, e) {
  const s = {};
  return e && (s.wasmBinary = e), new Promise((n) => {
    t({
      ...s,
      onModuleLoaded: (r) => n({ draco: r })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const A_ = {
  ...KM,
  parse: c3
};
async function c3(t, e) {
  const { draco: s } = await i3(e), n = new QM(s);
  try {
    return n.parseSync(t, e?.draco);
  } finally {
    n.destroy();
  }
}
function l3(t) {
  const e = {};
  for (const s in t) {
    const n = t[s];
    if (s !== "indices") {
      const r = T_(n);
      e[s] = r;
    }
  }
  return e;
}
function T_(t) {
  const { buffer: e, size: s, count: n } = h3(t);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: s,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: n,
    type: a_(s),
    componentType: Li(e)
  };
}
function h3(t) {
  let e = t, s = 1, n = 0;
  return t && t.value && (e = t.value, s = t.size || 1), e && (ArrayBuffer.isView(e) || (e = u3(e, Float32Array)), n = e.length / s), { buffer: e, size: s, count: n };
}
function u3(t, e, s = !1) {
  return t ? Array.isArray(t) ? new e(t) : s && !(t instanceof e) ? new e(t) : t : null;
}
const qt = "KHR_draco_mesh_compression", f3 = qt;
function d3(t, e, s) {
  const n = new _e(t);
  for (const r of y_(n))
    n.getObjectExtension(r, qt);
}
async function p3(t, e, s) {
  if (!e?.gltf?.decompressMeshes)
    return;
  const n = new _e(t), r = [];
  for (const i of y_(n))
    n.getObjectExtension(i, qt) && r.push(g3(n, i, e, s));
  await Promise.all(r), n.removeExtension(qt);
}
function _3(t, e = {}) {
  const s = new _e(t);
  for (const n of s.json.meshes || [])
    m3(n), s.addRequiredExtension(qt);
}
async function g3(t, e, s, n) {
  const r = t.getObjectExtension(e, qt);
  if (!r)
    return;
  const i = t.getTypedArrayForBufferView(r.bufferView), o = ec(i.buffer, i.byteOffset), a = { ...s };
  delete a["3d-tiles"];
  const c = await sr(o, A_, a, n), l = l3(c.attributes);
  for (const [h, u] of Object.entries(l))
    if (h in e.attributes) {
      const f = e.attributes[h], p = t.getAccessor(f);
      p?.min && p?.max && (u.min = p.min, u.max = p.max);
    }
  e.attributes = l, c.indices && (e.indices = T_(c.indices)), t.removeObjectExtension(e, qt), A3(e);
}
function m3(t, e, s = 4, n, r) {
  if (!n.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const i = n.DracoWriter.encodeSync({ attributes: t }), o = r?.parseSync?.({ attributes: t }), a = n._addFauxAttributes(o.attributes), c = n.addBufferView(i);
  return {
    primitives: [
      {
        attributes: a,
        // TODO - verify with spec
        mode: s,
        // GL.POINTS
        extensions: {
          [qt]: {
            bufferView: c,
            attributes: a
            // TODO - verify with spec
          }
        }
      }
    ]
  };
}
function A3(t) {
  if (!t.attributes && Object.keys(t.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* y_(t) {
  for (const e of t.json.meshes || [])
    for (const s of e.primitives)
      yield s;
}
const T3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: p3,
  encode: _3,
  name: f3,
  preprocess: d3
}, Symbol.toStringTag, { value: "Module" })), Hi = "KHR_texture_transform", y3 = Hi, Xr = new S(), b3 = new ae(), E3 = new ae();
async function C3(t, e) {
  if (!new _e(t).hasExtension(Hi) || !e.gltf?.loadBuffers)
    return;
  const r = t.json.materials || [];
  for (let i = 0; i < r.length; i++)
    S3(i, t);
}
function S3(t, e) {
  const s = e.json.materials?.[t], n = [
    s?.pbrMetallicRoughness?.baseColorTexture,
    s?.emissiveTexture,
    s?.normalTexture,
    s?.occlusionTexture,
    s?.pbrMetallicRoughness?.metallicRoughnessTexture
  ], r = [];
  for (const i of n)
    i && i?.extensions?.[Hi] && R3(e, t, i, r);
}
function R3(t, e, s, n) {
  const r = w3(s, n);
  if (!r)
    return;
  const i = t.json.meshes || [];
  for (const o of i)
    for (const a of o.primitives) {
      const c = a.material;
      Number.isFinite(c) && e === c && I3(t, a, r);
    }
}
function w3(t, e) {
  const s = t.extensions?.[Hi], { texCoord: n = 0 } = t, { texCoord: r = n } = s;
  if (!(e.findIndex(([o, a]) => o === n && a === r) !== -1)) {
    const o = M3(s);
    return n !== r && (t.texCoord = r), e.push([n, r]), { originalTexCoord: n, texCoord: r, matrix: o };
  }
  return null;
}
function I3(t, e, s) {
  const { originalTexCoord: n, texCoord: r, matrix: i } = s, o = e.attributes[`TEXCOORD_${n}`];
  if (Number.isFinite(o)) {
    const a = t.json.accessors?.[o];
    if (a && a.bufferView) {
      const c = t.json.bufferViews?.[a.bufferView];
      if (c) {
        const { arrayBuffer: l, byteOffset: h } = t.buffers[c.buffer], u = (h || 0) + (a.byteOffset || 0) + (c.byteOffset || 0), { ArrayType: f, length: p } = Wc(a, c), m = o_[a.componentType], A = i_[a.type], E = c.byteStride || m * A, C = new Float32Array(p);
        for (let w = 0; w < a.count; w++) {
          const I = new f(l, u + w * E, 2);
          Xr.set(I[0], I[1], 1), Xr.transformByMatrix3(i), C.set([Xr[0], Xr[1]], w * A);
        }
        n === r ? v3(a, c, t.buffers, C) : B3(r, a, e, t, C);
      }
    }
  }
}
function v3(t, e, s, n) {
  t.componentType = 5126, s.push({
    arrayBuffer: n.buffer,
    byteOffset: 0,
    byteLength: n.buffer.byteLength
  }), e.buffer = s.length - 1, e.byteLength = n.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function B3(t, e, s, n, r) {
  n.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: 0,
    byteLength: r.buffer.byteLength
  });
  const i = n.json.bufferViews;
  if (!i)
    return;
  i.push({
    buffer: n.buffers.length - 1,
    byteLength: r.buffer.byteLength,
    byteOffset: 0
  });
  const o = n.json.accessors;
  o && (o.push({
    bufferView: i?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), s.attributes[`TEXCOORD_${t}`] = o.length - 1);
}
function M3(t) {
  const { offset: e = [0, 0], rotation: s = 0, scale: n = [1, 1] } = t, r = new ae().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), i = b3.set(Math.cos(s), Math.sin(s), 0, -Math.sin(s), Math.cos(s), 0, 0, 0, 1), o = E3.set(n[0], 0, 0, 0, n[1], 0, 0, 0, 1);
  return r.multiplyRight(i).multiplyRight(o);
}
const P3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: C3,
  name: y3
}, Symbol.toStringTag, { value: "Module" })), ds = "KHR_lights_punctual", O3 = ds;
async function x3(t) {
  const e = new _e(t), { json: s } = e, n = e.getExtension(ds);
  n && (e.json.lights = n.lights, e.removeExtension(ds));
  for (const r of s.nodes || []) {
    const i = e.getObjectExtension(r, ds);
    i && (r.light = i.light), e.removeObjectExtension(r, ds);
  }
}
async function N3(t) {
  const e = new _e(t), { json: s } = e;
  if (s.lights) {
    const n = e.addExtension(ds);
    Fe(!n.lights), n.lights = s.lights, delete s.lights;
  }
  if (e.json.lights) {
    for (const n of e.json.lights) {
      const r = n.node;
      e.addObjectExtension(r, ds, n);
    }
    delete e.json.lights;
  }
}
const F3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: x3,
  encode: N3,
  name: O3
}, Symbol.toStringTag, { value: "Module" })), Qn = "KHR_materials_unlit", D3 = Qn;
async function U3(t) {
  const e = new _e(t), { json: s } = e;
  for (const n of s.materials || [])
    n.extensions && n.extensions.KHR_materials_unlit && (n.unlit = !0), e.removeObjectExtension(n, Qn);
  e.removeExtension(Qn);
}
function L3(t) {
  const e = new _e(t), { json: s } = e;
  if (e.materials)
    for (const n of s.materials || [])
      n.unlit && (delete n.unlit, e.addObjectExtension(n, Qn, {}), e.addExtension(Qn));
}
const k3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: U3,
  encode: L3,
  name: D3
}, Symbol.toStringTag, { value: "Module" })), Un = "KHR_techniques_webgl", V3 = Un;
async function H3(t) {
  const e = new _e(t), { json: s } = e, n = e.getExtension(Un);
  if (n) {
    const r = j3(n, e);
    for (const i of s.materials || []) {
      const o = e.getObjectExtension(i, Un);
      o && (i.technique = Object.assign(
        {},
        o,
        // @ts-ignore
        r[o.technique]
      ), i.technique.values = W3(i.technique, e)), e.removeObjectExtension(i, Un);
    }
    e.removeExtension(Un);
  }
}
async function z3(t, e) {
}
function j3(t, e) {
  const { programs: s = [], shaders: n = [], techniques: r = [] } = t, i = new TextDecoder();
  return n.forEach((o) => {
    if (Number.isFinite(o.bufferView))
      o.code = i.decode(e.getTypedArrayForBufferView(o.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), s.forEach((o) => {
    o.fragmentShader = n[o.fragmentShader], o.vertexShader = n[o.vertexShader];
  }), r.forEach((o) => {
    o.program = s[o.program];
  }), r;
}
function W3(t, e) {
  const s = Object.assign({}, t.values);
  return Object.keys(t.uniforms || {}).forEach((n) => {
    t.uniforms[n].value && !(n in s) && (s[n] = t.uniforms[n].value);
  }), Object.keys(s).forEach((n) => {
    typeof s[n] == "object" && s[n].index !== void 0 && (s[n].texture = e.getTexture(s[n].index));
  }), s;
}
const X3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: H3,
  encode: z3,
  name: V3
}, Symbol.toStringTag, { value: "Module" })), b_ = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  JB,
  bB,
  VM,
  jM,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  GM,
  T3,
  F3,
  k3,
  X3,
  P3,
  dM
];
function G3(t, e = {}, s) {
  const n = b_.filter((r) => E_(r.name, e));
  for (const r of n)
    r.preprocess?.(t, e, s);
}
async function $3(t, e = {}, s) {
  const n = b_.filter((r) => E_(r.name, e));
  for (const r of n)
    await r.decode?.(t, e, s);
}
function E_(t, e) {
  const s = e?.gltf?.excludeExtensions || {};
  return !(t in s && !s[t]);
}
const Go = "KHR_binary_glTF";
function K3(t) {
  const e = new _e(t), { json: s } = e;
  for (const n of s.images || []) {
    const r = e.getObjectExtension(n, Go);
    r && Object.assign(n, r), e.removeObjectExtension(n, Go);
  }
  s.buffers && s.buffers[0] && delete s.buffers[0].uri, e.removeExtension(Go);
}
const qu = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, Y3 = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class J3 {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, s) {
    this.json = e.json;
    const n = e.json;
    switch (n.asset && n.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${n.asset.version}`);
        return;
    }
    if (!s.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(n), this._convertTopLevelObjectsToArrays(n), K3(e), this._convertObjectIdsToArrayIndices(n), this._updateObjects(n), this._updateMaterial(n);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const s in qu)
      this._convertTopLevelObjectToArray(e, s);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, s) {
    const n = e[s];
    if (!(!n || Array.isArray(n))) {
      e[s] = [];
      for (const r in n) {
        const i = n[r];
        i.id = i.id || r;
        const o = e[s].length;
        e[s].push(i), this.idToIndexMap[s][r] = o;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const s in qu)
      this._convertIdsToIndices(e, s);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const s of e.textures)
      this._convertTextureIds(s);
    for (const s of e.meshes)
      this._convertMeshIds(s);
    for (const s of e.nodes)
      this._convertNodeIds(s);
    for (const s of e.scenes)
      this._convertSceneIds(s);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const s of e.primitives) {
      const { attributes: n, indices: r, material: i } = s;
      for (const o in n)
        n[o] = this._convertIdToIndex(n[o], "accessor");
      r && (s.indices = this._convertIdToIndex(r, "accessor")), i && (s.material = this._convertIdToIndex(i, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((s) => this._convertIdToIndex(s, "node"))), e.meshes && (e.meshes = e.meshes.map((s) => this._convertIdToIndex(s, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((s) => this._convertIdToIndex(s, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, s) {
    e[s] || (console.warn(`gltf v1: json doesn't contain attribute ${s}`), e[s] = []);
    for (const n of e[s])
      for (const r in n) {
        const i = n[r], o = this._convertIdToIndex(i, r);
        n[r] = o;
      }
  }
  _convertIdToIndex(e, s) {
    const n = Y3[s];
    if (n in this.idToIndexMap) {
      const r = this.idToIndexMap[n][e];
      if (!Number.isFinite(r))
        throw new Error(`gltf v1: failed to resolve ${s} with id ${e}`);
      return r;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const s of this.json.buffers)
      delete s.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    for (const s of e.materials) {
      s.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const n = s.values?.tex || s.values?.texture2d_0 || s.values?.diffuseTex, r = e.textures.findIndex((i) => i.id === n);
      r !== -1 && (s.pbrMetallicRoughness.baseColorTexture = { index: r });
    }
  }
}
function q3(t, e = {}) {
  return new J3().normalize(t, e);
}
async function Z3(t, e, s = 0, n, r) {
  return Q3(t, e, s, n), q3(t, { normalize: n?.gltf?.normalize }), G3(t, n, r), n?.gltf?.loadBuffers && t.json.buffers && await eP(t, n, r), n?.gltf?.loadImages && await tP(t, n, r), await $3(t, n, r), t;
}
function Q3(t, e, s, n) {
  if (n.uri && (t.baseUri = n.uri), e instanceof ArrayBuffer && !bM(e, s, n) && (e = new TextDecoder().decode(e)), typeof e == "string")
    t.json = ym(e);
  else if (e instanceof ArrayBuffer) {
    const o = {};
    s = EM(o, e, s, n.glb), Fe(o.type === "glTF", `Invalid GLB magic string ${o.type}`), t._glb = o, t.json = o.json;
  } else
    Fe(!1, "GLTF: must be ArrayBuffer or string");
  const r = t.json.buffers || [];
  if (t.buffers = new Array(r.length).fill(null), t._glb && t._glb.header.hasBinChunk) {
    const { binChunks: o } = t._glb;
    t.buffers[0] = {
      arrayBuffer: o[0].arrayBuffer,
      byteOffset: o[0].byteOffset,
      byteLength: o[0].byteLength
    };
  }
  const i = t.json.images || [];
  t.images = new Array(i.length).fill({});
}
async function eP(t, e, s) {
  const n = t.json.buffers || [];
  for (let r = 0; r < n.length; ++r) {
    const i = n[r];
    if (i.uri) {
      const { fetch: o } = s;
      Fe(o);
      const a = g_(i.uri, e), l = await (await s?.fetch?.(a))?.arrayBuffer?.();
      t.buffers[r] = {
        arrayBuffer: l,
        byteOffset: 0,
        byteLength: l.byteLength
      }, delete i.uri;
    } else t.buffers[r] === null && (t.buffers[r] = {
      arrayBuffer: new ArrayBuffer(i.byteLength),
      byteOffset: 0,
      byteLength: i.byteLength
    });
  }
}
async function tP(t, e, s) {
  const n = sP(t), r = t.json.images || [], i = [];
  for (const o of n)
    i.push(nP(t, r[o], o, e, s));
  return await Promise.all(i);
}
function sP(t) {
  const e = /* @__PURE__ */ new Set(), s = t.json.textures || [];
  for (const n of s)
    n.source !== void 0 && e.add(n.source);
  return Array.from(e).sort();
}
async function nP(t, e, s, n, r) {
  let i;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const a = g_(e.uri, n), { fetch: c } = r;
    i = await (await c(a)).arrayBuffer(), e.bufferView = {
      data: i
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const a = oB(t.json, t.buffers, e.bufferView);
    i = ec(a.buffer, a.byteOffset, a.byteLength);
  }
  Fe(i, "glTF image has no data");
  let o = await sr(i, [fd, Dv], {
    ...n,
    mimeType: e.mimeType,
    basis: n.basis || { format: r_() }
  }, r);
  o && o[0] && (o = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: o[0].width,
    height: o[0].height,
    data: o[0]
  }), t.images = t.images || [], t.images[s] = o;
}
const er = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: pM,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: rP,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function rP(t, e = {}, s) {
  e = { ...er.options, ...e }, e.gltf = { ...er.options.gltf, ...e.gltf };
  const { byteOffset: n = 0 } = e;
  return await Z3({}, t, n, e, s);
}
const iP = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, oP = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Le = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, aP = {
  magFilter: Le.TEXTURE_MAG_FILTER,
  minFilter: Le.TEXTURE_MIN_FILTER,
  wrapS: Le.TEXTURE_WRAP_S,
  wrapT: Le.TEXTURE_WRAP_T
}, cP = {
  [Le.TEXTURE_MAG_FILTER]: Le.LINEAR,
  [Le.TEXTURE_MIN_FILTER]: Le.NEAREST_MIPMAP_LINEAR,
  [Le.TEXTURE_WRAP_S]: Le.REPEAT,
  [Le.TEXTURE_WRAP_T]: Le.REPEAT
};
function lP() {
  return {
    id: "default-sampler",
    parameters: cP
  };
}
function hP(t) {
  return oP[t];
}
function uP(t) {
  return iP[t];
}
class fP {
  baseUri = "";
  // @ts-expect-error
  jsonUnprocessed;
  // @ts-expect-error
  json;
  buffers = [];
  images = [];
  postProcess(e, s = {}) {
    const { json: n, buffers: r = [], images: i = [] } = e, { baseUri: o = "" } = e;
    return Fe(n), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = n, this.json = this._resolveTree(e.json, s), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e, s = {}) {
    const n = { ...e };
    return this.json = n, e.bufferViews && (n.bufferViews = e.bufferViews.map((r, i) => this._resolveBufferView(r, i))), e.images && (n.images = e.images.map((r, i) => this._resolveImage(r, i))), e.samplers && (n.samplers = e.samplers.map((r, i) => this._resolveSampler(r, i))), e.textures && (n.textures = e.textures.map((r, i) => this._resolveTexture(r, i))), e.accessors && (n.accessors = e.accessors.map((r, i) => this._resolveAccessor(r, i))), e.materials && (n.materials = e.materials.map((r, i) => this._resolveMaterial(r, i))), e.meshes && (n.meshes = e.meshes.map((r, i) => this._resolveMesh(r, i))), e.nodes && (n.nodes = e.nodes.map((r, i) => this._resolveNode(r, i)), n.nodes = n.nodes.map((r, i) => this._resolveNodeChildren(r))), e.skins && (n.skins = e.skins.map((r, i) => this._resolveSkin(r, i))), e.scenes && (n.scenes = e.scenes.map((r, i) => this._resolveScene(r, i))), typeof this.json.scene == "number" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, s) {
    if (typeof s == "object")
      return s;
    const n = e && e[s];
    return n || console.warn(`glTF file error: Could not find ${e}[${s}]`), n;
  }
  // PARSING HELPERS
  _resolveScene(e, s) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${s}`,
      nodes: (e.nodes || []).map((n) => this.getNode(n))
    };
  }
  _resolveNode(e, s) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e?.id || `node-${s}`
    };
    return e.mesh !== void 0 && (n.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (n.camera = this.getCamera(e.camera)), e.skin !== void 0 && (n.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (n.mesh = e.meshes.reduce((r, i) => {
      const o = this.getMesh(i);
      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;
    }, { primitives: [] })), n;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((s) => this.getNode(s))), e;
  }
  _resolveSkin(e, s) {
    const n = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${s}`,
      inverseBindMatrices: n
    };
  }
  _resolveMesh(e, s) {
    const n = {
      ...e,
      id: e.id || `mesh-${s}`,
      primitives: []
    };
    return e.primitives && (n.primitives = e.primitives.map((r) => {
      const i = {
        ...r,
        attributes: {},
        indices: void 0,
        material: void 0
      }, o = r.attributes;
      for (const a in o)
        i.attributes[a] = this.getAccessor(o[a]);
      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;
    })), n;
  }
  _resolveMaterial(e, s) {
    const n = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${s}`
    };
    if (n.normalTexture && (n.normalTexture = { ...n.normalTexture }, n.normalTexture.texture = this.getTexture(n.normalTexture.index)), n.occlusionTexture && (n.occlusionTexture = { ...n.occlusionTexture }, n.occlusionTexture.texture = this.getTexture(n.occlusionTexture.index)), n.emissiveTexture && (n.emissiveTexture = { ...n.emissiveTexture }, n.emissiveTexture.texture = this.getTexture(n.emissiveTexture.index)), n.emissiveFactor || (n.emissiveFactor = n.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), n.pbrMetallicRoughness) {
      n.pbrMetallicRoughness = { ...n.pbrMetallicRoughness };
      const r = n.pbrMetallicRoughness;
      r.baseColorTexture && (r.baseColorTexture = { ...r.baseColorTexture }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = { ...r.metallicRoughnessTexture }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));
    }
    return n;
  }
  _resolveAccessor(e, s) {
    const n = hP(e.componentType), r = uP(e.type), i = n * r, o = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${s}`,
      bytesPerComponent: n,
      components: r,
      bytesPerElement: i,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (o.bufferView = this.getBufferView(e.bufferView)), o.bufferView) {
      const a = o.bufferView.buffer, { ArrayType: c, byteLength: l } = Wc(o, o.bufferView), h = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;
      let u = a.arrayBuffer.slice(h, h + l);
      o.bufferView.byteStride && (u = this._getValueFromInterleavedBuffer(a, h, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(u);
    }
    return o;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, s, n, r, i) {
    const o = new Uint8Array(i * r);
    for (let a = 0; a < i; a++) {
      const c = s + a * n;
      o.set(new Uint8Array(e.arrayBuffer.slice(c, c + r)), a * r);
    }
    return o.buffer;
  }
  _resolveTexture(e, s) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${s}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : lP(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, s) {
    const n = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${s}`,
      ...e,
      parameters: {}
    };
    for (const r in n) {
      const i = this._enumSamplerParameter(r);
      i !== void 0 && (n.parameters[i] = n[r]);
    }
    return n;
  }
  _enumSamplerParameter(e) {
    return aP[e];
  }
  _resolveImage(e, s) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${s}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, r = this.images[s];
    return r && (n.image = r), n;
  }
  _resolveBufferView(e, s) {
    const n = e.buffer, r = this.buffers[n].arrayBuffer;
    let i = this.buffers[n].byteOffset || 0;
    return e.byteOffset && (i += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${s}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[n],
      data: new Uint8Array(r, i, e.byteLength)
    };
  }
  _resolveCamera(e, s) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${s}`
    };
    return n.perspective, n.orthographic, n;
  }
}
function Yc(t, e) {
  return new fP().postProcess(t, e);
}
async function dP(t) {
  const e = [];
  return t.scenes.forEach((s) => {
    s.traverse((n) => {
      Object.values(n.model.uniforms).forEach((r) => {
        r.loaded === !1 && e.push(r);
      });
    });
  }), await pP(() => e.some((s) => !s.loaded));
}
async function pP(t) {
  for (; t(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const _P = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(MODULE_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(sizeScale);
float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, gP = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
uniform float opacity;
in vec4 vColor;
out vec4 fragColor;
#ifndef MODULE_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D u_BaseColorSampler;
#endif
#endif
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, C_ = [255, 255, 255, 255], mP = {
  scenegraph: { type: "object", value: null, async: !0 },
  getScene: (t) => t && t.scenes ? typeof t.scene == "object" ? t.scene : t.scenes[t.scene || 0] : t,
  getAnimator: (t) => t && t.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (t) => t.position },
  getColor: { type: "accessor", value: C_ },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [er]
};
class Jc extends fn {
  getShaders() {
    const e = [vc, Pc];
    return this.props._lighting === "pbr" && e.push(wc), super.getShaders({ vs: _P, fs: gP, modules: e });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: C_,
        transition: !0
      },
      instanceModelMatrix: e_
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: s, oldProps: n } = e;
    s.scenegraph !== n.scenegraph ? this._updateScenegraph() : s._animations !== n._animations && this._applyAnimationsProp(this.state.animator, s._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.scenegraph?.destroy();
  }
  get isLoaded() {
    return !!(this.state?.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    const e = this.props, { device: s } = this.context;
    let n = null;
    if (e.scenegraph instanceof mi)
      n = { scenes: [e.scenegraph] };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const a = e.scenegraph, c = a.json ? Yc(a) : a, l = Qv(s, c, this._getModelOptions());
      n = { gltf: c, ...l }, dP(l).then(() => {
        this.setNeedsRedraw();
      }).catch((h) => {
        this.raiseError(h, "loading glTF");
      });
    }
    const r = { layer: this, device: this.context.device }, i = e.getScene(n, r), o = e.getAnimator(n, r);
    if (i instanceof Ys) {
      this.state.scenegraph?.destroy(), this._applyAnimationsProp(o, e._animations);
      const a = [];
      i.traverse((c) => {
        c instanceof va && a.push(c.model);
      }), this.setState({ scenegraph: i, animator: o, models: a }), this.getAttributeManager().invalidateAll();
    } else i !== null && $.warn("invalid scenegraph:", i)();
  }
  _applyAnimationsProp(e, s) {
    if (!e || !s)
      return;
    const n = e.getAnimations();
    Object.keys(s).sort().forEach((r) => {
      const i = s[r];
      if (r === "*")
        n.forEach((o) => {
          Object.assign(o, i);
        });
      else if (Number.isFinite(Number(r))) {
        const o = Number(r);
        o >= 0 && o < n.length ? Object.assign(n[o], i) : $.warn(`animation ${r} not found`)();
      } else {
        const o = n.find(({ name: a }) => a === r);
        o ? Object.assign(o, i) : $.warn(`animation ${r} not found`)();
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment: e } = this.props;
    let s;
    return e && (typeof e == "function" ? s = e({ gl: this.context.gl, layer: this }) : s = e), {
      imageBasedLightingEnvironment: s,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw({ context: e }) {
    if (!this.state.scenegraph)
      return;
    this.props._animations && this.state.animator && (this.state.animator.animate(e.timeline.getTime()), this.setNeedsRedraw());
    const { viewport: s, renderPass: n } = this.context, { sizeScale: r, sizeMinPixels: i, sizeMaxPixels: o, opacity: a, coordinateSystem: c } = this.props, l = this.getNumInstances();
    this.state.scenegraph.traverse((h, { worldMatrix: u }) => {
      if (h instanceof va) {
        const { model: f } = h;
        f.setInstanceCount(l), f.setUniforms({
          sizeScale: r,
          opacity: a,
          sizeMinPixels: i,
          sizeMaxPixels: o,
          composeModelMatrix: t_(s, c),
          sceneModelMatrix: u,
          // Needed for PBR (TODO: find better way to get it)
          // eslint-disable-next-line camelcase
          u_Camera: f.uniforms.project_uCameraPosition
        }), f.draw(n);
      }
    });
  }
}
Jc.defaultProps = mP;
Jc.layerName = "ScenegraphLayer";
const AP = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, TP = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function yP(t) {
  const e = t.positions || t.POSITION, s = e.value.length / e.size;
  t.COLOR_0 || t.colors || (t.colors = {
    size: 4,
    value: new Uint8Array(s * 4).fill(255),
    normalized: !0
  });
}
const bP = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: !0 }
};
class qc extends jc {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(wc), { ...e, vs: AP, fs: TP };
  }
  initializeState() {
    const { featureIds: e } = this.props;
    super.initializeState();
    const s = this.getAttributeManager();
    e && s.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: s, oldProps: n } = e;
    s.pbrMaterial !== n.pbrMaterial && this.updatePbrMaterialUniforms(s.pbrMaterial);
  }
  draw(e) {
    const { featureIds: s } = this.props;
    this.state.model && (this.state.model.setUniforms({
      // Needed for PBR (TODO: find better way to get it)
      // eslint-disable-next-line camelcase
      u_Camera: this.state.model.uniforms.project_uCameraPosition,
      pickFeatureIds: !!s
    }), super.draw(e));
  }
  getModel(e) {
    const { id: s, pbrMaterial: n } = this.props, r = this.parseMaterial(n, e);
    this.setState({ parsedPBRMaterial: r });
    const i = this.getShaders();
    return yP(e.attributes), new Yt(this.context.device, {
      ...this.getShaders(),
      id: s,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...i.defines,
        ...r?.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: r?.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const { model: s } = this.state;
    if (s) {
      const { mesh: n } = this.props, r = this.parseMaterial(e, n);
      this.setState({ parsedPBRMaterial: r }), s.setBindings(r.bindings), s.setUniforms(r.uniforms);
    }
  }
  parseMaterial(e, s) {
    const n = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return s_(this.context.device, { unlit: n, ...e }, { NORMAL: s.attributes.normals, TEXCOORD_0: s.attributes.texCoords }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const s = this.props.featureIds, n = new Uint8ClampedArray(s.length * e.size), r = [];
    for (let i = 0; i < s.length; i++)
      this.encodePickingColor(s[i], r), n[i * 3] = r[0], n[i * 3 + 1] = r[1], n[i * 3 + 2] = r[2];
    e.value = n;
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.parsedPBRMaterial?.generatedTextures.forEach((s) => s.destroy()), this.setState({ parsedPBRMaterial: null });
  }
}
qc.layerName = "MeshLayer";
qc.defaultProps = bP;
const EP = 6378137, CP = 6378137, SP = 6356752314245179e-9;
function zi(t) {
  return t;
}
new S();
function RP(t, e = [], s = zi) {
  return "longitude" in t ? (e[0] = s(t.longitude), e[1] = s(t.latitude), e[2] = t.height) : "x" in t ? (e[0] = s(t.x), e[1] = s(t.y), e[2] = t.z) : (e[0] = s(t[0]), e[1] = s(t[1]), e[2] = t[2]), e;
}
function wP(t, e = []) {
  return RP(t, e, fe._cartographicRadians ? zi : oE);
}
function IP(t, e, s = zi) {
  return "longitude" in e ? (e.longitude = s(t[0]), e.latitude = s(t[1]), e.height = t[2]) : "x" in e ? (e.x = s(t[0]), e.y = s(t[1]), e.z = t[2]) : (e[0] = s(t[0]), e[1] = s(t[1]), e[2] = t[2]), e;
}
function vP(t, e) {
  return IP(t, e, fe._cartographicRadians ? zi : aE);
}
const Zu = 1e-14, BP = new S(), Qu = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, $o = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Bn = {
  east: new S(),
  north: new S(),
  up: new S(),
  west: new S(),
  south: new S(),
  down: new S()
}, MP = new S(), PP = new S(), OP = new S();
function ef(t, e, s, n, r, i) {
  const o = Qu[e] && Qu[e][s];
  $e(o && (!n || n === o));
  let a, c, l;
  const h = BP.copy(r);
  if (Qe(h.x, 0, Zu) && Qe(h.y, 0, Zu)) {
    const f = Math.sign(h.z);
    a = MP.fromArray($o[e]), e !== "east" && e !== "west" && a.scale(f), c = PP.fromArray($o[s]), s !== "east" && s !== "west" && c.scale(f), l = OP.fromArray($o[n]), n !== "east" && n !== "west" && l.scale(f);
  } else {
    const { up: f, east: p, north: m } = Bn;
    p.set(-h.y, h.x, 0).normalize(), t.geodeticSurfaceNormal(h, f), m.copy(f).cross(p);
    const { down: A, west: E, south: C } = Bn;
    A.copy(f).scale(-1), E.copy(p).scale(-1), C.copy(m).scale(-1), a = Bn[e], c = Bn[s], l = Bn[n];
  }
  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = l.x, i[9] = l.y, i[10] = l.z, i[11] = 0, i[12] = h.x, i[13] = h.y, i[14] = h.z, i[15] = 1, i;
}
const xs = new S(), xP = new S(), NP = new S();
function FP(t, e, s = []) {
  const { oneOverRadii: n, oneOverRadiiSquared: r, centerToleranceSquared: i } = e;
  xs.from(t);
  const o = xs.x, a = xs.y, c = xs.z, l = n.x, h = n.y, u = n.z, f = o * o * l * l, p = a * a * h * h, m = c * c * u * u, A = f + p + m, E = Math.sqrt(1 / A);
  if (!Number.isFinite(E))
    return;
  const C = xP;
  if (C.copy(t).scale(E), A < i)
    return C.to(s);
  const w = r.x, I = r.y, B = r.z, x = NP;
  x.set(C.x * w * 2, C.y * I * 2, C.z * B * 2);
  let N = (1 - E) * xs.len() / (0.5 * x.len()), L = 0, k, F, U, H;
  do {
    N -= L, k = 1 / (1 + N * w), F = 1 / (1 + N * I), U = 1 / (1 + N * B);
    const Y = k * k, te = F * F, z = U * U, me = Y * k, es = te * F, yt = z * U;
    H = f * Y + p * te + m * z - 1;
    const dn = -2 * (f * me * w + p * es * I + m * yt * B);
    L = H / dn;
  } while (Math.abs(H) > w0);
  return xs.scale([k, F, U]).to(s);
}
const Gr = new S(), tf = new S(), DP = new S(), Xe = new S(), UP = new S(), $r = new S();
class ne {
  constructor(e = 0, s = 0, n = 0) {
    this.centerToleranceSquared = R0, $e(e >= 0), $e(s >= 0), $e(n >= 0), this.radii = new S(e, s, n), this.radiiSquared = new S(e * e, s * s, n * n), this.radiiToTheFourth = new S(e * e * e * e, s * s * s * s, n * n * n * n), this.oneOverRadii = new S(e === 0 ? 0 : 1 / e, s === 0 ? 0 : 1 / s, n === 0 ? 0 : 1 / n), this.oneOverRadiiSquared = new S(e === 0 ? 0 : 1 / (e * e), s === 0 ? 0 : 1 / (s * s), n === 0 ? 0 : 1 / (n * n)), this.minimumRadius = Math.min(e, s, n), this.maximumRadius = Math.max(e, s, n), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e, s = [0, 0, 0]) {
    const n = tf, r = DP, [, , i] = e;
    this.geodeticSurfaceNormalCartographic(e, n), r.copy(this.radiiSquared).scale(n);
    const o = Math.sqrt(n.dot(r));
    return r.scale(1 / o), n.scale(i), r.add(n), r.to(s);
  }
  cartesianToCartographic(e, s = [0, 0, 0]) {
    $r.from(e);
    const n = this.scaleToGeodeticSurface($r, Xe);
    if (!n)
      return;
    const r = this.geodeticSurfaceNormal(n, tf), i = UP;
    i.copy($r).subtract(n);
    const o = Math.atan2(r.y, r.x), a = Math.asin(r.z), c = Math.sign(bc(i, $r)) * Xd(i);
    return vP([o, a, c], s);
  }
  eastNorthUpToFixedFrame(e, s = new W()) {
    return ef(this, "east", "north", "up", e, s);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, s, n, r, i = new W()) {
    return ef(this, e, s, n, r, i);
  }
  geocentricSurfaceNormal(e, s = [0, 0, 0]) {
    return Gr.from(e).normalize().to(s);
  }
  geodeticSurfaceNormalCartographic(e, s = [0, 0, 0]) {
    const n = wP(e), r = n[0], i = n[1], o = Math.cos(i);
    return Gr.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), Gr.to(s);
  }
  geodeticSurfaceNormal(e, s = [0, 0, 0]) {
    return Gr.from(e).scale(this.oneOverRadiiSquared).normalize().to(s);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, s) {
    return FP(e, this, s);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e, s = [0, 0, 0]) {
    Xe.from(e);
    const n = Xe.x, r = Xe.y, i = Xe.z, o = this.oneOverRadiiSquared, a = 1 / Math.sqrt(n * n * o.x + r * r * o.y + i * i * o.z);
    return Xe.multiplyScalar(a).to(s);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e, s = [0, 0, 0]) {
    return Xe.from(e).scale(this.oneOverRadii).to(s);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e, s = [0, 0, 0]) {
    return Xe.from(e).scale(this.radii).to(s);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e, s = 0, n = [0, 0, 0]) {
    $e(Qe(this.radii.x, this.radii.y, tp)), $e(this.radii.z > 0), Xe.from(e);
    const r = Xe.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(r) >= this.radii.z - s))
      return Xe.set(0, 0, r).to(n);
  }
}
ne.WGS84 = new ne(EP, CP, SP);
class LP {
  item;
  previous;
  next;
  constructor(e, s, n) {
    this.item = e, this.previous = s, this.next = n;
  }
}
class kP {
  head = null;
  tail = null;
  _length = 0;
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const s = new LP(e, this.tail, null);
    return this.tail ? (this.tail.next = s, this.tail = s) : (this.head = s, this.tail = s), ++this._length, s;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, s) {
    e !== s && (this.remove(s), this._insert(e, s));
  }
  _insert(e, s) {
    const n = e.next;
    e.next = s, this.tail === e ? this.tail = s : n.previous = s, s.next = n, s.previous = e, ++this._length;
  }
}
class VP {
  _list;
  _sentinel;
  _trimTiles;
  constructor() {
    this._list = new kP(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const s = e._cacheNode;
    s && this._list.splice(this._sentinel, s);
  }
  add(e, s, n) {
    s._cacheNode || (s._cacheNode = this._list.add(s), n && n(e, s));
  }
  unloadTile(e, s, n) {
    const r = s._cacheNode;
    r && (this._list.remove(r), s._cacheNode = null, n && n(e, s));
  }
  unloadTiles(e, s) {
    const n = this._trimTiles;
    this._trimTiles = !1;
    const r = this._list, i = e.maximumMemoryUsage * 1024 * 1024, o = this._sentinel;
    let a = r.head;
    for (; a !== o && (e.gpuMemoryUsageInBytes > i || n); ) {
      const c = a.item;
      a = a.next, this.unloadTile(e, c, s);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function HP(t, e) {
  se(t), se(e);
  const { rtcCenter: s, gltfUpAxis: n } = e, { computedTransform: r, boundingVolume: { center: i } } = t;
  let o = new W(r);
  switch (s && o.translate(s), n) {
    case "Z":
      break;
    case "Y":
      const u = new W().rotateX(Math.PI / 2);
      o = o.multiplyRight(u);
      break;
    case "X":
      const f = new W().rotateY(-Math.PI / 2);
      o = o.multiplyRight(f);
      break;
  }
  e.isQuantized && o.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const a = new S(i);
  e.cartesianModelMatrix = o, e.cartesianOrigin = a;
  const c = ne.WGS84.cartesianToCartographic(a, new S()), h = ne.WGS84.eastNorthUpToFixedFrame(a).invert();
  e.cartographicModelMatrix = h.multiplyRight(o), e.cartographicOrigin = c, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const sf = new S(), Ko = new S(), Xa = new ke([
  new pt(),
  new pt(),
  new pt(),
  new pt(),
  new pt(),
  new pt()
]);
function zP(t, e) {
  const { cameraDirection: s, cameraUp: n, height: r } = t, { metersPerUnit: i } = t.distanceScales, o = ri(t, t.center), a = ne.WGS84.eastNorthUpToFixedFrame(o), c = t.unprojectPosition(t.cameraPosition), l = ne.WGS84.cartographicToCartesian(c, new S()), h = new S(
    // @ts-ignore
    a.transformAsVector(new S(s).scale(i))
  ).normalize(), u = new S(
    // @ts-ignore
    a.transformAsVector(new S(n).scale(i))
  ).normalize();
  WP(t);
  const f = t.constructor, { longitude: p, latitude: m, width: A, bearing: E, zoom: C } = t, w = new f({
    longitude: p,
    latitude: m,
    height: r,
    width: A,
    bearing: E,
    zoom: C,
    pitch: 0
  });
  return {
    camera: {
      position: l,
      direction: h,
      up: u
    },
    viewport: t,
    topDownViewport: w,
    height: r,
    cullingVolume: Xa,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function jP(t, e, s) {
  if (s === 0 || t.length <= s)
    return [t, []];
  const n = [], { longitude: r, latitude: i } = e.viewport;
  for (const [l, h] of t.entries()) {
    const [u, f] = h.header.mbs, p = Math.abs(r - u), m = Math.abs(i - f), A = Math.sqrt(m * m + p * p);
    n.push([l, A]);
  }
  const o = n.sort((l, h) => l[1] - h[1]), a = [];
  for (let l = 0; l < s; l++)
    a.push(t[o[l][0]]);
  const c = [];
  for (let l = s; l < o.length; l++)
    c.push(t[o[l][0]]);
  return [a, c];
}
function WP(t) {
  const e = t.getFrustumPlanes(), s = nf(e.near, t.cameraPosition), n = ri(t, s), r = ri(t, t.cameraPosition, Ko);
  let i = 0;
  Xa.planes[i++].fromPointNormal(n, sf.copy(n).subtract(r));
  for (const o in e) {
    if (o === "near")
      continue;
    const a = e[o], c = nf(a, s, Ko), l = ri(t, c, Ko);
    Xa.planes[i++].fromPointNormal(
      l,
      // Want the normal to point into the frustum since that's what culling expects
      sf.copy(n).subtract(l)
    );
  }
}
function nf(t, e, s = new S()) {
  const n = t.normal.dot(e);
  return s.copy(t.normal).scale(t.distance - n).add(e), s;
}
function ri(t, e, s = new S()) {
  const n = t.unprojectPosition(e);
  return ne.WGS84.cartographicToCartesian(n, s);
}
const XP = 6378137, GP = 6378137, Ga = 6356752314245179e-9, js = new S();
function $P(t, e) {
  if (t instanceof ur) {
    const { halfAxes: s } = t, n = YP(s);
    return Math.log2(Ga / (n + e[2]));
  } else if (t instanceof hr) {
    const { radius: s } = t;
    return Math.log2(Ga / (s + e[2]));
  } else if (t.width && t.height) {
    const { width: s, height: n } = t, r = Math.log2(XP / s), i = Math.log2(GP / n);
    return (r + i) / 2;
  }
  return 1;
}
function S_(t, e, s) {
  ne.WGS84.cartographicToCartesian([t.xmax, t.ymax, t.zmax], js);
  const n = Math.sqrt(Math.pow(js[0] - s[0], 2) + Math.pow(js[1] - s[1], 2) + Math.pow(js[2] - s[2], 2));
  return Math.log2(Ga / (n + e[2]));
}
function KP(t, e, s) {
  const [n, r, i, o] = t;
  return S_({ xmax: i, ymax: o, zmax: 0 }, e, s);
}
function YP(t) {
  t.getColumn(0, js);
  const e = t.getColumn(1), s = t.getColumn(2);
  return js.add(e).add(s).len();
}
const Oe = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var et;
(function(t) {
  t[t.ADD = 1] = "ADD", t[t.REPLACE = 2] = "REPLACE";
})(et || (et = {}));
var It;
(function(t) {
  t.EMPTY = "empty", t.SCENEGRAPH = "scenegraph", t.POINTCLOUD = "pointcloud", t.MESH = "mesh";
})(It || (It = {}));
var Ie;
(function(t) {
  t.I3S = "I3S", t.TILES3D = "TILES3D";
})(Ie || (Ie = {}));
var an;
(function(t) {
  t.GEOMETRIC_ERROR = "geometricError", t.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(an || (an = {}));
const JP = {
  USE_OPTIMIZATION: 1
};
function R_(t) {
  return t != null;
}
const ye = new S(), ii = new S(), qP = new S(), ZP = new S(), is = new S(), rf = new S(), of = new S(), af = new S();
function Yo(t, e, s) {
  if (se(t, "3D Tile: boundingVolume must be defined"), t.box)
    return w_(t.box, e, s);
  if (t.region)
    return tO(t.region);
  if (t.sphere)
    return eO(t.sphere, e, s);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function QP(t, e) {
  if (t.box)
    return sO(e);
  if (t.region) {
    const [s, n, r, i, o, a] = t.region;
    return [
      [Ge(s), Ge(n), o],
      [Ge(r), Ge(i), a]
    ];
  }
  if (t.sphere)
    return nO(e);
  throw new Error("Unkown boundingVolume type");
}
function w_(t, e, s) {
  const n = new S(t[0], t[1], t[2]);
  e.transform(n, n);
  let r = [];
  if (t.length === 10) {
    const l = t.slice(3, 6), h = new $n();
    h.fromArray(t, 6);
    const u = new S([1, 0, 0]), f = new S([0, 1, 0]), p = new S([0, 0, 1]);
    u.transformByQuaternion(h), u.scale(l[0]), f.transformByQuaternion(h), f.scale(l[1]), p.transformByQuaternion(h), p.scale(l[2]), r = [...u.toArray(), ...f.toArray(), ...p.toArray()];
  } else
    r = [...t.slice(3, 6), ...t.slice(6, 9), ...t.slice(9, 12)];
  const i = e.transformAsVector(r.slice(0, 3)), o = e.transformAsVector(r.slice(3, 6)), a = e.transformAsVector(r.slice(6, 9)), c = new ae([
    i[0],
    i[1],
    i[2],
    o[0],
    o[1],
    o[2],
    a[0],
    a[1],
    a[2]
  ]);
  return R_(s) ? (s.center = n, s.halfAxes = c, s) : new ur(n, c);
}
function eO(t, e, s) {
  const n = new S(t[0], t[1], t[2]);
  e.transform(n, n);
  const r = e.getScale(ii), i = Math.max(Math.max(r[0], r[1]), r[2]), o = t[3] * i;
  return R_(s) ? (s.center = n, s.radius = o, s) : new hr(n, o);
}
function tO(t) {
  const [e, s, n, r, i, o] = t, a = ne.WGS84.cartographicToCartesian([Ge(e), Ge(r), i], qP), c = ne.WGS84.cartographicToCartesian([Ge(n), Ge(s), o], ZP), l = new S().addVectors(a, c).multiplyByScalar(0.5);
  return ne.WGS84.cartesianToCartographic(l, is), ne.WGS84.cartographicToCartesian([Ge(n), is[1], is[2]], rf), ne.WGS84.cartographicToCartesian([is[0], Ge(r), is[2]], of), ne.WGS84.cartographicToCartesian([is[0], is[1], o], af), w_([
    ...l,
    ...rf.subtract(l),
    ...of.subtract(l),
    ...af.subtract(l)
  ], new W());
}
function sO(t) {
  const e = I_(), { halfAxes: s } = t, n = new S(s.getColumn(0)), r = new S(s.getColumn(1)), i = new S(s.getColumn(2));
  for (let o = 0; o < 2; o++) {
    for (let a = 0; a < 2; a++) {
      for (let c = 0; c < 2; c++)
        ye.copy(t.center), ye.add(n), ye.add(r), ye.add(i), v_(e, ye), i.negate();
      r.negate();
    }
    n.negate();
  }
  return e;
}
function nO(t) {
  const e = I_(), { center: s, radius: n } = t, r = ne.WGS84.scaleToGeodeticSurface(s, ye);
  let i;
  r ? i = ne.WGS84.geodeticSurfaceNormal(r) : i = new S(0, 0, 1);
  let o = new S(i[2], -i[1], 0);
  o.len() > 0 ? o.normalize() : o = new S(0, 1, 0);
  const a = o.clone().cross(i);
  for (const c of [o, a, i]) {
    ii.copy(c).scale(n);
    for (let l = 0; l < 2; l++)
      ye.copy(s), ye.add(ii), v_(e, ye), ii.negate();
  }
  return e;
}
function I_() {
  return [
    [1 / 0, 1 / 0, 1 / 0],
    [-1 / 0, -1 / 0, -1 / 0]
  ];
}
function v_(t, e) {
  ne.WGS84.cartesianToCartographic(e, ye), t[0][0] = Math.min(t[0][0], ye[0]), t[0][1] = Math.min(t[0][1], ye[1]), t[0][2] = Math.min(t[0][2], ye[2]), t[1][0] = Math.max(t[1][0], ye[0]), t[1][1] = Math.max(t[1][1], ye[1]), t[1][2] = Math.max(t[1][2], ye[2]);
}
new S();
new S();
new W();
new S();
new S();
new S();
function rO(t, e) {
  const s = t * e;
  return 1 - Math.exp(-(s * s));
}
function iO(t, e) {
  if (t.dynamicScreenSpaceError && t.dynamicScreenSpaceErrorComputedDensity) {
    const s = t.dynamicScreenSpaceErrorComputedDensity, n = t.dynamicScreenSpaceErrorFactor;
    return rO(e, s) * n;
  }
  return 0;
}
function oO(t, e, s) {
  const n = t.tileset, r = t.parent && t.parent.lodMetricValue || t.lodMetricValue, i = s ? r : t.lodMetricValue;
  if (i === 0)
    return 0;
  const o = Math.max(t._distanceToCamera, 1e-7), { height: a, sseDenominator: c } = e, { viewDistanceScale: l } = n.options;
  let h = i * a * (l || 1) / (o * c);
  return h -= iO(n, o), h;
}
const Jo = new S(), cf = new S(), kt = new S(), lf = new S(), aO = new S(), qo = new W(), hf = new W();
function cO(t, e) {
  if (t.lodMetricValue === 0 || isNaN(t.lodMetricValue))
    return "DIG";
  const s = 2 * B_(t, e);
  return s < 2 ? "OUT" : !t.header.children || s <= t.lodMetricValue ? "DRAW" : t.header.children ? "DIG" : "OUT";
}
function B_(t, e) {
  const { topDownViewport: s } = e, n = t.header.mbs[1], r = t.header.mbs[0], i = t.header.mbs[2], o = t.header.mbs[3], a = [...t.boundingVolume.center], c = s.unprojectPosition(s.cameraPosition);
  ne.WGS84.cartographicToCartesian(c, Jo), cf.copy(Jo).subtract(a).normalize(), ne.WGS84.eastNorthUpToFixedFrame(a, qo), hf.copy(qo).invert(), kt.copy(Jo).transform(hf);
  const l = Math.sqrt(kt[0] * kt[0] + kt[1] * kt[1]), h = l * l / kt[2];
  lf.copy([kt[0], kt[1], h]);
  const f = lf.transform(qo).subtract(a).normalize(), m = cf.cross(f).normalize().scale(o).add(a), A = ne.WGS84.cartesianToCartographic(m), E = s.project([r, n, i]), C = s.project(A);
  return aO.copy(E).subtract(C).magnitude();
}
function lO(t) {
  return {
    assetGltfUpAxis: t.asset && t.asset.gltfUpAxis || "Y"
  };
}
class uf {
  _map = /* @__PURE__ */ new Map();
  _array;
  _length;
  constructor(e = 0) {
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return se(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, s) {
    se(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = s, this._map.set(s, e);
  }
  delete(e) {
    const s = this._map.get(e);
    s >= 0 && (this._array.splice(s, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const s = this.length++;
      this._array[s] = e, this._map.set(e, s);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    se(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    se(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const hO = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class ji {
  options;
  // fulfill in traverse call
  root = null;
  // tiles should be rendered
  selectedTiles = {};
  // tiles should be loaded from server
  requestedTiles = {};
  // tiles does not have render content
  emptyTiles = {};
  lastUpdate = (/* @__PURE__ */ new Date()).getTime();
  updateDebounceTime = 1e3;
  /** temporary storage to hold the traversed tiles during a traversal */
  _traversalStack = new uf();
  _emptyTraversalStack = new uf();
  /** set in every traverse cycle */
  _frameNumber = null;
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // TODO nested props
  constructor(e) {
    this.options = { ...hO, ...e };
  }
  // tiles should be visible
  traverse(e, s, n) {
    this.root = e, this.options = { ...this.options, ...n }, this.reset(), this.updateTile(e, s), this._frameNumber = s.frameNumber, this.executeTraversal(e, s);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, s) {
    const n = this._traversalStack;
    for (e._selectionDepth = 1, n.push(e); n.length > 0; ) {
      const i = n.pop();
      let o = !1;
      this.canTraverse(i, s) && (this.updateChildTiles(i, s), o = this.updateAndPushChildren(i, s, n, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));
      const a = i.parent, c = !!(!a || a._shouldRefine), l = !o;
      i.hasRenderContent ? i.refine === et.ADD ? (this.loadTile(i, s), this.selectTile(i, s)) : i.refine === et.REPLACE && (this.loadTile(i, s), l && this.selectTile(i, s)) : (this.emptyTiles[i.id] = i, this.loadTile(i, s), l && this.selectTile(i, s)), this.touchTile(i, s), i._shouldRefine = o && c;
    }
    const r = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(s) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(s));
  }
  updateChildTiles(e, s) {
    const n = e.children;
    for (const r of n)
      this.updateTile(r, s);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, s, n, r) {
    const { loadSiblings: i, skipLevelOfDetail: o } = this.options, a = e.children;
    a.sort(this.compareDistanceToCamera.bind(this));
    const c = e.refine === et.REPLACE && e.hasRenderContent && !o;
    let l = !1, h = !0;
    for (const u of a)
      if (u._selectionDepth = r, u.isVisibleAndInRequestVolume ? (n.find(u) && n.delete(u), n.push(u), l = !0) : (c || i) && (this.loadTile(u, s), this.touchTile(u, s)), c) {
        let f;
        if (u._inRequestVolume ? u.hasRenderContent ? f = u.contentAvailable : f = this.executeEmptyTraversal(u, s) : f = !1, h = h && f, !h)
          return !1;
      }
    return l || (h = !1), h;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, s) {
    this.updateTileVisibility(e, s);
  }
  // tile to render in the browser
  selectTile(e, s) {
    this.shouldSelectTile(e) && (e._selectedFrame = s.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, s) {
    this.shouldLoadTile(e) && (e._requestedFrame = s.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, s) {
    e.tileset._cache.touch(e), e._touchedFrame = s.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, s) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, s) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, s, n = !1) {
    let r = e._screenSpaceError;
    return n && (r = e.getScreenSpaceError(s, !0)), r > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, s) {
    const n = [];
    if (this.options.viewportTraversersMap)
      for (const r in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[r] === s.viewport.id && n.push(r);
    else
      n.push(s.viewport.id);
    e.updateVisibility(s, n);
  }
  // UTILITIES
  compareDistanceToCamera(e, s) {
    return e._distanceToCamera - s._distanceToCamera;
  }
  anyChildrenVisible(e, s) {
    let n = !1;
    for (const r of e.children)
      r.updateVisibility(s), n = n || r.isVisibleAndInRequestVolume;
    return n;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, s) {
    let n = !0;
    const r = this._emptyTraversalStack;
    for (r.push(e); r.length > 0; ) {
      const i = r.pop(), o = !i.hasRenderContent && this.canTraverse(i, s), a = !i.hasRenderContent && i.children.length === 0;
      if (!o && !i.contentAvailable && !a && (n = !1), this.updateTile(i, s), i.isVisibleAndInRequestVolume || (this.loadTile(i, s), this.touchTile(i, s)), o) {
        const c = i.children;
        for (const l of c)
          r.push(l);
      }
    }
    return n;
  }
}
const ff = new S();
function uO(t) {
  return t != null;
}
class $a {
  tileset;
  header;
  id;
  url;
  parent;
  /* Specifies the type of refine that is used when traversing this tile for rendering. */
  refine;
  type;
  contentUrl;
  /** Different refinement algorithms used by I3S and 3D tiles */
  lodMetricType = "geometricError";
  /** The error, in meters, introduced if this tile is rendered and its children are not. */
  lodMetricValue = 0;
  /** @todo math.gl is not exporting BoundingVolume base type? */
  boundingVolume = null;
  /**
   * The tile's content.  This represents the actual tile's payload,
   * not the content's metadata in the tileset JSON file.
   */
  content = null;
  contentState = Oe.UNLOADED;
  gpuMemoryUsageInBytes = 0;
  /** The tile's children - an array of Tile3D objects. */
  children = [];
  depth = 0;
  viewportIds = [];
  transform = new W();
  extensions = null;
  /** TODO Cesium 3d tiles specific */
  implicitTiling = null;
  /** Container to store application specific data */
  userData = {};
  computedTransform;
  hasEmptyContent = !1;
  hasTilesetContent = !1;
  traverser = new ji({});
  /** Used by TilesetCache */
  _cacheNode = null;
  _frameNumber = null;
  // TODO Cesium 3d tiles specific
  _expireDate = null;
  _expiredContent = null;
  _boundingBox = void 0;
  /** updated every frame for tree traversal and rendering optimizations: */
  _distanceToCamera = 0;
  _screenSpaceError = 0;
  _visibilityPlaneMask;
  _visible = void 0;
  _contentBoundingVolume;
  _viewerRequestVolume;
  _initialTransform = new W();
  // Used by traverser, cannot be marked private
  _priority = 0;
  _selectedFrame = 0;
  _requestedFrame = 0;
  _selectionDepth = 0;
  _touchedFrame = 0;
  _centerZDepth = 0;
  _shouldRefine = !1;
  _stackLength = 0;
  _visitedFrame = 0;
  _inRequestVolume = !1;
  _lodJudge = null;
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, s, n, r = "") {
    this.header = s, this.tileset = e, this.id = r || s.id, this.url = s.url, this.parent = n, this.refine = this._getRefine(s.refine), this.type = s.type, this.contentUrl = s.contentUrl, this._initializeLodMetric(s), this._initializeTransforms(s), this._initializeBoundingVolumes(s), this._initializeContent(s), this._initializeRenderingState(s), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === Oe.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === Oe.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === Oe.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === Oe.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = QP(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, s) {
    switch (this.tileset.type) {
      case Ie.I3S:
        return B_(this, e);
      case Ie.TILES3D:
        return oO(this, e, s);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, { skipLevelOfDetail: s } = e.options, n = this.refine === et.ADD || s;
    if (n && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === Oe.UNLOADED)
      return -1;
    const r = this.parent, o = r && (!n || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, a = e.root ? e.root._screenSpaceError : 0;
    return Math.max(a - o, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = Oe.LOADING;
    const s = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!s)
      return this.contentState = Oe.UNLOADED, !1;
    try {
      const n = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, i = {
        ...this.tileset.loadOptions,
        [r.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[r.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(r.id)
        }
      };
      return this.content = await $t(n, r, i), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = Oe.READY, this._onContentLoaded(), !0;
    } catch (n) {
      throw this.contentState = Oe.FAILED, n;
    } finally {
      s.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = Oe.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, s) {
    if (this._frameNumber === e.frameNumber)
      return;
    const n = this.parent, r = n ? n._visibilityPlaneMask : ke.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const i = n ? n.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(i);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, r), this._visible = this._visibilityPlaneMask !== ke.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = s;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, s) {
    const { cullingVolume: n } = e, { boundingVolume: r } = this;
    return n.computeVisibilityWithPlaneMask(r, s);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const s = this.boundingVolume;
    return Math.sqrt(Math.max(s.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera: e }) {
    const s = this.boundingVolume;
    return ff.subVectors(s.center, e.position), e.direction.dot(ff);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const s = this._viewerRequestVolume;
    return !s || s.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (uO(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = Oe.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new W(e.transform) : new W();
    const s = this.parent, n = this.tileset, r = s && s.computedTransform ? s.computedTransform.clone() : n.modelMatrix.clone();
    this.computedTransform = new W(r).multiplyRight(this.transform);
    const i = s && s._initialTransform ? s._initialTransform.clone() : new W();
    this._initialTransform = new W(i).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = { _tileset: this.tileset, _tile: this }, this.hasEmptyContent = !0, this.contentState = Oe.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = ke.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || et.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = Yo(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const s = e.content;
    s && (s.boundingVolume && (this._contentBoundingVolume = Yo(s.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = Yo(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(e = new W()) {
    const s = e.clone().multiplyRight(this.transform);
    s.equals(this.computedTransform) || (this.computedTransform = s, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return lO(this.tileset.tileset);
    }
  }
}
class fO extends ji {
  compareDistanceToCamera(e, s) {
    return s._distanceToCamera === 0 && e._distanceToCamera === 0 ? s._centerZDepth - e._centerZDepth : s._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, s) {
    if (super.updateTileVisibility(e, s), !e.isVisibleAndInRequestVolume)
      return;
    const n = e.children.length > 0;
    if (e.hasTilesetContent && n) {
      const o = e.children[0];
      this.updateTileVisibility(o, s), e._visible = o._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, s)) {
      e._visible = !1;
      return;
    }
    const r = e.refine === et.REPLACE, i = e._optimChildrenWithinParent === JP.USE_OPTIMIZATION;
    if (r && i && n && !this.anyChildrenVisible(e, s)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, s) {
    const { parent: n } = e;
    return !n || n.hasTilesetContent || n.refine !== et.ADD ? !1 : !this.shouldRefine(e, s, !0);
  }
}
class dO {
  frameNumberMap = /* @__PURE__ */ new Map();
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, s) {
    const n = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), r = n.get(s) || 0;
    n.set(s, r + 1), this.frameNumberMap.set(e, n);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, s) {
    const n = this.frameNumberMap.get(e);
    if (!n)
      return;
    const r = n.get(s) || 1;
    n.set(s, r - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, s) {
    return (this.frameNumberMap.get(e)?.get(s) || 0) === 0;
  }
}
const Zo = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class pO {
  _statusMap;
  pendingTilesRegister = new dO();
  constructor() {
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, s, n, r) {
    if (!this._statusMap[s]) {
      const { frameNumber: i, viewport: { id: o } } = r;
      this._statusMap[s] = { request: e, callback: n, key: s, frameState: r, status: Zo.REQUESTED }, this.pendingTilesRegister.register(o, i), e().then((a) => {
        this._statusMap[s].status = Zo.COMPLETED;
        const { frameNumber: c, viewport: { id: l } } = this._statusMap[s].frameState;
        this.pendingTilesRegister.deregister(l, c), this._statusMap[s].callback(a, r);
      }).catch((a) => {
        this._statusMap[s].status = Zo.ERROR;
        const { frameNumber: c, viewport: { id: l } } = this._statusMap[s].frameState;
        this.pendingTilesRegister.deregister(l, c), n(a);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, s) {
    if (this._statusMap[e]) {
      const { frameNumber: n, viewport: { id: r } } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(r, n);
      const { frameNumber: i, viewport: { id: o } } = s;
      this.pendingTilesRegister.register(o, i), this._statusMap[e].frameState = s;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, s) {
    return !this.pendingTilesRegister.isZero(e, s);
  }
}
class _O extends ji {
  _tileManager;
  constructor(e) {
    super(e), this._tileManager = new pO();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, s) {
    return e._lodJudge = cO(e, s), e._lodJudge === "DIG";
  }
  updateChildTiles(e, s) {
    const n = e.header.children || [], r = e.children, i = e.tileset;
    for (const o of n) {
      const a = `${o.id}-${s.viewport.id}`, c = r && r.find((l) => l.id === a);
      if (c)
        c && this.updateTile(c, s);
      else {
        let l = () => this._loadTile(o.id, i);
        this._tileManager.find(a) ? this._tileManager.update(a, s) : (i.tileset.nodePages && (l = () => i.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(l, a, (u) => this._onTileLoad(u, e, a), s));
      }
    }
    return !1;
  }
  async _loadTile(e, s) {
    const { loader: n } = s, r = s.getTileUrl(`${s.url}/nodes/${e}`), i = {
      ...s.loadOptions,
      i3s: {
        ...s.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await $t(r, n, i);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(e, s, n) {
    const r = new $a(s.tileset, e, s, n);
    s.children.push(r);
    const i = this._tileManager.find(r.id).frameState;
    this.updateTile(r, i), this._frameNumber === i.frameNumber && (this.traversalFinished(i) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, i);
  }
}
const gO = {
  description: "",
  ellipsoid: ne.WGS84,
  modelMatrix: new W(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (t) => t,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
}, Kr = "Tiles In Tileset(s)", Qo = "Tiles In Memory", df = "Tiles In View", pf = "Tiles To Render", _f = "Tiles Loaded", ea = "Tiles Loading", gf = "Tiles Unloaded", mf = "Failed Tile Loads", Af = "Points/Vertices", ta = "Tile Memory Use", Tf = "Maximum Screen Space Error";
class mO {
  // props: Tileset3DProps;
  options;
  loadOptions;
  type;
  tileset;
  loader;
  url;
  basePath;
  modelMatrix;
  ellipsoid;
  lodMetricType;
  lodMetricValue;
  refine;
  root = null;
  roots = {};
  /** @todo any->unknown */
  asset = {};
  // Metadata for the entire tileset
  description = "";
  properties;
  extras = null;
  attributions = {};
  credits = {};
  stats;
  /** flags that contain information about data types in nested tiles */
  contentFormats = { draco: !1, meshopt: !1, dds: !1, ktx2: !1 };
  // view props
  cartographicCenter = null;
  cartesianCenter = null;
  zoom = 1;
  boundingVolume = null;
  /** Updated based on the camera position and direction */
  dynamicScreenSpaceErrorComputedDensity = 0;
  // METRICS
  /**
   * The maximum amount of GPU memory (in MB) that may be used to cache tiles
   * Tiles not in view are unloaded to enforce private
   */
  maximumMemoryUsage = 32;
  /** The total amount of GPU memory in bytes used by the tileset. */
  gpuMemoryUsageInBytes = 0;
  /**
   * If loading the level of detail required by maximumScreenSpaceError
   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
   * will instead use this (larger) adjusted screen space error to achieve the
   * best possible visual quality within the available memory.
   */
  memoryAdjustedScreenSpaceError = 0;
  _cacheBytes = 0;
  _cacheOverflowBytes = 0;
  /** Update tracker. increase in each update cycle. */
  _frameNumber = 0;
  _queryParams = {};
  _extensionsUsed = [];
  _tiles = {};
  /** counter for tracking tiles requests */
  _pendingCount = 0;
  /** Hold traversal results */
  selectedTiles = [];
  // TRAVERSAL
  traverseCounter = 0;
  geometricError = 0;
  lastUpdatedVieports = null;
  _requestedTiles = [];
  _emptyTiles = [];
  frameStateData = {};
  _traverser;
  _cache = new VP();
  _requestScheduler;
  // Promise tracking
  updatePromise = null;
  tilesetInitializationPromise;
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, s) {
    this.options = { ...gO, ...s }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || tc(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new Om({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new hn({ id: this.url }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = { ...this.options, ...e };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let n = e;
    return this.queryParams.length && (n = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), n;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(e = null) {
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(e = null) {
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((s) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), s(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const s = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = s.length;
    const n = [];
    for (const r of s) {
      const i = r.id;
      this._needTraverse(i) ? n.push(i) : this.traverseCounter--;
    }
    for (const r of s) {
      const i = r.id;
      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !n.includes(i))
        continue;
      const o = zP(r, this._frameNumber);
      this._traverser.traverse(this.roots[i], o, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let s = e;
    return this.options.viewportTraversersMap && (s = this.options.viewportTraversersMap[e]), s === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const s = e.viewport.id;
    this.frameStateData[s] || (this.frameStateData[s] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });
    const n = this.frameStateData[s], r = Object.values(this._traverser.selectedTiles), [i, o] = jP(r, e, this.options.maximumTilesSelected);
    n.selectedTiles = i;
    for (const a of o)
      a.unselect();
    n._requestedTiles = Object.values(this._traverser.requestedTiles), n._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const s = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(s.selectedTiles), this._requestedTiles = this._requestedTiles.concat(s._requestedTiles), this._emptyTiles = this._emptyTiles.concat(s._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, s) {
    if (e.length !== s.length)
      return !0;
    const n = new Set(e.map((o) => o.id)), r = new Set(s.map((o) => o.id));
    let i = e.filter((o) => !r.has(o.id)).length > 0;
    return i = i || s.filter((o) => !n.has(o.id)).length > 0, i;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, s) => e._unloadTile(s));
  }
  _updateStats() {
    let e = 0, s = 0;
    for (const n of this.selectedTiles)
      n.contentAvailable && n.content && (e++, n.content.pointCount ? s += n.content.pointCount : s += n.content.vertexCount);
    this.stats.get(df).count = this.selectedTiles.length, this.stats.get(pf).count = e, this.stats.get(Af).count = s, this.stats.get(Tf).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === Ie.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === Ie.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === Ie.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    const e = this.tileset.fullExtent;
    if (e) {
      const { xmin: n, xmax: r, ymin: i, ymax: o, zmin: a, zmax: c } = e;
      this.cartographicCenter = new S(n + (r - n) / 2, i + (o - i) / 2, a + (c - a) / 2), this.cartesianCenter = new S(), ne.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = S_(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const s = this.tileset.store?.extent;
    if (s) {
      const [n, r, i, o] = s;
      this.cartographicCenter = new S(n + (i - n) / 2, r + (o - r) / 2, 0), this.cartesianCenter = new S(), ne.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = KP(s, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new S(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, { center: s } = e.boundingVolume;
    if (!s) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new S(), this.zoom = 1;
      return;
    }
    s[0] !== 0 || s[1] !== 0 || s[2] !== 0 ? (this.cartographicCenter = new S(), ne.WGS84.cartesianToCartographic(s, this.cartographicCenter)) : this.cartographicCenter = new S(0, 0, -ne.WGS84.radii[0]), this.cartesianCenter = s, this.zoom = $P(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Kr), this.stats.get(ea), this.stats.get(Qo), this.stats.get(df), this.stats.get(pf), this.stats.get(_f), this.stats.get(gf), this.stats.get(mf), this.stats.get(Af), this.stats.get(ta, "memory"), this.stats.get(Tf);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, s) {
    const n = new $a(this, e.root, s);
    if (s && (s.children.push(n), n.depth = s.depth + 1), this.type === Ie.TILES3D) {
      const r = [];
      for (r.push(n); r.length > 0; ) {
        const i = r.pop();
        this.stats.get(Kr).incrementCount();
        const o = i.header.children || [];
        for (const a of o) {
          const c = new $a(this, a, i);
          if (c.contentUrl?.includes("?session=")) {
            const h = new URL(c.contentUrl).searchParams.get("session");
            h && (this._queryParams.session = h);
          }
          i.children.push(c), c.depth = i.depth + 1, r.push(c);
        }
      }
    }
    return n;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case Ie.TILES3D:
        e = fO;
        break;
      case Ie.I3S:
        e = _O;
        break;
      default:
        e = ji;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let s;
    try {
      this._onStartTileLoading(), s = await e.loadContent();
    } catch (n) {
      this._onTileLoadError(e, n instanceof Error ? n : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, s);
    }
  }
  _onTileLoadError(e, s) {
    this.stats.get(mf).incrementCount();
    const n = s.message || s.toString(), r = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${n}`), this.options.onTileError(e, n, r);
  }
  _onTileLoad(e, s) {
    if (s) {
      if (this.type === Ie.I3S) {
        const n = this.tileset?.nodePagesTile?.nodesInNodePages || 0;
        this.stats.get(Kr).reset(), this.stats.get(Kr).addCount(n);
      }
      e && e.content && HP(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    if (this.type === Ie.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === Ie.TILES3D) {
      const { extensionsRemoved: s = [] } = e.content?.gltf || {};
      s.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), s.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), s.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(ea).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(ea).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (s) => s._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(_f).incrementCount(), this.stats.get(Qo).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(ta).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(Qo).decrementCount(), this.stats.get(gf).incrementCount(), this.stats.get(ta).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const s = e.pop();
      for (const n of s.children)
        e.push(n);
      this._destroyTile(s);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const s = e, n = [];
    for (n.push(s); n.length > 0; ) {
      e = n.pop();
      for (const r of e.children)
        n.push(r);
      e !== s && this._destroyTile(e);
    }
    s.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const s = new URLSearchParams(e.queryString), n = Object.fromEntries(s.entries());
      this._queryParams = { ...this._queryParams, ...n };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const M_ = "4.3.1", Mn = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function P_(t, e, s) {
  se(t instanceof ArrayBuffer);
  const n = new TextDecoder("utf8"), r = new Uint8Array(t, e, s);
  return n.decode(r);
}
function AO(t, e = 0) {
  const s = new DataView(t);
  return `${String.fromCharCode(s.getUint8(e + 0))}${String.fromCharCode(s.getUint8(e + 1))}${String.fromCharCode(s.getUint8(e + 2))}${String.fromCharCode(s.getUint8(e + 3))}`;
}
const TO = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, he = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, G = {
  ...TO,
  ...he
}, sa = {
  [he.DOUBLE]: Float64Array,
  [he.FLOAT]: Float32Array,
  [he.UNSIGNED_SHORT]: Uint16Array,
  [he.UNSIGNED_INT]: Uint32Array,
  [he.UNSIGNED_BYTE]: Uint8Array,
  [he.BYTE]: Int8Array,
  [he.SHORT]: Int16Array,
  [he.INT]: Int32Array
}, yO = {
  DOUBLE: he.DOUBLE,
  FLOAT: he.FLOAT,
  UNSIGNED_SHORT: he.UNSIGNED_SHORT,
  UNSIGNED_INT: he.UNSIGNED_INT,
  UNSIGNED_BYTE: he.UNSIGNED_BYTE,
  BYTE: he.BYTE,
  SHORT: he.SHORT,
  INT: he.INT
}, na = "Failed to convert GL type";
class At {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const s in sa)
      if (sa[s] === e)
        return s;
    throw new Error(na);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const s = yO[e];
    if (!s)
      throw new Error(na);
    return s;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case he.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case he.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case he.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const s = sa[e];
        if (!s)
          throw new Error(na);
        return s;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return At.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!At.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, s, n = 0, r) {
    r === void 0 && (r = (s.byteLength - n) / At.getByteSize(e));
    const i = At.getArrayType(e);
    return new i(s, n, r);
  }
}
function bO(t, e) {
  if (!t)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function EO(t, e = [0, 0, 0]) {
  const s = t >> 11 & 31, n = t >> 5 & 63, r = t & 31;
  return e[0] = s << 3, e[1] = n << 2, e[2] = r << 3, e;
}
new yc();
new S();
new yc();
new yc();
function yf(t, e = 255) {
  return wt(t, 0, e) / e * 2 - 1;
}
function bf(t) {
  return t < 0 ? -1 : 1;
}
function CO(t, e, s, n) {
  if (bO(n), t < 0 || t > s || e < 0 || e > s)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${s}`);
  if (n.x = yf(t, s), n.y = yf(e, s), n.z = 1 - (Math.abs(n.x) + Math.abs(n.y)), n.z < 0) {
    const r = n.x;
    n.x = (1 - Math.abs(n.y)) * bf(r), n.y = (1 - Math.abs(r)) * bf(n.y);
  }
  return n.normalize();
}
function SO(t, e, s) {
  return CO(t, e, 255, s);
}
class Zc {
  json;
  buffer;
  featuresLength = 0;
  _cachedTypedArrays = {};
  constructor(e, s) {
    this.json = e, this.buffer = s;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e, s = G.UNSIGNED_INT, n = 1) {
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(e, s, n, 1, r.byteOffset) : r;
  }
  getPropertyArray(e, s, n) {
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? ("componentType" in r && (s = At.fromName(r.componentType)), this._getTypedArrayFromBinary(e, s, n, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(e, s, r);
  }
  getProperty(e, s, n, r, i) {
    const o = this.json[e];
    if (!o)
      return o;
    const a = this.getPropertyArray(e, s, n);
    if (n === 1)
      return a[r];
    for (let c = 0; c < n; ++c)
      i[c] = a[n * r + c];
    return i;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, s, n, r, i) {
    const o = this._cachedTypedArrays;
    let a = o[e];
    return a || (a = At.createTypedArray(s, this.buffer.buffer, this.buffer.byteOffset + i, r * n), o[e] = a), a;
  }
  _getTypedArrayFromArray(e, s, n) {
    const r = this._cachedTypedArrays;
    let i = r[e];
    return i || (i = At.createTypedArray(s, n), r[e] = i), i;
  }
}
const RO = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, wO = {
  SCALAR: (t, e) => t[e],
  VEC2: (t, e) => [t[2 * e + 0], t[2 * e + 1]],
  VEC3: (t, e) => [t[3 * e + 0], t[3 * e + 1], t[3 * e + 2]],
  VEC4: (t, e) => [t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]],
  // TODO: check column major
  MAT2: (t, e) => [
    t[4 * e + 0],
    t[4 * e + 1],
    t[4 * e + 2],
    t[4 * e + 3]
  ],
  MAT3: (t, e) => [
    t[9 * e + 0],
    t[9 * e + 1],
    t[9 * e + 2],
    t[9 * e + 3],
    t[9 * e + 4],
    t[9 * e + 5],
    t[9 * e + 6],
    t[9 * e + 7],
    t[9 * e + 8]
  ],
  MAT4: (t, e) => [
    t[16 * e + 0],
    t[16 * e + 1],
    t[16 * e + 2],
    t[16 * e + 3],
    t[16 * e + 4],
    t[16 * e + 5],
    t[16 * e + 6],
    t[16 * e + 7],
    t[16 * e + 8],
    t[16 * e + 9],
    t[16 * e + 10],
    t[16 * e + 11],
    t[16 * e + 12],
    t[16 * e + 13],
    t[16 * e + 14],
    t[16 * e + 15]
  ]
}, IO = {
  SCALAR: (t, e, s) => {
    e[s] = t;
  },
  VEC2: (t, e, s) => {
    e[2 * s + 0] = t[0], e[2 * s + 1] = t[1];
  },
  VEC3: (t, e, s) => {
    e[3 * s + 0] = t[0], e[3 * s + 1] = t[1], e[3 * s + 2] = t[2];
  },
  VEC4: (t, e, s) => {
    e[4 * s + 0] = t[0], e[4 * s + 1] = t[1], e[4 * s + 2] = t[2], e[4 * s + 3] = t[3];
  },
  // TODO: check column major correctness
  MAT2: (t, e, s) => {
    e[4 * s + 0] = t[0], e[4 * s + 1] = t[1], e[4 * s + 2] = t[2], e[4 * s + 3] = t[3];
  },
  MAT3: (t, e, s) => {
    e[9 * s + 0] = t[0], e[9 * s + 1] = t[1], e[9 * s + 2] = t[2], e[9 * s + 3] = t[3], e[9 * s + 4] = t[4], e[9 * s + 5] = t[5], e[9 * s + 6] = t[6], e[9 * s + 7] = t[7], e[9 * s + 8] = t[8], e[9 * s + 9] = t[9];
  },
  MAT4: (t, e, s) => {
    e[16 * s + 0] = t[0], e[16 * s + 1] = t[1], e[16 * s + 2] = t[2], e[16 * s + 3] = t[3], e[16 * s + 4] = t[4], e[16 * s + 5] = t[5], e[16 * s + 6] = t[6], e[16 * s + 7] = t[7], e[16 * s + 8] = t[8], e[16 * s + 9] = t[9], e[16 * s + 10] = t[10], e[16 * s + 11] = t[11], e[16 * s + 12] = t[12], e[16 * s + 13] = t[13], e[16 * s + 14] = t[14], e[16 * s + 15] = t[15];
  }
};
function vO(t, e, s, n) {
  const { componentType: r } = t;
  se(t.componentType);
  const i = typeof r == "string" ? At.fromName(r) : r, o = RO[t.type], a = wO[t.type], c = IO[t.type];
  return s += t.byteOffset, {
    values: At.createTypedArray(i, e, s, o * n),
    type: i,
    size: o,
    unpacker: a,
    packer: c
  };
}
const gt = (t) => t !== void 0;
function BO(t, e, s) {
  if (!e)
    return null;
  let n = t.getExtension("3DTILES_batch_table_hierarchy");
  const r = e.HIERARCHY;
  return r && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = r, n = r), n ? MO(n, s) : null;
}
function MO(t, e) {
  let s, n, r;
  const i = t.instancesLength, o = t.classes;
  let a = t.classIds, c = t.parentCounts, l = t.parentIds, h = i;
  gt(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(e.buffer, e.byteOffset + a.byteOffset, i));
  let u;
  if (gt(c))
    for (gt(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(e.buffer, e.byteOffset + c.byteOffset, i)), u = new Uint16Array(i), h = 0, s = 0; s < i; ++s)
      u[s] = h, h += c[s];
  gt(l) && gt(l.byteOffset) && (l.componentType = defaultValue(l.componentType, GL.UNSIGNED_SHORT), l.type = AttributeType.SCALAR, r = getBinaryAccessor(l), l = r.createArrayBufferView(e.buffer, e.byteOffset + l.byteOffset, h));
  const f = o.length;
  for (s = 0; s < f; ++s) {
    const E = o[s].length, C = o[s].instances, w = getBinaryProperties(E, C, e);
    o[s].instances = combine(w, C);
  }
  const p = new Array(f).fill(0), m = new Uint16Array(i);
  for (s = 0; s < i; ++s)
    n = a[s], m[s] = p[n], ++p[n];
  const A = {
    classes: o,
    classIds: a,
    classIndexes: m,
    parentCounts: c,
    parentIndexes: u,
    parentIds: l
  };
  return xO(A), A;
}
function Pn(t, e, s) {
  if (!t)
    return;
  const n = t.parentCounts;
  return t.parentIds ? s(t, e) : n > 0 ? PO(t, e, s) : OO(t, e, s);
}
function PO(t, e, s) {
  const n = t.classIds, r = t.parentCounts, i = t.parentIds, o = t.parentIndexes, a = n.length, c = scratchVisited;
  c.length = Math.max(c.length, a);
  const l = ++marker, h = scratchStack;
  for (h.length = 0, h.push(e); h.length > 0; ) {
    if (e = h.pop(), c[e] === l)
      continue;
    c[e] = l;
    const u = s(t, e);
    if (gt(u))
      return u;
    const f = r[e], p = o[e];
    for (let m = 0; m < f; ++m) {
      const A = i[p + m];
      A !== e && h.push(A);
    }
  }
  return null;
}
function OO(t, e, s) {
  let n = !0;
  for (; n; ) {
    const r = s(t, e);
    if (gt(r))
      return r;
    const i = t.parentIds[e];
    n = i !== e, e = i;
  }
  throw new Error("traverseHierarchySingleParent");
}
function xO(t) {
  const s = t.classIds.length;
  for (let n = 0; n < s; ++n)
    O_(t, n, stack);
}
function O_(t, e, s) {
  const n = t.parentCounts, r = t.parentIds, i = t.parentIndexes, a = t.classIds.length;
  if (!gt(r))
    return;
  assert(e < a, `Parent index ${e} exceeds the total number of instances: ${a}`), assert(s.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), s.push(e);
  const c = gt(n) ? n[e] : 1, l = gt(n) ? i[e] : e;
  for (let h = 0; h < c; ++h) {
    const u = r[l + h];
    u !== e && O_(t, u, s);
  }
  s.pop(e);
}
function we(t) {
  return t != null;
}
const Yr = (t, e) => t, NO = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class x_ {
  json;
  binary;
  featureCount;
  _extensions;
  // Copy all top-level property fields from the json object, ignoring special fields
  _properties;
  _binaryProperties;
  // TODO: hierarchy support is only partially implemented and not tested
  _hierarchy;
  constructor(e, s, n, r = {}) {
    se(n >= 0), this.json = e || {}, this.binary = s, this.featureCount = n, this._extensions = this.json?.extensions || {}, this._properties = {};
    for (const i in this.json)
      NO[i] || (this._properties[i] = this.json[i]);
    this._binaryProperties = this._initializeBinaryProperties(), r["3DTILES_batch_table_hierarchy"] && (this._hierarchy = BO(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, s) {
    if (this._checkBatchId(e), se(typeof s == "string", s), this._hierarchy) {
      const n = Pn(this._hierarchy, e, (r, i) => {
        const o = r.classIds[i];
        return r.classes[o].name === s;
      });
      return we(n);
    }
    return !1;
  }
  isExactClass(e, s) {
    return se(typeof s == "string", s), this.getExactClassName(e) === s;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const s = this._hierarchy.classIds[e];
      return this._hierarchy.classes[s].name;
    }
  }
  hasProperty(e, s) {
    return this._checkBatchId(e), se(typeof s == "string", s), we(this._properties[s]) || this._hasPropertyInHierarchy(e, s);
  }
  getPropertyNames(e, s) {
    this._checkBatchId(e), s = we(s) ? s : [], s.length = 0;
    const n = Object.keys(this._properties);
    return s.push(...n), this._hierarchy && this._getPropertyNamesInHierarchy(e, s), s;
  }
  getProperty(e, s) {
    if (this._checkBatchId(e), se(typeof s == "string", s), this._binaryProperties) {
      const r = this._binaryProperties[s];
      if (we(r))
        return this._getBinaryProperty(r, e);
    }
    const n = this._properties[s];
    if (we(n))
      return Yr(n[e]);
    if (this._hierarchy) {
      const r = this._getHierarchyProperty(e, s);
      if (we(r))
        return r;
    }
  }
  setProperty(e, s, n) {
    const r = this.featureCount;
    if (this._checkBatchId(e), se(typeof s == "string", s), this._binaryProperties) {
      const o = this._binaryProperties[s];
      if (o) {
        this._setBinaryProperty(o, e, n);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, s, n))
      return;
    let i = this._properties[s];
    we(i) || (this._properties[s] = new Array(r), i = this._properties[s]), i[e] = Yr(n);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, s) {
    return e.unpack(e.typedArray, s);
  }
  _setBinaryProperty(e, s, n) {
    e.pack(n, e.typedArray, s);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const s in this._properties) {
      const n = this._properties[s], r = this._initializeBinaryProperty(s, n);
      r && (e = e || {}, e[s] = r);
    }
    return e;
  }
  _initializeBinaryProperty(e, s) {
    if ("byteOffset" in s) {
      const n = s;
      se(this.binary, `Property ${e} requires a batch table binary.`), se(n.type, `Property ${e} requires a type.`);
      const r = vO(n, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: r.values,
        componentCount: r.size,
        unpack: r.unpacker,
        pack: r.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, s) {
    if (!this._hierarchy)
      return !1;
    const n = Pn(this._hierarchy, e, (r, i) => {
      const o = r.classIds[i], a = r.classes[o].instances;
      return we(a[s]);
    });
    return we(n);
  }
  _getPropertyNamesInHierarchy(e, s) {
    Pn(this._hierarchy, e, (n, r) => {
      const i = n.classIds[r], o = n.classes[i].instances;
      for (const a in o)
        o.hasOwnProperty(a) && s.indexOf(a) === -1 && s.push(a);
    });
  }
  _getHierarchyProperty(e, s) {
    return Pn(this._hierarchy, e, (n, r) => {
      const i = n.classIds[r], o = n.classes[i], a = n.classIndexes[r], c = o.instances[s];
      return we(c) ? we(c.typedArray) ? this._getBinaryProperty(c, a) : Yr(c[a]) : null;
    });
  }
  _setHierarchyProperty(e, s, n, r) {
    const i = Pn(this._hierarchy, s, (o, a) => {
      const c = o.classIds[a], l = o.classes[c], h = o.classIndexes[a], u = l.instances[n];
      return we(u) ? (se(a === s, `Inherited property "${n}" is read-only.`), we(u.typedArray) ? this._setBinaryProperty(u, h, r) : u[h] = Yr(r), !0) : !1;
    });
    return we(i);
  }
}
const ra = 4;
function Wi(t, e, s = 0) {
  const n = new DataView(e);
  if (t.magic = n.getUint32(s, !0), s += ra, t.version = n.getUint32(s, !0), s += ra, t.byteLength = n.getUint32(s, !0), s += ra, t.version !== 1)
    throw new Error(`3D Tile Version ${t.version} not supported`);
  return s;
}
const Ns = 4, Ef = "b3dm tile in legacy format.";
function Qc(t, e, s) {
  const n = new DataView(e);
  let r;
  t.header = t.header || {};
  let i = n.getUint32(s, !0);
  s += Ns;
  let o = n.getUint32(s, !0);
  s += Ns;
  let a = n.getUint32(s, !0);
  s += Ns;
  let c = n.getUint32(s, !0);
  return s += Ns, a >= 570425344 ? (s -= Ns * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(Ef)) : c >= 570425344 && (s -= Ns, r = a, a = i, c = o, i = 0, o = 0, console.warn(Ef)), t.header.featureTableJsonByteLength = i, t.header.featureTableBinaryByteLength = o, t.header.batchTableJsonByteLength = a, t.header.batchTableBinaryByteLength = c, t.header.batchLength = r, s;
}
function el(t, e, s, n) {
  return s = FO(t, e, s), s = DO(t, e, s), s;
}
function FO(t, e, s, n) {
  const { featureTableJsonByteLength: r, featureTableBinaryByteLength: i, batchLength: o } = t.header || {};
  if (t.featureTableJson = {
    BATCH_LENGTH: o || 0
  }, r && r > 0) {
    const a = P_(e, s, r);
    t.featureTableJson = JSON.parse(a);
  }
  return s += r || 0, t.featureTableBinary = new Uint8Array(e, s, i), s += i || 0, s;
}
function DO(t, e, s, n) {
  const { batchTableJsonByteLength: r, batchTableBinaryByteLength: i } = t.header || {};
  if (r && r > 0) {
    const o = P_(e, s, r);
    t.batchTableJson = JSON.parse(o), s += r, i && i > 0 && (t.batchTableBinary = new Uint8Array(e, s, i), t.batchTableBinary = new Uint8Array(t.batchTableBinary), s += i);
  }
  return s;
}
function N_(t, e, s) {
  if (!e && (!t || !t.batchIds || !s))
    return null;
  const { batchIds: n, isRGB565: r, pointCount: i = 0 } = t;
  if (n && s) {
    const o = new Uint8ClampedArray(i * 3);
    for (let a = 0; a < i; a++) {
      const c = n[a], h = s.getProperty(c, "dimensions").map((u) => u * 255);
      o[a * 3] = h[0], o[a * 3 + 1] = h[1], o[a * 3 + 2] = h[2];
    }
    return {
      type: G.UNSIGNED_BYTE,
      value: o,
      size: 3,
      normalized: !0
    };
  }
  if (e && r) {
    const o = new Uint8ClampedArray(i * 3);
    for (let a = 0; a < i; a++) {
      const c = EO(e[a]);
      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];
    }
    return {
      type: G.UNSIGNED_BYTE,
      value: o,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === i * 3 ? {
    type: G.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: G.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const Cf = new S();
function UO(t, e) {
  if (!e)
    return null;
  if (t.isOctEncoded16P) {
    const s = new Float32Array((t.pointsLength || 0) * 3);
    for (let n = 0; n < (t.pointsLength || 0); n++)
      SO(e[n * 2], e[n * 2 + 1], Cf), Cf.toArray(s, n * 3);
    return {
      type: G.FLOAT,
      size: 2,
      value: s
    };
  }
  return {
    type: G.FLOAT,
    size: 2,
    value: e
  };
}
function LO(t, e, s) {
  return t.isQuantized ? s["3d-tiles"] && s["3d-tiles"].decodeQuantizedPositions ? (t.isQuantized = !1, kO(t, e)) : {
    type: G.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function kO(t, e) {
  const s = new S(), n = new Float32Array(t.pointCount * 3);
  for (let r = 0; r < t.pointCount; r++)
    s.set(e[r * 3], e[r * 3 + 1], e[r * 3 + 2]).scale(1 / t.quantizedRange).multiply(t.quantizedVolumeScale).add(t.quantizedVolumeOffset).toArray(n, r * 3);
  return n;
}
async function VO(t, e, s, n, r) {
  s = Wi(t, e, s), s = Qc(t, e, s), s = el(t, e, s), HO(t);
  const { featureTable: i, batchTable: o } = zO(t);
  return await $O(t, i, o, n, r), jO(t, i, n), WO(t, i, o), XO(t, i), s;
}
function HO(t) {
  t.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, t.isQuantized = !1, t.isTranslucent = !1, t.isRGB565 = !1, t.isOctEncoded16P = !1;
}
function zO(t) {
  const e = new Zc(t.featureTableJson, t.featureTableBinary), s = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(s))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = s, t.featuresLength = s, t.pointsLength = s, t.pointCount = s, t.rtcCenter = e.getGlobalProperty("RTC_CENTER", G.FLOAT, 3);
  const n = GO(t, e);
  return { featureTable: e, batchTable: n };
}
function jO(t, e, s) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.positions) {
    if (e.hasProperty("POSITION"))
      t.attributes.positions = e.getPropertyArray("POSITION", G.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const n = e.getPropertyArray("POSITION_QUANTIZED", G.UNSIGNED_SHORT, 3);
      if (t.isQuantized = !0, t.quantizedRange = 65535, t.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", G.FLOAT, 3), !t.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (t.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", G.FLOAT, 3), !t.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      t.attributes.positions = LO(t, n, s);
    }
  }
  if (!t.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function WO(t, e, s) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.colors) {
    let n = null;
    e.hasProperty("RGBA") ? (n = e.getPropertyArray("RGBA", G.UNSIGNED_BYTE, 4), t.isTranslucent = !0) : e.hasProperty("RGB") ? n = e.getPropertyArray("RGB", G.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (n = e.getPropertyArray("RGB565", G.UNSIGNED_SHORT, 1), t.isRGB565 = !0), t.attributes.colors = N_(t, n, s);
  }
  e.hasProperty("CONSTANT_RGBA") && (t.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", G.UNSIGNED_BYTE, 4));
}
function XO(t, e) {
  if (t.attributes = t.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !t.attributes.normals) {
    let s = null;
    e.hasProperty("NORMAL") ? s = e.getPropertyArray("NORMAL", G.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (s = e.getPropertyArray("NORMAL_OCT16P", G.UNSIGNED_BYTE, 2), t.isOctEncoded16P = !0), t.attributes.normals = UO(t, s);
  }
}
function GO(t, e) {
  let s = null;
  if (!t.batchIds && e.hasProperty("BATCH_ID") && (t.batchIds = e.getPropertyArray("BATCH_ID", G.UNSIGNED_SHORT, 1), t.batchIds)) {
    const n = e.getGlobalProperty("BATCH_LENGTH");
    if (!n)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const { batchTableJson: r, batchTableBinary: i } = t;
    s = new x_(r, i, n);
  }
  return s;
}
async function $O(t, e, s, n, r) {
  let i, o, a;
  const c = t.batchTableJson && t.batchTableJson.extensions && t.batchTableJson.extensions["3DTILES_draco_point_compression"];
  c && (a = c.properties);
  const l = e.getExtension("3DTILES_draco_point_compression");
  if (l) {
    o = l.properties;
    const u = l.byteOffset, f = l.byteLength;
    if (!o || !Number.isFinite(u) || !f)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    i = (t.featureTableBinary || []).slice(u, u + f), t.hasPositions = Number.isFinite(o.POSITION), t.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), t.hasNormals = Number.isFinite(o.NORMAL), t.hasBatchIds = Number.isFinite(o.BATCH_ID), t.isTranslucent = Number.isFinite(o.RGBA);
  }
  if (!i)
    return !0;
  const h = {
    buffer: i,
    properties: { ...o, ...a },
    batchTableProperties: a
  };
  return await KO(t, h, n, r);
}
async function KO(t, e, s, n) {
  if (!n)
    return;
  const r = {
    ...s,
    draco: {
      ...s?.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete r["3d-tiles"];
  const i = await sr(e.buffer, A_, r, n), o = i.attributes.POSITION && i.attributes.POSITION.value, a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value, c = i.attributes.NORMAL && i.attributes.NORMAL.value, l = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value, h = o && i.attributes.POSITION.value.quantization, u = c && i.attributes.NORMAL.value.quantization;
  if (h) {
    const p = i.POSITION.data.quantization, m = p.range;
    t.quantizedVolumeScale = new S(m, m, m), t.quantizedVolumeOffset = new S(p.minValues), t.quantizedRange = (1 << p.quantizationBits) - 1, t.isQuantizedDraco = !0;
  }
  u && (t.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, t.isOctEncodedDraco = !0);
  const f = {};
  if (e.batchTableProperties)
    for (const p of Object.keys(e.batchTableProperties))
      i.attributes[p] && i.attributes[p].value && (f[p.toLowerCase()] = i.attributes[p].value);
  t.attributes = {
    // @ts-expect-error
    positions: o,
    // @ts-expect-error
    colors: N_(t, a, void 0),
    // @ts-expect-error
    normals: c,
    // @ts-expect-error
    batchIds: l,
    ...f
  };
}
const Ka = {
  URI: 0,
  EMBEDDED: 1
};
function F_(t, e, s, n) {
  t.rotateYtoZ = !0;
  const r = (t.byteOffset || 0) + (t.byteLength || 0) - s;
  if (r === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return t.gltfUpAxis = n?.["3d-tiles"] && n["3d-tiles"].assetGltfUpAxis ? n["3d-tiles"].assetGltfUpAxis : "Y", t.gltfArrayBuffer = ec(e, s, r), t.gltfByteOffset = 0, t.gltfByteLength = r, s % 4 === 0 || console.warn(`${t.type}: embedded glb is not aligned to a 4-byte boundary.`), (t.byteOffset || 0) + (t.byteLength || 0);
}
async function D_(t, e, s, n) {
  const r = s?.["3d-tiles"] || {};
  if (YO(t, e), r.loadGLTF) {
    if (!n)
      return;
    if (t.gltfUrl) {
      const { fetch: i } = n, o = await i(t.gltfUrl, s);
      t.gltfArrayBuffer = await o.arrayBuffer(), t.gltfByteOffset = 0;
    }
    if (t.gltfArrayBuffer) {
      const i = await sr(t.gltfArrayBuffer, er, s, n);
      t.gltf = Yc(i), t.gpuMemoryUsageInBytes = c_(t.gltf), delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
    }
  }
}
function YO(t, e, s) {
  switch (e) {
    case Ka.URI:
      if (t.gltfArrayBuffer) {
        const n = new Uint8Array(t.gltfArrayBuffer, t.gltfByteOffset), i = new TextDecoder().decode(n);
        t.gltfUrl = i.replace(/[\s\0]+$/, "");
      }
      delete t.gltfArrayBuffer, delete t.gltfByteOffset, delete t.gltfByteLength;
      break;
    case Ka.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function JO(t, e, s, n, r) {
  s = qO(t, e, s, n), await D_(t, Ka.EMBEDDED, n, r);
  const i = t?.gltf?.extensions;
  return i && i.CESIUM_RTC && (t.rtcCenter = i.CESIUM_RTC.center), s;
}
function qO(t, e, s, n, r) {
  s = Wi(t, e, s), s = Qc(t, e, s), s = el(t, e, s), s = F_(t, e, s, n);
  const i = new Zc(t.featureTableJson, t.featureTableBinary);
  return t.rtcCenter = i.getGlobalProperty("RTC_CENTER", G.FLOAT, 3), s;
}
async function ZO(t, e, s, n, r) {
  return s = QO(t, e, s, n), await D_(t, t.gltfFormat || 0, n, r), s;
}
function QO(t, e, s, n, r) {
  if (s = Wi(t, e, s), t.version !== 1)
    throw new Error(`Instanced 3D Model version ${t.version} is not supported`);
  s = Qc(t, e, s);
  const i = new DataView(e);
  if (t.gltfFormat = i.getUint32(s, !0), s += 4, s = el(t, e, s), s = F_(t, e, s, n), !t?.header?.featureTableJsonByteLength || t.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const o = new Zc(t.featureTableJson, t.featureTableBinary), a = o.getGlobalProperty("INSTANCES_LENGTH");
  if (o.featuresLength = a, !Number.isFinite(a))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  t.eastNorthUp = o.getGlobalProperty("EAST_NORTH_UP"), t.rtcCenter = o.getGlobalProperty("RTC_CENTER", G.FLOAT, 3);
  const c = new x_(t.batchTableJson, t.batchTableBinary, a);
  return ex(t, o, c, a), s;
}
function ex(t, e, s, n) {
  const r = new Array(n), i = new S();
  new S(), new S(), new S();
  const o = new ae(), a = new $n(), c = new S(), l = {}, h = new W(), u = [], f = [], p = [], m = [];
  for (let A = 0; A < n; A++) {
    let E;
    if (e.hasProperty("POSITION"))
      E = e.getProperty("POSITION", G.FLOAT, 3, A, i);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      E = e.getProperty("POSITION_QUANTIZED", G.UNSIGNED_SHORT, 3, A, i);
      const N = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", G.FLOAT, 3);
      if (!N)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const L = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", G.FLOAT, 3);
      if (!L)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const k = 65535;
      for (let F = 0; F < 3; F++)
        E[F] = E[F] / k * L[F] + N[F];
    }
    if (!E)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (i.copy(E), l.translation = i, t.normalUp = e.getProperty("NORMAL_UP", G.FLOAT, 3, A, u), t.normalRight = e.getProperty("NORMAL_RIGHT", G.FLOAT, 3, A, f), t.normalUp) {
      if (!t.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      t.hasCustomOrientation = !0;
    } else {
      if (t.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", G.UNSIGNED_SHORT, 2, A, u), t.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", G.UNSIGNED_SHORT, 2, A, f), t.octNormalUp)
        throw t.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      t.eastNorthUp ? (ne.WGS84.eastNorthUpToFixedFrame(i, h), h.getRotationMatrix3(o)) : o.identity();
    }
    a.fromMatrix3(o), l.rotation = a, c.set(1, 1, 1);
    const C = e.getProperty("SCALE", G.FLOAT, 1, A, p);
    Number.isFinite(C) && c.multiplyByScalar(C);
    const w = e.getProperty("SCALE_NON_UNIFORM", G.FLOAT, 3, A, u);
    w && c.scale(w), l.scale = c;
    let I = e.getProperty("BATCH_ID", G.UNSIGNED_SHORT, 1, A, m);
    I === void 0 && (I = A);
    const B = new W().fromQuaternion(l.rotation);
    h.identity(), h.translate(l.translation), h.multiplyRight(B), h.scale(l.scale);
    const x = h.clone();
    r[A] = {
      modelMatrix: x,
      batchId: I
    };
  }
  t.instances = r;
}
async function tx(t, e, s, n, r, i) {
  s = Wi(t, e, s);
  const o = new DataView(e);
  for (t.tilesLength = o.getUint32(s, !0), s += 4, t.tiles = []; t.tiles.length < t.tilesLength && (t.byteLength || 0) - s > 12; ) {
    const a = { shape: "tile3d" };
    t.tiles.push(a), s = await i(e, s, n, r, a);
  }
  return s;
}
async function sx(t, e, s, n) {
  if (t.rotateYtoZ = !0, t.gltfUpAxis = s?.["3d-tiles"]?.assetGltfUpAxis ? s["3d-tiles"].assetGltfUpAxis : "Y", s?.["3d-tiles"]?.loadGLTF) {
    if (!n)
      return e.byteLength;
    const r = await sr(e, er, s, n);
    t.gltf = Yc(r), t.gpuMemoryUsageInBytes = c_(t.gltf);
  } else
    t.gltfArrayBuffer = e;
  return e.byteLength;
}
async function U_(t, e = 0, s, n, r = { shape: "tile3d" }) {
  switch (r.byteOffset = e, r.type = AO(t, e), r.type) {
    case Mn.COMPOSITE:
      return await tx(r, t, e, s, n, U_);
    case Mn.BATCHED_3D_MODEL:
      return await JO(r, t, e, s, n);
    case Mn.GLTF:
      return await sx(r, t, s, n);
    case Mn.INSTANCED_3D_MODEL:
      return await ZO(r, t, e, s, n);
    case Mn.POINT_CLOUD:
      return await VO(r, t, e, s, n);
    default:
      throw new Error(`3DTileLoader: unknown type ${r.type}`);
  }
}
const nx = 1952609651, rx = 1;
async function ix(t, e, s) {
  if (new Uint32Array(t.slice(0, 4))[0] !== nx)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(t.slice(4, 8))[0] !== rx)
    throw new Error("Wrong subtree file verson, must be 1");
  const i = Sf(t.slice(8, 16)), o = new Uint8Array(t, 24, i), c = new TextDecoder("utf8").decode(o), l = JSON.parse(c), h = Sf(t.slice(16, 24));
  let u = new ArrayBuffer(0);
  if (h && (u = t.slice(24 + i)), await Jr(l, l.tileAvailability, u, s), Array.isArray(l.contentAvailability))
    for (const f of l.contentAvailability)
      await Jr(l, f, u, s);
  else
    await Jr(l, l.contentAvailability, u, s);
  return await Jr(l, l.childSubtreeAvailability, u, s), l;
}
async function Jr(t, e, s, n) {
  const r = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof r != "number")
    return;
  const i = t.bufferViews[r], o = t.buffers[i.buffer];
  if (!n?.baseUrl)
    throw new Error("Url is not provided");
  if (!n.fetch)
    throw new Error("fetch is not provided");
  if (o.uri) {
    const c = `${n?.baseUrl || ""}/${o.uri}`, h = await (await n.fetch(c)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(h, i.byteOffset, i.byteLength);
    return;
  }
  const a = t.buffers.slice(0, i.buffer).reduce((c, l) => c + l.byteLength, 0);
  e.explicitBitstream = new Uint8Array(s.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);
}
function Sf(t) {
  const e = new DataView(t), s = e.getUint32(0, !0), n = e.getUint32(4, !0);
  return s + 2 ** 32 * n;
}
const L_ = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: M_,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: ix,
  options: {}
};
var Ve = null;
try {
  Ve = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Z(t, e, s) {
  this.low = t | 0, this.high = e | 0, this.unsigned = !!s;
}
Z.prototype.__isLong__;
Object.defineProperty(Z.prototype, "__isLong__", { value: !0 });
function be(t) {
  return (t && t.__isLong__) === !0;
}
function Rf(t) {
  var e = Math.clz32(t & -t);
  return t ? 31 - e : e;
}
Z.isLong = be;
var wf = {}, If = {};
function Cs(t, e) {
  var s, n, r;
  return e ? (t >>>= 0, (r = 0 <= t && t < 256) && (n = If[t], n) ? n : (s = K(t, 0, !0), r && (If[t] = s), s)) : (t |= 0, (r = -128 <= t && t < 128) && (n = wf[t], n) ? n : (s = K(t, t < 0 ? -1 : 0, !1), r && (wf[t] = s), s));
}
Z.fromInt = Cs;
function He(t, e) {
  if (isNaN(t))
    return e ? vt : Ze;
  if (e) {
    if (t < 0)
      return vt;
    if (t >= k_)
      return z_;
  } else {
    if (t <= -Bf)
      return Be;
    if (t + 1 >= Bf)
      return H_;
  }
  return t < 0 ? He(-t, e).neg() : K(t % cn | 0, t / cn | 0, e);
}
Z.fromNumber = He;
function K(t, e, s) {
  return new Z(t, e, s);
}
Z.fromBits = K;
var Si = Math.pow;
function tl(t, e, s) {
  if (t.length === 0)
    throw Error("empty string");
  if (typeof e == "number" ? (s = e, e = !1) : e = !!e, t === "NaN" || t === "Infinity" || t === "+Infinity" || t === "-Infinity")
    return e ? vt : Ze;
  if (s = s || 10, s < 2 || 36 < s)
    throw RangeError("radix");
  var n;
  if ((n = t.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (n === 0)
    return tl(t.substring(1), e, s).neg();
  for (var r = He(Si(s, 8)), i = Ze, o = 0; o < t.length; o += 8) {
    var a = Math.min(8, t.length - o), c = parseInt(t.substring(o, o + a), s);
    if (a < 8) {
      var l = He(Si(s, a));
      i = i.mul(l).add(He(c));
    } else
      i = i.mul(r), i = i.add(He(c));
  }
  return i.unsigned = e, i;
}
Z.fromString = tl;
function st(t, e) {
  return typeof t == "number" ? He(t, e) : typeof t == "string" ? tl(t, e) : K(t.low, t.high, typeof e == "boolean" ? e : t.unsigned);
}
Z.fromValue = st;
var vf = 65536, ox = 1 << 24, cn = vf * vf, k_ = cn * cn, Bf = k_ / 2, Mf = Cs(ox), Ze = Cs(0);
Z.ZERO = Ze;
var vt = Cs(0, !0);
Z.UZERO = vt;
var Ws = Cs(1);
Z.ONE = Ws;
var V_ = Cs(1, !0);
Z.UONE = V_;
var Ya = Cs(-1);
Z.NEG_ONE = Ya;
var H_ = K(-1, 2147483647, !1);
Z.MAX_VALUE = H_;
var z_ = K(-1, -1, !0);
Z.MAX_UNSIGNED_VALUE = z_;
var Be = K(0, -2147483648, !1);
Z.MIN_VALUE = Be;
var O = Z.prototype;
O.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
O.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * cn + (this.low >>> 0) : this.high * cn + (this.low >>> 0);
};
O.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(Be)) {
      var s = He(e), n = this.div(s), r = n.mul(s).sub(this);
      return n.toString(e) + r.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var i = He(Si(e, 6), this.unsigned), o = this, a = ""; ; ) {
    var c = o.div(i), l = o.sub(c.mul(i)).toInt() >>> 0, h = l.toString(e);
    if (o = c, o.isZero())
      return h + a;
    for (; h.length < 6; )
      h = "0" + h;
    a = "" + h + a;
  }
};
O.getHighBits = function() {
  return this.high;
};
O.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
O.getLowBits = function() {
  return this.low;
};
O.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
O.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Be) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, s = 31; s > 0 && (e & 1 << s) == 0; s--)
    ;
  return this.high != 0 ? s + 33 : s + 1;
};
O.isZero = function() {
  return this.high === 0 && this.low === 0;
};
O.eqz = O.isZero;
O.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
O.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
O.isOdd = function() {
  return (this.low & 1) === 1;
};
O.isEven = function() {
  return (this.low & 1) === 0;
};
O.equals = function(e) {
  return be(e) || (e = st(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
O.eq = O.equals;
O.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
O.neq = O.notEquals;
O.ne = O.notEquals;
O.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
O.lt = O.lessThan;
O.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
O.lte = O.lessThanOrEqual;
O.le = O.lessThanOrEqual;
O.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
O.gt = O.greaterThan;
O.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
O.gte = O.greaterThanOrEqual;
O.ge = O.greaterThanOrEqual;
O.compare = function(e) {
  if (be(e) || (e = st(e)), this.eq(e))
    return 0;
  var s = this.isNegative(), n = e.isNegative();
  return s && !n ? -1 : !s && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
O.comp = O.compare;
O.negate = function() {
  return !this.unsigned && this.eq(Be) ? Be : this.not().add(Ws);
};
O.neg = O.negate;
O.add = function(e) {
  be(e) || (e = st(e));
  var s = this.high >>> 16, n = this.high & 65535, r = this.low >>> 16, i = this.low & 65535, o = e.high >>> 16, a = e.high & 65535, c = e.low >>> 16, l = e.low & 65535, h = 0, u = 0, f = 0, p = 0;
  return p += i + l, f += p >>> 16, p &= 65535, f += r + c, u += f >>> 16, f &= 65535, u += n + a, h += u >>> 16, u &= 65535, h += s + o, h &= 65535, K(f << 16 | p, h << 16 | u, this.unsigned);
};
O.subtract = function(e) {
  return be(e) || (e = st(e)), this.add(e.neg());
};
O.sub = O.subtract;
O.multiply = function(e) {
  if (this.isZero())
    return this;
  if (be(e) || (e = st(e)), Ve) {
    var s = Ve.mul(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return K(s, Ve.get_high(), this.unsigned);
  }
  if (e.isZero())
    return this.unsigned ? vt : Ze;
  if (this.eq(Be))
    return e.isOdd() ? Be : Ze;
  if (e.eq(Be))
    return this.isOdd() ? Be : Ze;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(Mf) && e.lt(Mf))
    return He(this.toNumber() * e.toNumber(), this.unsigned);
  var n = this.high >>> 16, r = this.high & 65535, i = this.low >>> 16, o = this.low & 65535, a = e.high >>> 16, c = e.high & 65535, l = e.low >>> 16, h = e.low & 65535, u = 0, f = 0, p = 0, m = 0;
  return m += o * h, p += m >>> 16, m &= 65535, p += i * h, f += p >>> 16, p &= 65535, p += o * l, f += p >>> 16, p &= 65535, f += r * h, u += f >>> 16, f &= 65535, f += i * l, u += f >>> 16, f &= 65535, f += o * c, u += f >>> 16, f &= 65535, u += n * h + r * l + i * c + o * a, u &= 65535, K(p << 16 | m, u << 16 | f, this.unsigned);
};
O.mul = O.multiply;
O.divide = function(e) {
  if (be(e) || (e = st(e)), e.isZero())
    throw Error("division by zero");
  if (Ve) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var s = (this.unsigned ? Ve.div_u : Ve.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return K(s, Ve.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? vt : Ze;
  var n, r, i;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return vt;
    if (e.gt(this.shru(1)))
      return V_;
    i = vt;
  } else {
    if (this.eq(Be)) {
      if (e.eq(Ws) || e.eq(Ya))
        return Be;
      if (e.eq(Be))
        return Ws;
      var o = this.shr(1);
      return n = o.div(e).shl(1), n.eq(Ze) ? e.isNegative() ? Ws : Ya : (r = this.sub(e.mul(n)), i = n.add(r.div(e)), i);
    } else if (e.eq(Be))
      return this.unsigned ? vt : Ze;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    i = Ze;
  }
  for (r = this; r.gte(e); ) {
    n = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));
    for (var a = Math.ceil(Math.log(n) / Math.LN2), c = a <= 48 ? 1 : Si(2, a - 48), l = He(n), h = l.mul(e); h.isNegative() || h.gt(r); )
      n -= c, l = He(n, this.unsigned), h = l.mul(e);
    l.isZero() && (l = Ws), i = i.add(l), r = r.sub(h);
  }
  return i;
};
O.div = O.divide;
O.modulo = function(e) {
  if (be(e) || (e = st(e)), Ve) {
    var s = (this.unsigned ? Ve.rem_u : Ve.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return K(s, Ve.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
O.mod = O.modulo;
O.rem = O.modulo;
O.not = function() {
  return K(~this.low, ~this.high, this.unsigned);
};
O.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
O.clz = O.countLeadingZeros;
O.countTrailingZeros = function() {
  return this.low ? Rf(this.low) : Rf(this.high) + 32;
};
O.ctz = O.countTrailingZeros;
O.and = function(e) {
  return be(e) || (e = st(e)), K(this.low & e.low, this.high & e.high, this.unsigned);
};
O.or = function(e) {
  return be(e) || (e = st(e)), K(this.low | e.low, this.high | e.high, this.unsigned);
};
O.xor = function(e) {
  return be(e) || (e = st(e)), K(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
O.shiftLeft = function(e) {
  return be(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? K(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : K(0, this.low << e - 32, this.unsigned);
};
O.shl = O.shiftLeft;
O.shiftRight = function(e) {
  return be(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? K(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : K(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
O.shr = O.shiftRight;
O.shiftRightUnsigned = function(e) {
  return be(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? K(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? K(this.high, 0, this.unsigned) : K(this.high >>> e - 32, 0, this.unsigned);
};
O.shru = O.shiftRightUnsigned;
O.shr_u = O.shiftRightUnsigned;
O.rotateLeft = function(e) {
  var s;
  return be(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? K(this.high, this.low, this.unsigned) : e < 32 ? (s = 32 - e, K(this.low << e | this.high >>> s, this.high << e | this.low >>> s, this.unsigned)) : (e -= 32, s = 32 - e, K(this.high << e | this.low >>> s, this.low << e | this.high >>> s, this.unsigned));
};
O.rotl = O.rotateLeft;
O.rotateRight = function(e) {
  var s;
  return be(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? K(this.high, this.low, this.unsigned) : e < 32 ? (s = 32 - e, K(this.high << s | this.low >>> e, this.low << s | this.high >>> e, this.unsigned)) : (e -= 32, s = 32 - e, K(this.low << s | this.high >>> e, this.high << s | this.low >>> e, this.unsigned));
};
O.rotr = O.rotateRight;
O.toSigned = function() {
  return this.unsigned ? K(this.low, this.high, !1) : this;
};
O.toUnsigned = function() {
  return this.unsigned ? this : K(this.low, this.high, !0);
};
O.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
O.toBytesLE = function() {
  var e = this.high, s = this.low;
  return [
    s & 255,
    s >>> 8 & 255,
    s >>> 16 & 255,
    s >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
O.toBytesBE = function() {
  var e = this.high, s = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    s >>> 24,
    s >>> 16 & 255,
    s >>> 8 & 255,
    s & 255
  ];
};
Z.fromBytes = function(e, s, n) {
  return n ? Z.fromBytesLE(e, s) : Z.fromBytesBE(e, s);
};
Z.fromBytesLE = function(e, s) {
  return new Z(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    s
  );
};
Z.fromBytesBE = function(e, s) {
  return new Z(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    s
  );
};
const ax = 16;
function j_(t) {
  t === "X" && (t = "");
  const e = t.padEnd(ax, "0");
  return Z.fromString(e, !0, 16);
}
function cx(t) {
  if (t.isZero())
    return "X";
  let e = t.countTrailingZeros();
  const s = e % 4;
  e = (e - s) / 4;
  const n = e;
  e *= 4;
  const i = t.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - n - i.length).join("0") + i;
}
function lx(t, e) {
  const s = hx(t).shiftRightUnsigned(2);
  return t.add(Z.fromNumber(2 * e + 1 - 4).multiply(s));
}
function hx(t) {
  return t.and(t.not().add(1));
}
const ux = 3, fx = 30, dx = 2 * fx + 1, Pf = 180 / Math.PI;
function px(t) {
  if (t.length === 0)
    throw new Error(`Invalid Hilbert quad key ${t}`);
  const e = t.split("/"), s = parseInt(e[0], 10), n = e[1], r = n.length;
  let i = 0;
  const o = [0, 0];
  for (let a = r - 1; a >= 0; a--) {
    i = r - a;
    const c = n[a];
    let l = 0, h = 0;
    c === "1" ? h = 1 : c === "2" ? (l = 1, h = 1) : c === "3" && (l = 1);
    const u = Math.pow(2, i - 1);
    gx(u, o, l, h), o[0] += u * l, o[1] += u * h;
  }
  if (s % 2 === 1) {
    const a = o[0];
    o[0] = o[1], o[1] = a;
  }
  return { face: s, ij: o, level: i };
}
function _x(t) {
  if (t.isZero())
    return "";
  let e = t.toString(2);
  for (; e.length < ux + dx; )
    e = "0" + e;
  const s = e.lastIndexOf("1"), n = e.substring(0, 3), r = e.substring(3, s), i = r.length / 2, o = Z.fromString(n, !0, 2).toString(10);
  let a = "";
  if (i !== 0)
    for (a = Z.fromString(r, !0, 2).toString(4); a.length < i; )
      a = "0" + a;
  return `${o}/${a}`;
}
function W_(t, e, s) {
  const n = 1 << e;
  return [(t[0] + s[0]) / n, (t[1] + s[1]) / n];
}
function Of(t) {
  return t >= 0.5 ? 1 / 3 * (4 * t * t - 1) : 1 / 3 * (1 - 4 * (1 - t) * (1 - t));
}
function X_(t) {
  return [Of(t[0]), Of(t[1])];
}
function G_(t, [e, s]) {
  switch (t) {
    case 0:
      return [1, e, s];
    case 1:
      return [-e, 1, s];
    case 2:
      return [-e, -s, 1];
    case 3:
      return [-1, -s, -e];
    case 4:
      return [s, -1, -e];
    case 5:
      return [s, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function $_([t, e, s]) {
  const n = Math.atan2(s, Math.sqrt(t * t + e * e));
  return [Math.atan2(e, t) * Pf, n * Pf];
}
function gx(t, e, s, n) {
  if (n === 0) {
    s === 1 && (e[0] = t - 1 - e[0], e[1] = t - 1 - e[1]);
    const r = e[0];
    e[0] = e[1], e[1] = r;
  }
}
function mx(t) {
  const e = W_(t.ij, t.level, [0.5, 0.5]), s = X_(e), n = G_(t.face, s);
  return $_(n);
}
const Ax = 100;
function xf(t) {
  const { face: e, ij: s, level: n } = t, r = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ], i = Math.max(1, Math.ceil(Ax * Math.pow(2, -n))), o = new Float64Array(4 * i * 2 + 2);
  let a = 0, c = 0;
  for (let l = 0; l < 4; l++) {
    const h = r[l].slice(0), u = r[l + 1], f = (u[0] - h[0]) / i, p = (u[1] - h[1]) / i;
    for (let m = 0; m < i; m++) {
      h[0] += f, h[1] += p;
      const A = W_(s, n, h), E = X_(A), C = G_(e, E), w = $_(C);
      Math.abs(w[1]) > 89.999 && (w[0] = c);
      const I = w[0] - c;
      w[0] += I > 180 ? -360 : I < -180 ? 360 : 0, o[a++] = w[0], o[a++] = w[1], c = w[0];
    }
  }
  return o[a++] = o[0], o[a++] = o[1], o;
}
function sl(t) {
  const e = Tx(t);
  return px(e);
}
function Tx(t) {
  if (t.indexOf("/") > 0)
    return t;
  const e = j_(t);
  return _x(e);
}
function yx(t) {
  const e = sl(t);
  return mx(e);
}
function bx(t) {
  let e;
  if (t.face === 2 || t.face === 5) {
    let s = null, n = 0;
    for (let r = 0; r < 4; r++) {
      const i = `${t.face}/${r}`, o = sl(i), a = xf(o);
      (typeof s > "u" || s === null) && (s = new Float64Array(4 * a.length)), s.set(a, n), n += a.length;
    }
    e = Nf(s);
  } else {
    const s = xf(t);
    e = Nf(s);
  }
  return e;
}
function Nf(t) {
  if (t.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], s = [];
  for (let n = 0; n < t.length; n += 2)
    e.push(t[n]), s.push(t[n + 1]);
  return e.sort((n, r) => n - r), s.sort((n, r) => n - r), {
    west: e[0],
    east: e[e.length - 1],
    north: s[s.length - 1],
    south: s[0]
  };
}
function Ex(t, e) {
  const s = e?.minimumHeight || 0, n = e?.maximumHeight || 0, r = sl(t), i = bx(r), o = i.west, a = i.south, c = i.east, l = i.north, h = [];
  return h.push(new S(o, l, s)), h.push(new S(c, l, s)), h.push(new S(c, a, s)), h.push(new S(o, a, s)), h.push(new S(o, l, n)), h.push(new S(c, l, n)), h.push(new S(c, a, n)), h.push(new S(o, a, n)), h;
}
function K_(t) {
  const e = t.token, s = {
    minimumHeight: t.minimumHeight,
    maximumHeight: t.maximumHeight
  }, n = Ex(e, s), r = yx(e), i = r[0], o = r[1], a = ne.WGS84.cartographicToCartesian([
    i,
    o,
    s.maximumHeight
  ]), c = new S(a[0], a[1], a[2]);
  n.push(c);
  const l = _v(n);
  return [...l.center, ...l.halfAxes];
}
const Cx = 4, Sx = 8, Rx = {
  QUADTREE: Cx,
  OCTREE: Sx
};
function wx(t, e, s) {
  if (t?.box) {
    const n = j_(t.s2VolumeInfo.token), r = lx(n, e), i = cx(r), o = { ...t.s2VolumeInfo };
    switch (o.token = i, s) {
      case "OCTREE":
        const l = t.s2VolumeInfo, h = l.maximumHeight - l.minimumHeight, u = h / 2, f = l.minimumHeight + h / 2;
        l.minimumHeight = f - u, l.maximumHeight = f + u;
        break;
    }
    return {
      box: K_(o),
      s2VolumeInfo: o
    };
  }
}
async function Y_(t) {
  const { subtree: e, subtreeData: s = {
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }, parentData: n = {
    mortonIndex: 0,
    localLevel: -1,
    localX: 0,
    localY: 0,
    localZ: 0
  }, childIndex: r = 0, implicitOptions: i, loaderOptions: o, s2VolumeBox: a } = t, { subdivisionScheme: c, subtreeLevels: l, maximumLevel: h, contentUrlTemplate: u, subtreesUriTemplate: f, basePath: p } = i, m = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!h)
    return jf.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${u} won't be loaded...`), m;
  const A = n.localLevel + 1, E = s.level + A;
  if (E > h)
    return m;
  const C = Rx[c], w = Math.log2(C), I = r & 1, B = r >> 1 & 1, x = r >> 2 & 1, N = os(n.localX, I, 1), L = os(n.localY, B, 1), k = os(n.localZ, x, 1), F = os(s.x, N, A), U = os(s.y, L, A), H = os(s.z, k, A), Y = os(n.mortonIndex, r, w), te = A === l && ia(e.childSubtreeAvailability, Y);
  let z, me, es, yt;
  if (te) {
    const nt = `${p}/${f}`, Ss = Ja(nt, E, F, U, H);
    z = await $t(Ss, L_, o), yt = 0, me = { level: E, x: F, y: U, z: H }, es = { mortonIndex: 0, localLevel: 0, localX: 0, localY: 0, localZ: 0 };
  } else
    z = e, yt = (C ** A - 1) / (C - 1) + Y, me = s, es = { mortonIndex: Y, localLevel: A, localX: N, localY: L, localZ: k };
  if (!ia(z.tileAvailability, yt))
    return m;
  ia(z.contentAvailability, yt) && (m.contentUrl = Ja(u, E, F, U, H));
  for (let nt = 0; nt < C; nt++) {
    const Ss = wx(a, nt, c), rt = await Y_({
      subtree: z,
      subtreeData: me,
      parentData: es,
      childIndex: nt,
      implicitOptions: i,
      loaderOptions: o,
      s2VolumeBox: Ss
    });
    (rt.contentUrl || rt.children.length) && m.children.push(rt);
  }
  return m.contentUrl || m.children.length ? Ix(m, { level: E, x: F, y: U, z: H }, i, a) : m;
}
function ia(t, e) {
  let s;
  return Array.isArray(t) ? (s = t[0], t.length > 1 && jf.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : s = t, "constant" in s ? !!s.constant : s.explicitBitstream ? Mx(e, s.explicitBitstream) : !1;
}
function Ix(t, e, s, n) {
  const { basePath: r, refine: i, getRefine: o, lodMetricType: a, getTileType: c, rootLodMetricValue: l, rootBoundingVolume: h } = s, u = t.contentUrl && t.contentUrl.replace(`${r}/`, ""), f = l / 2 ** e.level, p = n?.box ? { box: n.box } : h, m = vx(p, e, s.subdivisionScheme);
  return {
    children: t.children,
    contentUrl: t.contentUrl,
    content: { uri: u },
    id: t.contentUrl,
    refine: o(i),
    type: c(t),
    lodMetricType: a,
    lodMetricValue: f,
    geometricError: f,
    transform: t.transform,
    boundingVolume: m
  };
}
function vx(t, e, s) {
  if (t.region) {
    const { level: n, x: r, y: i, z: o } = e, [a, c, l, h, u, f] = t.region, p = 2 ** n, m = (l - a) / p, [A, E] = [a + m * r, a + m * (r + 1)], C = (h - c) / p, [w, I] = [c + C * i, c + C * (i + 1)];
    let B, x;
    if (s === "OCTREE") {
      const N = (f - u) / p;
      [B, x] = [
        u + N * o,
        u + N * (o + 1)
      ];
    } else
      [B, x] = [u, f];
    return {
      region: [A, w, E, I, B, x]
    };
  }
  if (t.box)
    return t;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(t)}`);
}
function os(t, e, s) {
  return (t << s) + e;
}
function Ja(t, e, s, n, r) {
  const i = Bx({ level: e, x: s, y: n, z: r });
  return t.replace(/{level}|{x}|{y}|{z}/gi, (o) => i[o]);
}
function Bx(t) {
  const e = {};
  for (const s in t)
    e[`{${s}}`] = t[s];
  return e;
}
function Mx(t, e) {
  const s = Math.floor(t / 8), n = t % 8;
  return (e[s] >> n & 1) === 1;
}
function nl(t, e = "") {
  if (!e)
    return It.EMPTY;
  const n = e.split("?")[0].split(".").pop();
  switch (n) {
    case "pnts":
      return It.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return It.SCENEGRAPH;
    default:
      return n || It.EMPTY;
  }
}
function rl(t) {
  switch (t) {
    case "REPLACE":
    case "replace":
      return et.REPLACE;
    case "ADD":
    case "add":
      return et.ADD;
    default:
      return t;
  }
}
function qa(t, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const n = new URL(t, `${e}/`);
    return decodeURI(n.toString());
  } else if (t.startsWith("/"))
    return t;
  return Um(e, t);
}
function Ff(t, e) {
  if (!t)
    return null;
  let s;
  if (t.content) {
    const r = t.content.uri || t.content?.url;
    typeof r < "u" && (s = qa(r, e));
  }
  return {
    ...t,
    id: s,
    contentUrl: s,
    lodMetricType: an.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: nl(t, s),
    refine: rl(t.refine)
  };
}
async function Px(t, e, s) {
  let n = null;
  const r = Uf(t.root);
  r && t.root ? n = await Df(t.root, t, e, r, s) : n = Ff(t.root, e);
  const i = [];
  for (i.push(n); i.length > 0; ) {
    const o = i.pop() || {}, a = o.children || [], c = [];
    for (const l of a) {
      const h = Uf(l);
      let u;
      h ? u = await Df(l, t, e, h, s) : u = Ff(l, e), u && (c.push(u), i.push(u));
    }
    o.children = c;
  }
  return n;
}
async function Df(t, e, s, n, r) {
  const { subdivisionScheme: i, maximumLevel: o, availableLevels: a, subtreeLevels: c, subtrees: { uri: l } } = n, h = Ja(l, 0, 0, 0, 0), u = qa(h, s), f = await $t(u, L_, r), p = t.content?.uri, m = p ? qa(p, s) : "", A = e?.root?.refine, E = t.geometricError, C = t.boundingVolume.extensions?.["3DTILES_bounding_volume_S2"];
  if (C) {
    const x = { box: K_(C), s2VolumeInfo: C };
    t.boundingVolume = x;
  }
  const w = t.boundingVolume, I = {
    contentUrlTemplate: m,
    subtreesUriTemplate: l,
    subdivisionScheme: i,
    subtreeLevels: c,
    maximumLevel: Number.isFinite(a) ? a - 1 : o,
    refine: A,
    basePath: s,
    lodMetricType: an.GEOMETRIC_ERROR,
    rootLodMetricValue: E,
    rootBoundingVolume: w,
    getTileType: nl,
    getRefine: rl
  };
  return await Ox(t, s, f, I, r);
}
async function Ox(t, e, s, n, r) {
  if (!t)
    return null;
  const { children: i, contentUrl: o } = await Y_({
    subtree: s,
    implicitOptions: n,
    loaderOptions: r
  });
  let a, c = null;
  return o && (a = o, c = { uri: o.replace(`${e}/`, "") }), {
    ...t,
    id: a,
    contentUrl: a,
    lodMetricType: an.GEOMETRIC_ERROR,
    lodMetricValue: t.geometricError,
    transformMatrix: t.transform,
    type: nl(t, a),
    refine: rl(t.refine),
    content: c || t.content,
    children: i
  };
}
function Uf(t) {
  return t?.extensions?.["3DTILES_implicit_tiling"] || t?.implicitTiling;
}
const J_ = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: M_,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: xx,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function xx(t, e = {}, s) {
  const n = e["3d-tiles"] || {};
  let r;
  return n.isTileset === "auto" ? r = s?.url && s.url.indexOf(".json") !== -1 : r = n.isTileset, r ? Nx(t, e, s) : Fx(t, e, s);
}
async function Nx(t, e, s) {
  const n = JSON.parse(new TextDecoder().decode(t)), r = s?.url || "", i = Dx(r), o = await Px(n, i, e || {});
  return {
    ...n,
    shape: "tileset3d",
    loader: J_,
    url: r,
    queryString: s?.queryString || "",
    basePath: i,
    root: o || n.root,
    type: Ie.TILES3D,
    lodMetricType: an.GEOMETRIC_ERROR,
    lodMetricValue: n.root?.geometricError || 0
  };
}
async function Fx(t, e, s) {
  const n = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await U_(t, 0, e, s, n.content), n.content;
}
function Dx(t) {
  return tc(t);
}
const Lf = [0], Ux = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: J_,
  onTilesetLoad: { type: "function", value: (t) => {
  } },
  onTileLoad: { type: "function", value: (t) => {
  } },
  onTileUnload: { type: "function", value: (t) => {
  } },
  onTileError: { type: "function", value: (t, e, s) => {
  } },
  _getMeshColor: { type: "function", value: (t) => [255, 255, 255] }
};
class il extends qp {
  initializeState() {
    "onTileLoadFail" in this.props && $.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    return !!(this.state?.tileset3d?.isLoaded() && super.isLoaded);
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState({ props: e, oldProps: s, changeFlags: n }) {
    if (e.data && e.data !== s.data && this._loadTileset(e.data), n.viewportChanged) {
      const { activeViewports: r } = this.state;
      Object.keys(r).length && (this._updateTileset(r), this.state.lastUpdatedViewports = r, this.state.activeViewports = {});
    }
    if (n.propsChanged) {
      const { layerMap: r } = this.state;
      for (const i in r)
        r[i].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const { activeViewports: s, lastUpdatedViewports: n } = this.state;
    this.internalState.viewport = e, s[e.id] = e;
    const r = n?.[e.id];
    (!r || !e.equals(r)) && (this.setChangeFlags({ viewportChanged: !0 }), this.setNeedsUpdate());
  }
  getPickingInfo({ info: e, sourceLayer: s }) {
    const n = s && s.props.tile;
    return e.picked && (e.object = n), e.sourceTile = n, e;
  }
  filterSubLayer({ layer: e, viewport: s }) {
    const { tile: n } = e.props, { id: r } = s;
    return n.selected && n.viewportIds.includes(r);
  }
  _updateAutoHighlight(e) {
    const s = e.sourceTile, n = this.state.layerMap[s?.id];
    n && n.layer && n.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const { loadOptions: s = {} } = this.props, n = this.props.loader || this.props.loaders, r = Array.isArray(n) ? n[0] : n, i = { loadOptions: { ...s } };
    let o = e;
    if (r.preload) {
      const l = await r.preload(e, s);
      l.url && (o = l.url), l.headers && (i.loadOptions.fetch = {
        ...i.loadOptions.fetch,
        headers: l.headers
      }), Object.assign(i, l);
    }
    const a = await $t(o, r, i.loadOptions), c = new mO(a, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...i
    });
    this.setState({
      tileset3d: c,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(c);
  }
  _onTileLoad(e) {
    const { lastUpdatedViewports: s } = this.state;
    this.props.onTileLoad(e), this._updateTileset(s), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const { tileset3d: s } = this.state, { timeline: n } = this.context, r = Object.keys(e).length;
    !n || !r || !s || s.selectTiles(Object.values(e)).then((i) => {
      this.state.frameNumber !== i && this.setState({ frameNumber: i });
    });
  }
  _getSubLayer(e, s) {
    if (!e.content)
      return null;
    switch (e.type) {
      case It.POINTCLOUD:
        return this._makePointCloudLayer(e, s);
      case It.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case It.MESH:
        return this._makeSimpleMeshLayer(e, s);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, s) {
    const { attributes: n, pointCount: r, constantRGBA: i, cartographicOrigin: o, modelMatrix: a } = e.content, { positions: c, normals: l, colors: h } = n;
    if (!c)
      return null;
    const u = s && s.props.data || {
      header: {
        vertexCount: r
      },
      attributes: {
        POSITION: c,
        NORMAL: l,
        COLOR_0: h
      }
    }, { pointSize: f, getPointColor: p } = this.props, m = this.getSubLayerClass("pointcloud", zc);
    return new m({
      pointSize: f
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: u,
      coordinateSystem: X.METER_OFFSETS,
      coordinateOrigin: o,
      modelMatrix: a,
      getColor: i || p,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const { gltf: s, instances: n, cartographicOrigin: r, modelMatrix: i } = e.content, o = this.getSubLayerClass("scenegraph", Jc);
    return new o({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: n || Lf,
      scenegraph: s,
      coordinateSystem: X.METER_OFFSETS,
      coordinateOrigin: r,
      modelMatrix: i,
      getTransformMatrix: (a) => a.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, s) {
    const n = e.content, { attributes: r, indices: i, modelMatrix: o, cartographicOrigin: a, coordinateSystem: c = X.METER_OFFSETS, material: l, featureIds: h } = n, { _getMeshColor: u } = this.props, f = s && s.props.mesh || new Ks({
      topology: "triangle-list",
      attributes: Lx(r),
      indices: i
    }), p = this.getSubLayerClass("mesh", qc);
    return new p(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: f,
      data: Lf,
      getColor: u(e),
      pbrMaterial: l,
      modelMatrix: o,
      coordinateOrigin: a,
      coordinateSystem: c,
      featureIds: h,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d: e, layerMap: s } = this.state;
    return e ? e.tiles.map((n) => {
      const r = s[n.id] = s[n.id] || { tile: n };
      let { layer: i } = r;
      return n.selected && (i ? r.needsUpdate && (i = this._getSubLayer(n, i), r.needsUpdate = !1) : i = this._getSubLayer(n)), r.layer = i, i;
    }).filter(Boolean) : null;
  }
}
il.defaultProps = Ux;
il.layerName = "Tile3DLayer";
function Lx(t) {
  const e = {};
  return e.positions = {
    ...t.positions,
    value: new Float32Array(t.positions.value)
  }, t.normals && (e.normals = t.normals), t.texCoords && (e.texCoords = t.texCoords), t.colors && (e.colors = t.colors), t.uvRegions && (e.uvRegions = t.uvRegions), e;
}
const oa = 512, kx = Math.PI / 180;
function q_({ map: t, gl: e, deck: s }) {
  if (t.__deck)
    return t.__deck;
  const n = s?.props._customRender, r = s?.props.onLoad, i = Q_({
    ...s?.props,
    _customRender: () => {
      t.triggerRepaint(), n?.("");
    }
  });
  let o;
  return (!s || s.props.gl === e) && (Object.assign(i, {
    gl: e,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: tr(t)
  }), s?.isInitialized ? kf(s, t) : i.onLoad = () => {
    r?.(), kf(o, t);
  }), s ? (o = s, s.setProps(i), s.userData.isExternal = !0) : (o = new Zn(i), t.on("remove", () => {
    Z_(t);
  })), o.userData.mapboxLayers = /* @__PURE__ */ new Set(), t.__deck = o, t.on("render", () => {
    o.isInitialized && Xx(o, t);
  }), o;
}
function kf(t, e) {
  const s = () => {
    t.isInitialized ? Gx(t, e) : e.off("move", s);
  };
  e.on("move", s);
}
function Z_(t) {
  t.__deck?.finalize(), t.__deck = null;
}
function Q_(t) {
  return {
    ...t,
    // TODO: remove with withParametersWebGL
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...t.parameters
    },
    // @ts-ignore views prop is hidden by the types because it is not expected to work the same way as in standalone Deck, see documentation
    views: t.views || [new Fc({ id: "mapbox" })]
  };
}
function Vx(t, e) {
  t.userData.mapboxLayers.add(e), ol(t);
}
function Hx(t, e) {
  t.userData.mapboxLayers.delete(e), ol(t);
}
function zx(t, e) {
  ol(t);
}
function jx(t, e, s) {
  let { currentViewport: n } = t.userData, r = !1;
  n || (n = eg(t, e, !0), t.userData.currentViewport = n, r = !0), t.isInitialized && t._drawLayers("mapbox-repaint", {
    viewports: [n],
    layerFilter: ({ layer: i }) => s.id === i.id || i.props.operation.includes("terrain"),
    clearStack: r,
    clearCanvas: !1
  });
}
function tr(t) {
  const { lng: e, lat: s } = t.getCenter(), n = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: s,
    zoom: t.getZoom(),
    bearing: t.getBearing(),
    pitch: t.getPitch(),
    padding: t.getPadding(),
    repeat: t.getRenderWorldCopies()
  };
  return t.getTerrain?.() && Wx(t, n), n;
}
function Wx(t, e) {
  if (t.getFreeCameraOptions) {
    const { position: s } = t.getFreeCameraOptions();
    if (!s || s.z === void 0)
      return;
    const n = t.transform.height, { longitude: r, latitude: i, pitch: o } = e, a = s.x * oa, c = (1 - s.y) * oa, l = s.z * oa, h = Kn([r, i]), u = a - h[0], f = c - h[1], p = Math.sqrt(u * u + f * f), m = o * kx, A = 1.5 * n, E = m < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      A * Math.cos(m) / l
    ) : A * Math.sin(m) / p;
    e.zoom = Math.log2(E);
    const C = A * Math.cos(m) / E, w = l - C;
    e.position = [0, 0, w / ti(i)];
  } else typeof t.transform.elevation == "number" && (e.position = [0, 0, t.transform.elevation]);
}
function eg(t, e, s = !0) {
  return new ms({
    id: "mapbox",
    x: 0,
    y: 0,
    width: t.width,
    height: t.height,
    ...tr(e),
    nearZMultiplier: s ? (
      // match mapbox-gl@>=1.3.0's projection matrix
      0.02
    ) : (
      // use deck.gl's own default
      0.1
    ),
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function Xx(t, e) {
  const { mapboxLayers: s, isExternal: n } = t.userData;
  if (n) {
    const r = Array.from(s, (h) => h.id), o = nn(t.props.layers, Boolean).some((h) => h && !r.includes(h.id));
    let a = t.getViewports();
    const c = a.findIndex((h) => h.id === "mapbox"), l = a.length > 1 || c < 0;
    (o || l) && (c >= 0 && (a = a.slice(), a[c] = eg(t, e, !1)), t._drawLayers("mapbox-repaint", {
      viewports: a,
      layerFilter: (h) => (!t.props.layerFilter || t.props.layerFilter(h)) && (h.viewport.id !== "mapbox" || !r.includes(h.layer.id)),
      clearCanvas: !1
    }));
  }
  t.userData.currentViewport = null;
}
function Gx(t, e) {
  t.setProps({
    viewState: tr(e)
  }), t.needsRedraw({ clearRedrawFlags: !0 });
}
function ol(t) {
  if (t.userData.isExternal)
    return;
  const e = [];
  t.userData.mapboxLayers.forEach((s) => {
    const n = s.props.type, r = new n(s.props);
    e.push(r);
  }), t.setProps({ layers: e });
}
class $x {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, s) {
    this.map = e, this.deck = q_({ map: e, gl: s, deck: this.props.deck }), Vx(this.deck, this);
  }
  onRemove() {
    this.deck && Hx(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, { id: this.id }), this.deck && zx(this.deck);
  }
  render() {
    jx(this.deck, this.map, this);
  }
}
const aa = "__UNDEFINED__";
function qr(t, e, s, n) {
  if (!t || !e || !t.style || !t.style._loaded)
    return;
  const r = nn(n, Boolean);
  if (s !== n) {
    const a = nn(s, Boolean), c = new Set(a.map((l) => l.id));
    for (const l of r)
      c.delete(l.id);
    for (const l of c)
      t.getLayer(l) && t.removeLayer(l);
  }
  for (const a of r) {
    const c = t.getLayer(a.id);
    c ? (c.implementation || c).setProps(a.props) : t.addLayer(
      new $x({ id: a.id, deck: e }),
      // @ts-expect-error beforeId is not defined in LayerProps
      a.props.beforeId
    );
  }
  const i = t.style._order, o = {};
  for (const a of r) {
    let { beforeId: c } = a.props;
    (!c || !i.includes(c)) && (c = aa), o[c] = o[c] || [], o[c].push(a.id);
  }
  for (const a in o) {
    const c = o[a];
    let l = a === aa ? i.length : i.indexOf(a), h = a === aa ? void 0 : a;
    for (let u = c.length - 1; u >= 0; u--) {
      const f = c[u], p = i.indexOf(f);
      p !== l - 1 && (t.moveLayer(f, h), p > l && l++), l--, h = f;
    }
  }
}
class Kx {
  constructor(e) {
    this._handleStyleChange = () => {
      qr(this._map, this._deck, this._props.layers, this._props.layers);
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const { clientWidth: r, clientHeight: i } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${r}px`,
          height: `${i}px`
        });
      }
    }, this._updateViewState = () => {
      const r = this._deck;
      r && (r.setProps({ viewState: tr(this._map) }), r.isInitialized && r.redraw());
    }, this._handleMouseEvent = (r) => {
      const i = this._deck;
      if (!i || !i.isInitialized)
        return;
      const o = {
        type: r.type,
        offsetCenter: r.point,
        srcEvent: r
      }, a = this._lastMouseDownPoint;
      switch (!r.point && a && (o.deltaX = r.originalEvent.clientX - a.clientX, o.deltaY = r.originalEvent.clientY - a.clientY, o.offsetCenter = {
        x: a.x + o.deltaX,
        y: a.y + o.deltaY
      }), o.type) {
        case "mousedown":
          i._onPointerDown(o), this._lastMouseDownPoint = {
            ...r.point,
            clientX: r.originalEvent.clientX,
            clientY: r.originalEvent.clientY
          };
          break;
        case "dragstart":
          o.type = "panstart", i._onEvent(o);
          break;
        case "drag":
          o.type = "panmove", i._onEvent(o);
          break;
        case "dragend":
          o.type = "panend", i._onEvent(o);
          break;
        case "click":
          o.tapCount = 1, i._onEvent(o);
          break;
        case "dblclick":
          o.type = "click", o.tapCount = 2, i._onEvent(o);
          break;
        case "mousemove":
          o.type = "pointermove", i._onPointerMove(o);
          break;
        case "mouseout":
          o.type = "pointerleave", i._onPointerMove(o);
          break;
        default:
          return;
      }
    };
    const { interleaved: s = !1, ...n } = e;
    this._interleaved = s, this._props = n;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && qr(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, e), this._deck && this._deck.setProps(this._interleaved ? Q_(this._props) : this._props);
  }
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const s = document.createElement("div");
    return Object.assign(s.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = s, this._deck = new Zn({
      ...this._props,
      parent: s,
      viewState: tr(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), s;
  }
  _onAddInterleaved(e) {
    const s = e.painter.context.gl;
    return s instanceof WebGLRenderingContext && $.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = q_({
      map: e,
      gl: s,
      deck: new Zn({
        ...this._props,
        gl: s
      })
    }), e.on("styledata", this._handleStyleChange), qr(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), this._deck?.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), qr(e, this._deck, this._props.layers, []), Z_(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return ue(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return ue(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return ue(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
class Yx {
  olaMaps;
  apiKey;
  accessToken;
  mode;
  threedTileset;
  // Static properties to expose MapLibre GL components through OlaMaps
  static Marker = V.Marker;
  static Popup = V.Popup;
  static NavigationControl = V.NavigationControl;
  static GeolocateControl = V.GeolocateControl;
  static ScaleControl = V.ScaleControl;
  static FullscreenControl = V.FullscreenControl;
  static AttributionControl = V.AttributionControl;
  static TerrainControl = V.TerrainControl;
  static LogoControl = V.LogoControl;
  static GlobeControl = V.GlobeControl;
  // Static utility classes
  static LngLat = V.LngLat;
  static LngLatBounds = V.LngLatBounds;
  static Point = V.Point;
  static MercatorCoordinate = V.MercatorCoordinate;
  // Static source classes
  static GeoJSONSource = V.GeoJSONSource;
  static VectorTileSource = V.VectorTileSource;
  static RasterTileSource = V.RasterTileSource;
  static RasterDEMTileSource = V.RasterDEMTileSource;
  static ImageSource = V.ImageSource;
  static VideoSource = V.VideoSource;
  static CanvasSource = V.CanvasSource;
  // Static event classes
  static MapMouseEvent = V.MapMouseEvent;
  static MapTouchEvent = V.MapTouchEvent;
  static MapWheelEvent = V.MapWheelEvent;
  // Static error classes
  static AJAXError = V.AJAXError;
  // Static handler classes
  static BoxZoomHandler = V.BoxZoomHandler;
  static CooperativeGesturesHandler = V.CooperativeGesturesHandler;
  static DoubleClickZoomHandler = V.DoubleClickZoomHandler;
  static DragPanHandler = V.DragPanHandler;
  static DragRotateHandler = V.DragRotateHandler;
  static KeyboardHandler = V.KeyboardHandler;
  static ScrollZoomHandler = V.ScrollZoomHandler;
  static TwoFingersTouchPitchHandler = V.TwoFingersTouchPitchHandler;
  static TwoFingersTouchRotateHandler = V.TwoFingersTouchRotateHandler;
  static TwoFingersTouchZoomHandler = V.TwoFingersTouchZoomHandler;
  static TwoFingersTouchZoomRotateHandler = V.TwoFingersTouchZoomRotateHandler;
  // Static utility classes
  static EdgeInsets = V.EdgeInsets;
  static Event = V.Event;
  static Evented = V.Evented;
  static Hash = V.Hash;
  static Style = V.Style;
  constructor({ apiKey: e, accessToken: s = "", mode: n = "2d", threedTileset: r = Og }) {
    this.apiKey = e, this.mode = n, this.threedTileset = r, this.accessToken = s;
  }
  addOlaLogo(e) {
    if (typeof window > "u") return;
    const s = document.getElementsByClassName("maplibregl-ctrl-bottom-left");
    let n = "#000";
    e.style?.includes("dark") && (n = "#FFF");
    for (let r = 0; r < s.length; r++) {
      const i = document.createElement("div");
      i.style.position = "absolute", i.style.bottom = "4px", i.style.left = "10px", i.style.zIndex = "1000", i.innerHTML = xg(n), s[r].appendChild(i);
    }
  }
  addAttribution(e) {
    const s = document.querySelectorAll(".maplibregl-ctrl-bottom-right .maplibregl-ctrl-attrib-inner"), n = e?.style || "";
    s?.forEach((r) => {
      const i = r.querySelector("a");
      i && (i.style.display = "none");
      const o = "ola-maps-link";
      if (!r.querySelector(`#${o}`)) {
        const l = document.createElement("a");
        l.id = o, l.href = "https://maps.olakrutrim.com/", l.target = "_blank", l.textContent = "Ola Maps ", r.appendChild(l);
      }
      const a = "osm-link";
      if (!r.querySelector(`#${a}`)) {
        const l = document.createElement("a");
        l.id = a, l.href = "https://www.openstreetmap.org/copyright", l.target = "_blank", l.textContent = "|  OpenStreetMap contributors", r.appendChild(l);
      }
      const c = "copernicus-attrib";
      if (n.includes("default-dark-standard-satellite") && !r.querySelector(`#${c}`)) {
        const l = document.createElement("span");
        l.id = c, l.textContent = " | Contains modified Copernicus Sentinel-2 data 2024", r.appendChild(l);
      }
    });
  }
  fetchStaticMap(e) {
    try {
      return fetch(e).then((s) => s.blob());
    } catch (s) {
      console.log(s);
    }
  }
  async add3dLayer() {
    if (!this.threedTileset)
      throw new Error("3d Tileset is not initialized");
    const e = new il({
      id: "tile-3d-layer",
      data: `${this.threedTileset}?api_key=${this.apiKey}`,
      beforeId: "poi_railway"
    }), s = new Kx({
      interleaved: !0,
      layers: [e]
    });
    s && this.olaMaps.on("style.load", () => {
      this.olaMaps.setFilter("building-3d", [
        "all",
        [
          "!has",
          "hide_3d"
        ],
        [
          "!=",
          "render_as_3d",
          !0
        ]
      ]), this.olaMaps.addControl(s);
    });
  }
  init(e) {
    this.olaMaps = new V.Map({
      container: e?.container || "map",
      center: e?.center || [0, 0],
      zoom: e?.zoom || 9,
      hash: e?.hash || !1,
      style: e?.style || Ng,
      transformRequest: (r, i) => {
        if (this.accessToken)
          return {
            url: r,
            headers: { Authorization: `Bearer ${this.accessToken}` }
          };
        {
          const o = new URL(r);
          return i !== "Image" && o.searchParams.append("api_key", this.apiKey), {
            url: o.toString()
          };
        }
      },
      ...e
    }), this.mode === "3d" && this.add3dLayer(), this.addOlaLogo(e), this.addAttribution({ style: e?.style });
    const s = {};
    return Object.getOwnPropertyNames(V.Map.prototype).forEach((r) => {
      typeof this.olaMaps[r] == "function" && (s[r] = this.olaMaps[r].bind(this.olaMaps));
    }), Object.keys(Er).forEach((r) => {
      typeof Er[r] == "function" ? s[r] = (...i) => new Er[r](...i) : s[r] = Er[r];
    }), Object.getOwnPropertyNames(this.olaMaps).forEach((r) => {
      r in s || (s[r] = this.olaMaps[r]);
    }), Object.assign(this.olaMaps, s);
  }
  addNavigationControls(e) {
    return new V.NavigationControl(e);
  }
  addGeolocateControls(e) {
    return new V.GeolocateControl(e);
  }
  getMercatorCoordinate() {
    return V.MercatorCoordinate;
  }
  addMarker(e) {
    return new V.Marker(e);
  }
  addPopup(e) {
    return new V.Popup(e);
  }
  getStaticMap(e, s) {
    this.fetchStaticMap(e)?.then((r) => {
      const i = URL.createObjectURL(r), o = document.createElement("img");
      o.src = i;
      const a = document.getElementById(s);
      a && !a.querySelector("img") ? a?.appendChild(o) : console.log("An image already exists in the element.");
    }).catch((r) => console.error(r));
  }
}
typeof window < "u" && (window.OlaMaps = Yx);
export {
  Yx as OlaMaps
};
